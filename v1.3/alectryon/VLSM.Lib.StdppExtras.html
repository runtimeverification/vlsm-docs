<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>StdppExtras.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.18.0+0.18.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk0"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> Itauto.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file coq-itauto.plugin ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> prelude.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> Preamble ListExtras.</span></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Utility: Std++ General Results</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1"><span class="kn">Lemma</span> <span class="nf">elem_of_take</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A) :
  elem_of x (take n l) -&gt; elem_of x l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ take n l → x ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ take n l → x ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3"><span class="nb">generalize dependent</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4"><span class="nb">induction</span> l; <span class="nb">intros</span> n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n (a :: l)</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk5"><hr></label><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">simpl</span> <span class="kr">in</span> H; <span class="nb">destruct</span> n; <span class="nb">simpl</span> <span class="kr">in</span> H; <span class="nb">inversion</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8"><span class="nb">destruct</span> n; [<span class="bp">by</span> <span class="nb">inversion</span> H |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take (S n) (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ a :: take n l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka"><span class="nb">apply</span> elem_of_cons <span class="kr">in</span> H <span class="kr">as</span> [-&gt; | H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, a ∈ take n l → a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a :: l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n l</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkb"><hr></label><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, a ∈ take n l → a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">eapply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke"><span class="kn">Lemma</span> <span class="nf">map_tail</span> [A B : <span class="kt">Type</span>] (f : A -&gt; B) (l : list A) :
  map f (tail l) = tail (map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (tail l) = tail (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (tail l) = tail (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk10"><span class="kn">Lemma</span> <span class="nf">nth_error_stdpp_last</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) :
  nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk12"><span class="nb">induction</span> l; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (a :: l) (length (a :: l) - <span class="mi">1</span>) =
<span class="nb">last</span> (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13"><span class="nb">destruct</span> l; [<span class="bp">done</span> |]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth_error (a0 :: l) (length l - <span class="mi">0</span>) = <span class="nb">last</span> (a0 :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (a0 :: l) (length l) = <span class="nb">last</span> (a0 :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- IHl, Nat.sub_0_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk14"><span class="kn">Lemma</span> <span class="nf">last_last_error</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) :
  last_error l = <span class="nb">last</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error l = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error l = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16"><span class="nb">induction</span> l; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>last_error l = <span class="nb">last</span> l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error (a :: l) = <span class="nb">last</span> (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk17"><span class="nb">rewrite</span> last_cons, &lt;- IHl; <span class="nb">clear</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error (a :: l) =
<span class="kr">match</span> last_error l <span class="kr">with</span>
| Some y =&gt; Some y
| None =&gt; Some a
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk18"><span class="nb">destruct</span> l; [<span class="bp">done</span> |]; <span class="nb">cbn</span>; <span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a0
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> = List.<span class="nb">last</span> l a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19"><span class="nb">induction</span> l; [<span class="bp">done</span> |]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0, a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a0
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> = List.<span class="nb">last</span> l a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> =
<span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt; List.<span class="nb">last</span> l a0
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0, a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a0
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> = List.<span class="nb">last</span> l a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> =
<span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt;
    <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; a0
    | _ :: _ =&gt; List.<span class="nb">last</span> l a
    <span class="kr">end</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b"><span class="kn">Lemma</span> <span class="nf">existsb_Exists</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; bool) :
  <span class="kr">forall</span> <span class="nv">l</span>, existsb f l = true &lt;-&gt; Exists (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x = true) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = true ↔ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = true ↔ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1d"><span class="nb">intro</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb f l = true ↔ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1e"><span class="nb">rewrite</span> Exists_exists, existsb_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∃</span> <span class="nv">x</span> : A, In x l ∧ f x = true)
↔ (<span class="kr">∃</span> <span class="nv">x</span> : A, x ∈ l ∧ f x = true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1f"><span class="nb">apply</span> exist_proper; <span class="nb">intros</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In x l ∧ f x = true ↔ x ∈ l ∧ f x = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> elem_of_list_In.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk20"><span class="kn">Lemma</span> <span class="nf">Exists_last</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">l</span> : list A)
  (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>)
  (<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a))
  (<span class="nv">Hsomething</span> : Exists P l)
  : <span class="kr">exists</span> (<span class="nv">prefix</span> : list A)
         (<span class="nv">suffix</span> : list A)
         (<span class="nv">last</span> : A),
         P <span class="nb">last</span> /\
         l = prefix ++ [<span class="nb">last</span>] ++ suffix /\
         ~ Exists P suffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk22"><span class="nb">induction</span> l <span class="nb">using</span> rev_ind; [<span class="bp">by</span> <span class="nb">inversion</span> Hsomething |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk23"><span class="nb">destruct</span> (decide (P x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk24"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk25">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk26"><span class="kr">exists</span> <span class="nv">l</span>, nil, x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x ∧ l ++ [x] = l ++ [x] ++ [] ∧ ¬ Exists P []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk27"><span class="nb">rewrite</span> Exists_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x ∧ l ++ [x] = l ++ [x] ++ [] ∧ ¬ <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk29"><span class="nb">apply</span> Exists_app <span class="kr">in</span> Hsomething.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P l ∨ Exists P [x]</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2a"><span class="nb">destruct</span> Hsomething; [| <span class="bp">by</span> <span class="nb">inversion</span> H; [| <span class="nb">inversion</span> H1]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P l</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2b"><span class="nb">specialize</span> (IHl H); <span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2c"><span class="nb">destruct</span> IHl <span class="kr">as</span> [prefix [suffix [<span class="nb">last</span> [Hf [-&gt; Hnone_after]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix0</span> <span class="nv">suffix0</span> : list A) (<span class="nv">last0</span> : A),
  P last0
  ∧ (prefix ++ [<span class="nb">last</span>] ++ suffix) ++ [x] =
    prefix0 ++ [last0] ++ suffix0 ∧ ¬ Exists P suffix0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2d"><span class="kr">exists</span> <span class="nv">prefix</span>, (suffix ++ [x]), <span class="nb">last</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ (prefix ++ [<span class="nb">last</span>] ++ suffix) ++ [x] =
  prefix ++ [<span class="nb">last</span>] ++ suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ (prefix ++ <span class="nb">last</span> :: suffix) ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2f"><span class="nb">rewrite</span> &lt;- app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ (<span class="nb">last</span> :: suffix) ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk30"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk31"><span class="nb">rewrite</span> Exists_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ (Exists P suffix ∨ Exists P [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk32"><span class="nb">rewrite</span> Exists_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ (Exists P suffix ∨ P x ∨ Exists P [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk33"><span class="nb">rewrite</span> Exists_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ (Exists P suffix ∨ P x ∨ <span class="kt">False</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk34"><span class="kn">Lemma</span> <span class="nf">existsb_last</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">l</span> : list A)
  (<span class="nv">f</span> : A -&gt; bool)
  (<span class="nv">Hsomething</span> : existsb f l = true) :
  <span class="kr">exists</span> (<span class="nv">prefix</span> : list A)
         (<span class="nv">suffix</span> : list A)
         (<span class="nv">last</span> : A),
         (f <span class="nb">last</span> = true) /\
         l = prefix ++ [<span class="nb">last</span>] ++ suffix /\
         (existsb f suffix = false).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ existsb f suffix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ existsb f suffix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk36"><span class="nb">setoid_rewrite</span> &lt;-not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ existsb f suffix ≠ true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk37"><span class="nb">setoid_rewrite</span> existsb_Exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk38"><span class="nb">apply</span> Exists_last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk39"><hr></label><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> existsb_Exists.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3c"><span class="kn">Lemma</span> <span class="nf">existsb_forall</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; bool) :
  <span class="kr">forall</span> <span class="nv">l</span>, existsb f l = false &lt;-&gt; <span class="kr">forall</span> <span class="nv">x</span>, x ∈ l -&gt; f x = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = false ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → f x = false)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = false ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → f x = false)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3e"><span class="nb">intro</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb f l = false ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → f x = false)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3f"><span class="nb">setoid_rewrite</span> &lt;- not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb f l ≠ true ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → f x ≠ true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> existsb_Exists, &lt;- Forall_Exists_neg, Forall_forall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk40"><span class="kn">Lemma</span> <span class="nf">existsb_first</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">l</span> : list A)
  (<span class="nv">f</span> : A -&gt; bool)
  (<span class="nv">Hsomething</span> : existsb f l = true) :
  <span class="kr">exists</span> (<span class="nv">prefix</span> : list A)
         (<span class="nv">suffix</span> : list A)
         (<span class="nv">first</span> : A),
         (f <span class="kp">first</span> = true) /\
         l = prefix ++ [<span class="kp">first</span>] ++ suffix /\
         (existsb f prefix = false).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ existsb f prefix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ existsb f prefix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk42"><span class="nb">setoid_rewrite</span> &lt;-not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ existsb f prefix ≠ true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk43"><span class="nb">setoid_rewrite</span> existsb_Exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ ¬ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) prefix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk44"><span class="nb">apply</span> Exists_first.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk45"><hr></label><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">typeclasses eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> existsb_Exists.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">  Returns all elements &lt;&lt;X&gt;&gt; of &lt;&lt;l&gt;&gt; such that &lt;&lt;X&gt;&gt; does not compare less</span>
<span class="c">  than any other element w.r.t to the precedes relation.</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">maximal_elements_list</span>
  {<span class="nv">A</span>} (<span class="nv">precedes</span> : relation A) `{!RelDecision precedes} (l : list A)
  : list A :=
  filter (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Forall (<span class="kr">fun</span> <span class="nv">b</span> =&gt; ~ precedes a b) l) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk48"><span class="kn">Example</span> <span class="nf">maximal_elements_list1</span> : maximal_elements_list Nat.lt [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [<span class="mi">4</span>; <span class="mi">4</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">maximal_elements_list Nat.lt [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [<span class="mi">4</span>; <span class="mi">4</span>]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk49"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">maximal_elements_list Nat.lt [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [<span class="mi">4</span>; <span class="mi">4</span>]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4a"><span class="kn">Example</span> <span class="nf">maximal_elements_list2</span> : maximal_elements_list Nat.le [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">maximal_elements_list Nat.le [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">maximal_elements_list Nat.le [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Returns all elements <code>x</code> of a set <code>S</code> such that <code>x</code> does not compare less
  than any other element in <code>S</code> w.r.t to a given precedes relation.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">maximal_elements_set</span>
  `{HfinSetMessage : FinSet A SetA}
   (precedes : relation A) `{!RelDecision precedes} (s : SetA)
   : SetA :=
    filter (<span class="kr">fun</span> <span class="nv">a</span> =&gt; set_Forall (<span class="kr">fun</span> <span class="nv">b</span> =&gt; ~ precedes a b) s) s.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4c"><span class="kn">Lemma</span> <span class="nf">filter_ext_elem_of</span> {<span class="nv">A</span>} <span class="nv">P</span> <span class="nv">Q</span>
 `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (Q x)} (l : list A) :
 (<span class="kr">forall</span> <span class="nv">a</span>, a ∈ l -&gt; (P a &lt;-&gt; Q a)) -&gt;
 filter P l = filter Q l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4e"><span class="nb">induction</span> l; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ [] → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P [] = filter Q []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk4f"><hr></label><div class="goal-conclusion">filter P (a :: l) = filter Q (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk50">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ [] → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P [] = filter Q []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> <span class="mi">2</span> filter_nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk51">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P (a :: l) = filter Q (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk52"><span class="nb">rewrite</span> <span class="mi">2</span> filter_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (P a) <span class="kr">then</span> a :: filter P l <span class="kr">else</span> filter P l) =
(<span class="kr">if</span> decide (Q a) <span class="kr">then</span> a :: filter Q l <span class="kr">else</span> filter Q l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk53"><span class="nb">setoid_rewrite</span> elem_of_cons <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 = a ∨ a0 ∈ l → P a0 ↔ Q a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (P a) <span class="kr">then</span> a :: filter P l <span class="kr">else</span> filter P l) =
(<span class="kr">if</span> decide (Q a) <span class="kr">then</span> a :: filter Q l <span class="kr">else</span> filter Q l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (decide (P a)), (decide (Q a)); [<span class="nb">rewrite</span> IHl | ..]; <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk54"><span class="kn">Lemma</span> <span class="nf">ext_elem_of_filter</span> {<span class="nv">A</span>} <span class="nv">P</span> <span class="nv">Q</span>
 `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (Q x)}
 (l : list A) :
 filter P l = filter Q l -&gt; <span class="kr">forall</span> <span class="nv">a</span>, a ∈ l -&gt; (P a &lt;-&gt; Q a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l → <span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l → <span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk56"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk57"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk58"><hr></label><div class="goal-conclusion">P a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> elem_of_list_filter; <span class="nb">rewrite</span> &lt;- H1; <span class="nb">apply</span> elem_of_list_filter.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> elem_of_list_filter; <span class="nb">rewrite</span> H1; <span class="nb">apply</span> elem_of_list_filter.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5b"><span class="kn">Lemma</span> <span class="nf">filter_complement</span> {<span class="nv">X</span>} <span class="nv">P</span> <span class="nv">Q</span>
 `{<span class="kr">forall</span> (<span class="nv">x</span> : X), Decision (P x)} `{<span class="kr">forall</span> (<span class="nv">x</span> : X), Decision (Q x)}
 (l : list X) :
 filter P l = filter Q l &lt;-&gt;
 filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ~ P x) l = filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ~ Q x) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l
↔ filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
  filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l
↔ filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
  filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5d"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l = filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk5e"><hr></label><div class="goal-conclusion">filter P l = filter Q l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l = filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk60"><span class="nb">specialize</span> (ext_elem_of_filter P Q l H1) <span class="kr">as</span> Hext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l = filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk61"><span class="nb">apply</span> filter_ext_elem_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → ¬ P a ↔ ¬ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk62"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ P a ↔ ¬ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk63"><span class="nb">specialize</span> (Hext a H2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>P a ↔ Q a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ P a ↔ ¬ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hext; itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk65"><span class="nb">apply</span> filter_ext_elem_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk66"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk67"><span class="nb">specialize</span> (ext_elem_of_filter _ _ l H1 a H2) <span class="kr">as</span> Hext; <span class="nb">cbn</span> <span class="kr">in</span> Hext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>¬ P a ↔ ¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (decide (P a)), (decide (Q a)); itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk68"><span class="kn">Lemma</span> <span class="nf">NoDup_elem_of_remove</span> <span class="nv">A</span> (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) <span class="nv">a</span> :
  NoDup (l ++ a :: l&#39;) -&gt; NoDup (l ++ l&#39;) /\ a ∉ l ++ l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ a :: l&#39;) → NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ a :: l&#39;) → NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6a"><span class="nb">intros</span> Hnda.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>NoDup (l ++ a :: l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6b"><span class="nb">apply</span> NoDup_app <span class="kr">in</span> Hnda.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>NoDup l
∧ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;)
  ∧ NoDup (a :: l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6c"><span class="nb">destruct</span> Hnda <span class="kr">as</span> [Hnd [Ha Hnda]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>NoDup (a :: l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6d"><span class="nb">apply</span> NoDup_cons <span class="kr">in</span> Hnda.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>(a ∉ l&#39;) ∧ NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6e"><span class="nb">setoid_rewrite</span> elem_of_cons <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ (x = a ∨ x ∈ l&#39;)</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>(a ∉ l&#39;) ∧ NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6f"><span class="nb">destruct</span> Hnda <span class="kr">as</span> [Ha&#39; Hnd&#39;]; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ (x = a ∨ x ∈ l&#39;)</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ (x = a ∨ x ∈ l&#39;)</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk70"><hr></label><div class="goal-conclusion">a ∉ l ++ l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk71">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ (x = a ∨ x ∈ l&#39;)</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> NoDup_app; <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk72">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ (x = a ∨ x ∈ l&#39;)</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> elem_of_app; <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk73"><span class="kn">Lemma</span> <span class="nf">list_lookup_lt</span> [A] (<span class="kr">is</span> : list A) :
  <span class="kr">forall</span> <span class="nv">i</span>, is_Some (<span class="kr">is</span> !! i) -&gt;
  <span class="kr">forall</span> <span class="nv">j</span>, j &lt; i -&gt; is_Some (<span class="kr">is</span> !! j).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>is</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">i</span> : nat,
  is_Some (<span class="kr">is</span> !! i)
  → <span class="kr">∀</span> <span class="nv">j</span> : nat, j &lt; i → is_Some (<span class="kr">is</span> !! j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk74"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>is</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">i</span> : nat,
  is_Some (<span class="kr">is</span> !! i)
  → <span class="kr">∀</span> <span class="nv">j</span> : nat, j &lt; i → is_Some (<span class="kr">is</span> !! j)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk75"><span class="nb">intros</span>; <span class="nb">apply</span> lookup_lt_is_Some.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>is</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_Some (<span class="kr">is</span> !! i)</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>j &lt; i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j &lt; length <span class="kr">is</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">etransitivity</span>; [| <span class="nb">apply</span> lookup_lt_is_Some].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk76"><span class="kn">Lemma</span> <span class="nf">list_difference_singleton_not_in</span> `{EqDecision A} :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A), a ∉ l -&gt;
    list_difference l [a] = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  a ∉ l → list_difference l [a] = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk77"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  a ∉ l → list_difference l [a] = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk78"><span class="nb">intros</span> l a; <span class="nb">induction</span> l; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∉ l → list_difference l [a] = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∉ a0 :: l → list_difference (a0 :: l) [a] = a0 :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk79"><span class="nb">rewrite</span> not_elem_of_cons; <span class="nb">intros</span> [Hna0 Hnal]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∉ l → list_difference l [a] = l</span></span></span><br><span><var>Hna0</var><span class="hyp-type"><b>: </b><span>a ≠ a0</span></span></span><br><span><var>Hnal</var><span class="hyp-type"><b>: </b><span>a ∉ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel elem_of a0 [a]
 <span class="kr">then</span> list_difference l [a]
 <span class="kr">else</span> a0 :: list_difference l [a]) = a0 :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7a">case_decide <span class="kr">as</span> Ha0; [<span class="bp">by</span> <span class="nb">apply</span> elem_of_list_singleton <span class="kr">in</span> Ha0 |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∉ l → list_difference l [a] = l</span></span></span><br><span><var>Hna0</var><span class="hyp-type"><b>: </b><span>a ≠ a0</span></span></span><br><span><var>Hnal</var><span class="hyp-type"><b>: </b><span>a ∉ l</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a0 ∉ [a]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0 :: list_difference l [a] = a0 :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7b"><span class="kn">Lemma</span> <span class="nf">list_difference_singleton_length_in</span> `{EqDecision A} :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A), a ∈ l -&gt;
    length (list_difference l [a]) &lt; length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  a ∈ l → length (list_difference l [a]) &lt; length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  a ∈ l → length (list_difference l [a]) &lt; length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7d"><span class="nb">intros</span> l a; <span class="nb">induction</span> l; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a0 :: l
→ length
    (<span class="kr">if</span> decide_rel elem_of a0 [a]
     <span class="kr">then</span> list_difference l [a]
     <span class="kr">else</span> a0 :: list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7e">case_decide <span class="kr">as</span> Ha0; <span class="nb">rewrite</span> elem_of_list_singleton <span class="kr">in</span> Ha0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a0 = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a0 :: l
→ length (list_difference l [a]) &lt; S (length l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a0 ≠ a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk7f"><hr></label><div class="goal-conclusion">a ∈ a0 :: l
→ length (a0 :: list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk80">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a0 = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a0 :: l
→ length (list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk81"><span class="nb">subst</span>; <span class="nb">intros</span> _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk82"><span class="nb">destruct</span> (decide (a ∈ l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_difference l [a]) &lt; S (length l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk83"><hr></label><div class="goal-conclusion">length (list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk84">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">etransitivity</span>; [<span class="nb">apply</span> IHl | <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk85">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> list_difference_singleton_not_in; [<span class="bp">lia</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk86">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>a ∈ l
→ length (list_difference l [a]) &lt; length l</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a0 ≠ a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a0 :: l
→ length (a0 :: list_difference l [a]) &lt; S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>; [<span class="bp">done</span> |]; <span class="nb">cbn</span>; spec IHl; [| <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk87"><span class="kn">Lemma</span> <span class="nf">longer_subseteq_has_dups</span> `{EqDecision A} :
  <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l1 ⊆ l2 -&gt; length l1 &gt; length l2 -&gt;
  <span class="kr">exists</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A), i1 &lt;&gt; i2 /\ l1 !! i1 = Some a /\ l1 !! i2 = Some a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk89"><span class="nb">induction</span> l1; [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">2</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  a :: l1 ⊆ l2
  → length (a :: l1) &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
        i1 ≠ i2
        ∧ (a :: l1) !! i1 = Some a0
          ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8a"><span class="nb">intros</span> l2 Hl12 Hlen12.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  i1 ≠ i2
  ∧ (a :: l1) !! i1 = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8b"><span class="nb">destruct</span> (decide (a ∈ l1)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  i1 ≠ i2
  ∧ (a :: l1) !! i1 = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk8c"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  i1 ≠ i2
  ∧ (a :: l1) !! i1 = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  i1 ≠ i2
  ∧ (a :: l1) !! i1 = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8e"><span class="kr">exists</span> <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  <span class="mi">0</span> ≠ i2
  ∧ (a :: l1) !! <span class="mi">0</span> = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8f"><span class="nb">apply</span> elem_of_list_lookup_1 <span class="kr">in</span> e <span class="kr">as</span> [i2 Hi2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>i2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi2</var><span class="hyp-type"><b>: </b><span>l1 !! i2 = Some a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  <span class="mi">0</span> ≠ i2
  ∧ (a :: l1) !! <span class="mi">0</span> = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">i2</span>), a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk90">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  i1 ≠ i2
  ∧ (a :: l1) !! i1 = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk91"><span class="nb">edestruct</span> (IHl1 (list_difference l2 [a]))
           <span class="kr">as</span> (i1 &amp; i2 &amp; a&#39; &amp; Hi12 &amp; Hli1 &amp; Hli2); <span class="nb">cycle</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br><span><var>i1, i2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hi12</var><span class="hyp-type"><b>: </b><span>i1 ≠ i2</span></span></span><br><span><var>Hli1</var><span class="hyp-type"><b>: </b><span>l1 !! i1 = Some a&#39;</span></span></span><br><span><var>Hli2</var><span class="hyp-type"><b>: </b><span>l1 !! i2 = Some a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  i1 ≠ i2
  ∧ (a :: l1) !! i1 = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk92"><hr></label><div class="goal-conclusion">l1 ⊆ list_difference l2 [a]</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk93"><hr></label><div class="goal-conclusion">length l1 &gt; length (list_difference l2 [a])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk94">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br><span><var>i1, i2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hi12</var><span class="hyp-type"><b>: </b><span>i1 ≠ i2</span></span></span><br><span><var>Hli1</var><span class="hyp-type"><b>: </b><span>l1 !! i1 = Some a&#39;</span></span></span><br><span><var>Hli2</var><span class="hyp-type"><b>: </b><span>l1 !! i2 = Some a&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a0</span> : A),
  i1 ≠ i2
  ∧ (a :: l1) !! i1 = Some a0
    ∧ (a :: l1) !! i2 = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">i1</span>), (S i2), a&#39;; <span class="nb">cbn</span>; itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk95">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 ⊆ list_difference l2 [a]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk96"><span class="nb">intros</span> x Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ list_difference l2 [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk97"><span class="nb">rewrite</span> elem_of_list_difference, elem_of_list_singleton.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ l2 ∧ x ≠ a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">apply</span> Hl12; <span class="nb">right</span> | <span class="bp">by</span> <span class="bp">contradict</span> n; <span class="nb">subst</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk98">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>length (a :: l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 &gt; length (list_difference l2 [a])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk99"><span class="nb">cbn</span> <span class="kr">in</span> Hlen12.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>S (length l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 &gt; length (list_difference l2 [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9a"><span class="nb">assert</span> (Ha : a ∈ l2) <span class="bp">by</span> (<span class="nb">apply</span> Hl12; <span class="nb">left</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l2</span> : list A,
  l1 ⊆ l2
  → length l1 &gt; length l2
    → <span class="kr">∃</span> (<span class="nv">i1</span> <span class="nv">i2</span> : nat) (<span class="nv">a</span> : A),
        i1 ≠ i2
        ∧ l1 !! i1 = Some a ∧ l1 !! i2 = Some a</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl12</var><span class="hyp-type"><b>: </b><span>a :: l1 ⊆ l2</span></span></span><br><span><var>Hlen12</var><span class="hyp-type"><b>: </b><span>S (length l1) &gt; length l2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a ∉ l1</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a ∈ l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length l1 &gt; length (list_difference l2 [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">specialize</span> (list_difference_singleton_length_in _ _ Ha) <span class="kr">as</span> Hlen&#39;; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9b"><span class="kn">Lemma</span> <span class="nf">ForAllSuffix2_lookup</span> [A : <span class="kt">Type</span>] (R : A -&gt; A -&gt; <span class="kt">Prop</span>) l
  : ForAllSuffix2 R l &lt;-&gt; <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, l !! n = Some a -&gt; l !! (S n) = Some b -&gt; R a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R l
↔ (<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
     l !! n = Some a → l !! S n = Some b → R a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R l
↔ (<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
     l !! n = Some a → l !! S n = Some b → R a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9d"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R l
→ <span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
    l !! n = Some a → l !! S n = Some b → R a b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk9e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk9e"><hr></label><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
   l !! n = Some a → l !! S n = Some b → R a b)
→ ForAllSuffix2 R l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R l
→ <span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
    l !! n = Some a → l !! S n = Some b → R a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka0"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">2</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">λ</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) l</span></span></span><br><span><var>IHForAllSuffix</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a
  → l !! S n = Some b → R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b</span> : A),
  (a :: l) !! n = Some a0 → l !! n = Some b → R a0 b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka1"><span class="nb">destruct</span> n <span class="kr">as</span> [| n&#39;]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">λ</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) l</span></span></span><br><span><var>IHForAllSuffix</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a
  → l !! S n = Some b → R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a0</span> <span class="nv">b</span> : A,
  Some a = Some a0 → l !! <span class="mi">0</span> = Some b → R a0 b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">λ</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) l</span></span></span><br><span><var>IHForAllSuffix</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a
  → l !! S n = Some b → R a b</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chka2"><hr></label><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> <span class="nv">b</span> : A,
  l !! n&#39; = Some a → l !! S n&#39; = Some b → R a b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">λ</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) l</span></span></span><br><span><var>IHForAllSuffix</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a
  → l !! S n = Some b → R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a0</span> <span class="nv">b</span> : A,
  Some a = Some a0 → l !! <span class="mi">0</span> = Some b → R a0 b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> l; <span class="kp">do</span> <span class="mi">2</span> <span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">λ</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) l</span></span></span><br><span><var>IHForAllSuffix</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a
  → l !! S n = Some b → R a b</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> <span class="nv">b</span> : A,
  l !! n&#39; = Some a → l !! S n&#39; = Some b → R a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> IHForAllSuffix.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
   l !! n = Some a → l !! S n = Some b → R a b)
→ ForAllSuffix2 R l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka6"><span class="nb">induction</span> l <span class="kr">as</span> [| a [| b l&#39;]]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
   [] !! n = Some a → None = Some b → R a b)
→ ForAllSuffix2 R []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chka7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A), [] !! n = Some a → [] !! S n = Some b → R a b)
→ ForAllSuffix2 R []</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chka7"><hr></label><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b</span> : A),
   [a] !! n = Some a0 → [] !! n = Some b → R a0 b)
→ ForAllSuffix2 R [a]</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b0</span> : A),
(b :: l&#39;) !! n = Some a → (b :: l&#39;) !! S n = Some b0 → R a b0)
→ ForAllSuffix2 R (b :: l&#39;)</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chka8"><hr></label><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b0</span> : A),
   (a :: b :: l&#39;) !! n = Some a0
   → (b :: l&#39;) !! n = Some b0 → R a0 b0)
→ ForAllSuffix2 R (a :: b :: l&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka9">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
   [] !! n = Some a → None = Some b → R a b)
→ ForAllSuffix2 R []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkaa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A), [] !! n = Some a → [] !! S n = Some b → R a b)
→ ForAllSuffix2 R []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b</span> : A),
   [a] !! n = Some a0 → [] !! n = Some b → R a0 b)
→ ForAllSuffix2 R [a]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kp">repeat</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkab">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b0</span> : A),
(b :: l&#39;) !! n = Some a → (b :: l&#39;) !! S n = Some b0 → R a b0)
→ ForAllSuffix2 R (b :: l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b0</span> : A),
   (a :: b :: l&#39;) !! n = Some a0
   → (b :: l&#39;) !! n = Some b0 → R a0 b0)
→ ForAllSuffix2 R (a :: b :: l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkac"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b0</span> : A),
(b :: l&#39;) !! n = Some a → (b :: l&#39;) !! S n = Some b0 → R a b0)
→ ForAllSuffix2 R (b :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b0</span> : A),
  (a :: b :: l&#39;) !! n = Some a0
  → (b :: l&#39;) !! n = Some b0 → R a0 b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b0</span> : A),
(b :: l&#39;) !! n = Some a → (b :: l&#39;) !! S n = Some b0 → R a b0)
→ ForAllSuffix2 R (b :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b0</span> : A),
  (a :: b :: l&#39;) !! n = Some a0
  → (b :: l&#39;) !! n = Some b0 → R a0 b0</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkad"><hr></label><div class="goal-conclusion">ForAllSuffix
  (<span class="kr">λ</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) (b :: l&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkae">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b0</span> : A),
(b :: l&#39;) !! n = Some a → (b :: l&#39;) !! S n = Some b0 → R a b0)
→ ForAllSuffix2 R (b :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b0</span> : A),
  (a :: b :: l&#39;) !! n = Some a0
  → (b :: l&#39;) !! n = Some b0 → R a0 b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> (H <span class="mi">0</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkaf">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b0</span> : A),
(b :: l&#39;) !! n = Some a → (b :: l&#39;) !! S n = Some b0 → R a b0)
→ ForAllSuffix2 R (b :: l&#39;)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> <span class="nv">b0</span> : A),
  (a :: b :: l&#39;) !! n = Some a0
  → (b :: l&#39;) !! n = Some b0 → R a0 b0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix
  (<span class="kr">λ</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) (b :: l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHl; <span class="nb">intro</span> n; <span class="nb">apply</span> (H (S n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb0"><span class="kn">Lemma</span> <span class="nf">stdpp_nat_le_sum</span> (<span class="nv">x</span> <span class="nv">y</span> : nat) : x &lt;= y &lt;-&gt; <span class="kr">exists</span> <span class="nv">z</span>, y = x + z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ≤ y ↔ (<span class="kr">∃</span> <span class="nv">z</span> : nat, y = x + z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ≤ y ↔ (<span class="kr">∃</span> <span class="nv">z</span> : nat, y = x + z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb2"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ≤ y → <span class="kr">∃</span> <span class="nv">z</span> : nat, y = x + z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkb3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkb3"><hr></label><div class="goal-conclusion">(<span class="kr">∃</span> <span class="nv">z</span> : nat, y = x + z) → x ≤ y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ≤ y → <span class="kr">∃</span> <span class="nv">z</span> : nat, y = x + z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">y</span> - x); <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∃</span> <span class="nv">z</span> : nat, y = x + z) → x ≤ y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [z -&gt;]; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb6"><span class="kn">Lemma</span> <span class="nf">ForAllSuffix2_transitive_lookup</span>
  [A : <span class="kt">Type</span>] (R : A -&gt; A -&gt; <span class="kt">Prop</span>) {HT : Transitive R} (l : list A)
  : ForAllSuffix2 R l &lt;-&gt; <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, m &lt; n -&gt; l !! m = Some a -&gt; l !! n = Some b -&gt; R a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R l
↔ (<span class="kr">∀</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
     m &lt; n → l !! m = Some a → l !! n = Some b → R a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R l
↔ (<span class="kr">∀</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
     m &lt; n → l !! m = Some a → l !! n = Some b → R a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb8"><span class="nb">rewrite</span> ForAllSuffix2_lookup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
   l !! n = Some a → l !! S n = Some b → R a b)
↔ (<span class="kr">∀</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
     m &lt; n → l !! m = Some a → l !! n = Some b → R a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb9"><span class="nb">split</span>; <span class="nb">intro</span> Hall; [| <span class="bp">by</span> <span class="nb">intros</span> n a b; <span class="nb">apply</span> Hall; <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a → l !! S n = Some b → R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  m &lt; n → l !! m = Some a → l !! n = Some b → R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkba"><span class="nb">intros</span> m n a b Hlt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a → l !! S n = Some b → R a b</span></span></span><br><span><var>m, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>m &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l !! m = Some a → l !! n = Some b → R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbb"><span class="nb">apply</span> stdpp_nat_le_sum <span class="kr">in</span> Hlt <span class="kr">as</span> [k -&gt;]; <span class="nb">rewrite</span> Nat.add_comm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a → l !! S n = Some b → R a b</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l !! m = Some a → l !! (k + S m) = Some b → R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbc"><span class="nb">revert</span> a b; <span class="nb">induction</span> k; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">apply</span> Hall |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a → l !! S n = Some b → R a b</span></span></span><br><span><var>m, k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> <span class="nv">b</span> : A,
  l !! m = Some a
  → l !! (k + S m) = Some b → R a b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> <span class="nv">b</span> : A,
  l !! m = Some a → l !! S (k + S m) = Some b → R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbd"><span class="nb">intros</span> a b Ha Hb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a → l !! S n = Some b → R a b</span></span></span><br><span><var>m, k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> <span class="nv">b</span> : A,
  l !! m = Some a
  → l !! (k + S m) = Some b → R a b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>l !! m = Some a</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>l !! S (k + S m) = Some b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbe"><span class="nb">assert</span> (Hlt : k + S m &lt; length l) <span class="bp">by</span> (<span class="nb">apply</span> lookup_lt_Some <span class="kr">in</span> Hb; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a → l !! S n = Some b → R a b</span></span></span><br><span><var>m, k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> <span class="nv">b</span> : A,
  l !! m = Some a
  → l !! (k + S m) = Some b → R a b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>l !! m = Some a</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>l !! S (k + S m) = Some b</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>k + S m &lt; length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbf"><span class="nb">apply</span> lookup_lt_is_Some <span class="kr">in</span> Hlt <span class="kr">as</span> [c Hc].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A → A → <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> <span class="nv">b</span> : A),
  l !! n = Some a → l !! S n = Some b → R a b</span></span></span><br><span><var>m, k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> <span class="nv">b</span> : A,
  l !! m = Some a
  → l !! (k + S m) = Some b → R a b</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>l !! m = Some a</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>l !! S (k + S m) = Some b</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hc</var><span class="hyp-type"><b>: </b><span>l !! (k + S m) = Some c</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">transitivity</span> c; [<span class="nb">apply</span> IHk | <span class="nb">eapply</span> Hall].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  If the <code>n</code>-th element of <code>l</code> is <code>x</code>, then we can decompose long enough
  suffixes of <code>l</code> into <code>x</code> and a suffix shorter by 1.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc0"><span class="kn">Lemma</span> <span class="nf">lastn_length_cons</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A),
    l !! n = Some x -&gt; lastn (length l - n) l = x :: lastn (length l - S n) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A),
  l !! n = Some x
  → lastn (length l - n) l =
    x :: lastn (length l - S n) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A),
  l !! n = Some x
  → lastn (length l - n) l =
    x :: lastn (length l - S n) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc2"><span class="nb">intros</span> A n l x H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l !! n = Some x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn (length l - n) l = x :: lastn (length l - S n) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc3"><span class="nb">unfold</span> lastn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l !! n = Some x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (take (length l - n) (rev l)) =
x :: rev (take (length l - S n) (rev l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc4"><span class="nb">rewrite</span> &lt;- rev_length, &lt;- !skipn_rev, rev_involutive.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l !! n = Some x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n l = x :: drop (S n) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> drop_S.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc5"><span class="kn">Lemma</span> <span class="nf">list_subseteq_filter</span> {<span class="nv">A</span>} <span class="nv">P</span> <span class="nv">Q</span>
  `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (Q x)} :
  (<span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a) -&gt;
  <span class="kr">forall</span> <span class="nv">s</span> : list A, filter P s ⊆ filter Q s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a)
→ <span class="kr">∀</span> <span class="nv">s</span> : list A, filter P s ⊆ filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a)
→ <span class="kr">∀</span> <span class="nv">s</span> : list A, filter P s ⊆ filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc7"><span class="nb">induction</span> s; <span class="nb">cbn</span>; <span class="nb">intros</span> x Hin; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x ∈ (<span class="kr">if</span> decide (P a) <span class="kr">then</span> a :: filter P s <span class="kr">else</span> filter P s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x
∈ (<span class="kr">if</span> decide (Q a)
   <span class="kr">then</span> a :: filter Q s
   <span class="kr">else</span> filter Q s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (decide (P a)), (decide (Q a)); <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> <span class="nl">?elem_of_cons</span> <span class="kr">in</span> *; itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc8"><span class="kn">Lemma</span> <span class="nf">filter_length_fn</span> {<span class="nv">A</span>} <span class="nv">P</span> <span class="nv">Q</span>
  `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (Q x)}
  s (Hfg : Forall (<span class="kr">fun</span> <span class="nv">a</span> =&gt; P a -&gt; Q a) s) :
  length (filter P s) &lt;= length (filter Q s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hfg</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter P s) ≤ length (filter Q s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hfg</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter P s) ≤ length (filter Q s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkca"><span class="nb">induction</span> s; <span class="nb">simpl</span>; [<span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hfg</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) (a :: s)</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) s → length (filter P s) ≤ length (filter Q s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter P (a :: s))
≤ length (filter Q (a :: s))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkcb"><span class="nb">inversion</span> Hfg; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hfg</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) (a :: s)</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) s → length (filter P s) ≤ length (filter Q s)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a → Q a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter P (a :: s))
≤ length (filter Q (a :: s))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkcc"><span class="nb">specialize</span> (IHs H4).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hfg</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) (a :: s)</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>length (filter P s) ≤ length (filter Q s)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a → Q a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter P (a :: s))
≤ length (filter Q (a :: s))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkcd"><span class="nb">rewrite</span> <span class="mi">2</span> filter_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hfg</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) (a :: s)</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>length (filter P s) ≤ length (filter Q s)</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a → Q a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, P a → Q a) s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span> a :: filter P s
   <span class="kr">else</span> filter P s)
≤ length
    (<span class="kr">if</span> decide (Q a)
     <span class="kr">then</span> a :: filter Q s
     <span class="kr">else</span> filter Q s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (decide (P a)), (decide (Q a)); <span class="nb">cbn</span>; itauto <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkce"><span class="kn">Lemma</span> <span class="nf">nth_error_filter</span>
  {<span class="nv">A</span>} <span class="nv">P</span> `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)}
  (l : list A)
  (n : nat)
  (a : A)
  (Hnth : nth_error (filter P l) n = Some a)
  : <span class="kr">exists</span> (<span class="nv">nth</span> : nat),
    nth_error_filter_index P l n = Some nth
    /\ nth_error l nth = Some a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  nth_error_filter_index P l n = Some nth
  ∧ nth_error l nth = Some a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkcf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  nth_error_filter_index P l n = Some nth
  ∧ nth_error l nth = Some a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd0"><span class="nb">generalize dependent</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A,
  nth_error (filter P l) n = Some a
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P l n = Some nth
      ∧ nth_error l nth = Some a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd1"><span class="nb">generalize dependent</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
  nth_error (filter P l) n = Some a
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P l n = Some nth
      ∧ nth_error l nth = Some a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd2"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
  nth_error (filter P []) n = Some a
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P [] n = Some nth
      ∧ nth_error [] nth = Some a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkd3"><hr></label><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A),
  nth_error (filter P (a :: l)) n = Some a0
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P (a :: l) n = Some nth
      ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
  nth_error (filter P []) n = Some a
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P [] n = Some nth
      ∧ nth_error [] nth = Some a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> []; <span class="nb">cbn</span>; <span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A),
  nth_error (filter P (a :: l)) n = Some a0
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P (a :: l) n = Some nth
      ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P (a :: l)) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  nth_error_filter_index P (a :: l) n = Some nth
  ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd7"><span class="nb">rewrite</span> filter_cons <span class="kr">in</span> Hnth.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error
  (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span> a :: filter P l
   <span class="kr">else</span> filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  nth_error_filter_index P (a :: l) n = Some nth
  ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd8"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error
  (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span> a :: filter P l
   <span class="kr">else</span> filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span>
    <span class="kr">match</span> n <span class="kr">with</span>
    | <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
    | S n&#39; =&gt;
        option_map S (nth_error_filter_index P l n&#39;)
    <span class="kr">end</span>
   <span class="kr">else</span> option_map S (nth_error_filter_index P l n)) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd9"><span class="nb">destruct</span> (decide (P a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (a :: filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
  | S n&#39; =&gt;
      option_map S (nth_error_filter_index P l n&#39;)
  <span class="kr">end</span> = Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkda" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
  nth_error (filter P l) n = Some a
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P l n = Some nth
      ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkda"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkdb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (a :: filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
  | S n&#39; =&gt;
      option_map S (nth_error_filter_index P l n&#39;)
  <span class="kr">end</span> = Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkdc"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (a :: filter P l) <span class="mi">0</span> = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  Some <span class="mi">0</span> = Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkdd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
  nth_error (filter P l) n = Some a
  → <span class="kr">∃</span> <span class="nv">nth</span> : nat,
      nth_error_filter_index P l n = Some nth
      ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (a :: filter P l) (S n) = Some a0</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkdd"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkde">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (a :: filter P l) <span class="mi">0</span> = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  Some <span class="mi">0</span> = Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hnth; <span class="nb">subst</span>; <span class="kr">exists</span> <span class="mi">0</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkdf">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (a :: filter P l) (S n) = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke0"><span class="nb">simpl</span> <span class="kr">in</span> Hnth.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke1"><span class="nb">specialize</span> (IHl n a0 Hnth).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke2"><span class="nb">destruct</span> IHl <span class="kr">as</span> [nth [Hnth&#39; Ha0]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hnth'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n = Some nth</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>nth_error l nth = Some a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke3"><span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">nth</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hnth'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n = Some nth</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>nth_error l nth = Some a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_map S (nth_error_filter_index P l n) =
Some (S nth) ∧ nth_error (a :: l) (S nth) = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hnth&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
nth_error (filter P l) n = Some a
→ <span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke5"><span class="nb">specialize</span> (IHl n a0 Hnth).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">nth</span> : nat,
nth_error_filter_index P l n = Some nth ∧ nth_error l nth = Some a0</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke6"><span class="nb">destruct</span> IHl <span class="kr">as</span> [nth [Hnth&#39; Ha0]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hnth'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n = Some nth</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>nth_error l nth = Some a0</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">nth</span> : nat,
  option_map S (nth_error_filter_index P l n) =
  Some nth ∧ nth_error (a :: l) nth = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke7"><span class="kr">exists</span> (<span class="nv">S</span> <span class="nv">nth</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hnth'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n = Some nth</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>nth_error l nth = Some a0</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error (filter P l) n = Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_map S (nth_error_filter_index P l n) =
Some (S nth) ∧ nth_error (a :: l) (S nth) = Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hnth&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke8"><span class="kn">Lemma</span> <span class="nf">filter_subseteq</span> {<span class="nv">A</span>} <span class="nv">P</span> `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} (s1 s2 : list A) :
  s1 ⊆ s2 -&gt;
  filter P s1 ⊆ filter P s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s1 ⊆ s2 → filter P s1 ⊆ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s1 ⊆ s2 → filter P s1 ⊆ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkea"><span class="nb">induction</span> s1; <span class="nb">intros</span>; <span class="nb">intro</span> x; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>[] ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkeb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P (a :: s1)</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkeb"><hr></label><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkec">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>[] ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> not_elem_of_nil <span class="kr">in</span> H1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P (a :: s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkee"><span class="nb">rewrite</span> filter_cons <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x
∈ (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span> a :: filter P s1
   <span class="kr">else</span> filter P s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkef"><span class="nb">destruct</span> (decide (P a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ a :: filter P s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s1</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkf0"><hr></label><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ a :: filter P s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf2"><span class="nb">rewrite</span> elem_of_cons <span class="kr">in</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x = a ∨ x ∈ filter P s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf3"><span class="nb">destruct</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkf4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s1</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkf4"><hr></label><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf5">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf6"><span class="nb">subst</span>; <span class="nb">apply</span> elem_of_list_filter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ∧ a ∈ s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [| <span class="nb">apply</span> H0; <span class="nb">left</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf7">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf8"><span class="nb">apply</span> IHs1; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s1 ⊆ s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> y Hel; <span class="nb">apply</span> H0; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf9">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter P s2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkfa"><span class="nb">apply</span> IHs1; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs1</var><span class="hyp-type"><b>: </b><span>s1 ⊆ s2 → filter P s1 ⊆ filter P s2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>a :: s1 ⊆ s2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s1 ⊆ s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> y Hel; <span class="nb">apply</span> H0; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkfb"><span class="kn">Lemma</span> <span class="nf">filter_subseteq_fn</span> {<span class="nv">A</span>} <span class="nv">P</span> <span class="nv">Q</span>
  `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (Q x)} :
  (<span class="kr">forall</span> <span class="nv">a</span>, P a -&gt; Q a) -&gt;
  <span class="kr">forall</span> (<span class="nv">s</span> : list A), filter P s ⊆ filter Q s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a)
→ <span class="kr">∀</span> <span class="nv">s</span> : list A, filter P s ⊆ filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkfc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a)
→ <span class="kr">∀</span> <span class="nv">s</span> : list A, filter P s ⊆ filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkfd"><span class="nb">induction</span> s; <span class="nb">cbn</span>; <span class="nb">intros</span> x H2; [<span class="bp">by</span> <span class="nb">inversion</span> H2 |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x
∈ (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span> a :: filter P s
   <span class="kr">else</span> filter P s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x
∈ (<span class="kr">if</span> decide (Q a)
   <span class="kr">then</span> a :: filter Q s
   <span class="kr">else</span> filter Q s)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkfe"><span class="nb">destruct</span> (decide (P a)), (decide (Q a)); <span class="nb">rewrite</span> <span class="nl">?elem_of_cons</span> <span class="kr">in</span> H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x = a ∨ x ∈ filter P s</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: filter Q s</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x = a ∨ x ∈ filter P s</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkff"><hr></label><div class="goal-conclusion">x ∈ filter Q s</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk100" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk100"><hr></label><div class="goal-conclusion">x ∈ a :: filter Q s</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk101" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk101"><hr></label><div class="goal-conclusion">x ∈ filter Q s</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk102">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x = a ∨ x ∈ filter P s</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> H2 <span class="kr">as</span> [-&gt; |]; [<span class="nb">left</span> | <span class="nb">right</span>; <span class="nb">apply</span> IHs].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk103">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x = a ∨ x ∈ filter P s</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk104">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">apply</span> IHs.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk105">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, P a → Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHs</var><span class="hyp-type"><b>: </b><span>filter P s ⊆ filter Q s</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>x ∈ filter P s</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ filter Q s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk106"><span class="kn">Lemma</span> <span class="nf">Forall_filter_nil</span> {<span class="nv">A</span>} <span class="nv">P</span> `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} l :
  Forall (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; ~ P a) l &lt;-&gt; filter P l = [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, ¬ P a) l ↔ filter P l = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk107"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">λ</span> <span class="nv">a</span> : A, ¬ P a) l ↔ filter P l = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk108"><span class="nb">rewrite</span> Forall_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ P x) ↔ filter P l = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk109"><span class="nb">split</span>; <span class="nb">intro</span> Hnone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnone</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnone</var><span class="hyp-type"><b>: </b><span>filter P l = []</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk10a"><hr></label><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ P x</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk10b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnone</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk10c"><span class="nb">induction</span> l; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnone</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ a :: l → ¬ P x</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ P x) → filter P l = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (P a) <span class="kr">then</span> a :: filter P l <span class="kr">else</span> filter P l) =
[]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk10d"><span class="nb">setoid_rewrite</span> elem_of_cons <span class="kr">in</span> Hnone.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnone</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x = a ∨ x ∈ l → ¬ P x</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ P x) → filter P l = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (P a) <span class="kr">then</span> a :: filter P l <span class="kr">else</span> filter P l) =
[]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> decide_False; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk10e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnone</var><span class="hyp-type"><b>: </b><span>filter P l = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → ¬ P x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk10f"><span class="nb">intros</span> x Hel Px.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnone</var><span class="hyp-type"><b>: </b><span>filter P l = []</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hel</var><span class="hyp-type"><b>: </b><span>x ∈ l</span></span></span><br><span><var>Px</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> filter_nil_not_elem_of <span class="kr">in</span> Px.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk110"><span class="kn">Lemma</span> <span class="nf">occurrences_ordering</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">a</span> <span class="nv">b</span> : A)
  (<span class="nv">la1</span> <span class="nv">la2</span> <span class="nv">lb1</span> <span class="nv">lb2</span> : list A)
  (<span class="nv">Heq</span> : la1 ++ a :: la2 = lb1 ++ b :: lb2)
  (<span class="nv">Ha</span> : a ∉ b :: lb2)
  : <span class="kr">exists</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la1, la2, lb1, lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>la1 ++ a :: la2 = lb1 ++ b :: lb2</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a ∉ b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk111"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la1, la2, lb1, lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>la1 ++ a :: la2 = lb1 ++ b :: lb2</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a ∉ b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk112"><span class="nb">generalize dependent</span> lb2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la1, la2, lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">lb2</span> : list A,
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk113"><span class="nb">generalize dependent</span> la2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la1, lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">la2</span> <span class="nv">lb2</span> : list A,
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk114"><span class="nb">generalize dependent</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la1, lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">b</span> : A) (<span class="nv">la2</span> <span class="nv">lb2</span> : list A),
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk115"><span class="nb">generalize dependent</span> lb1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">lb1</span> : list A) (<span class="nv">b</span> : A) (<span class="nv">la2</span> <span class="nv">lb2</span> : list A),
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk116"><span class="nb">generalize dependent</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">a</span> : A) (<span class="nv">lb1</span> : list A) (<span class="nv">b</span> : A) (<span class="nv">la2</span> <span class="nv">lb2</span> : list A),
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk117"><span class="nb">induction</span> la1; <span class="nb">intros</span>; <span class="nb">destruct</span> lb1 <span class="kr">as</span> [| b0 lb1]; <span class="nb">simpl</span> <span class="kr">in</span> *
  ; <span class="nb">inversion</span> Heq; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>b ∉ b :: lb2</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b :: lb2 = b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, [] = b :: lab</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>b0 ∉ b :: lb2</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b0 :: lb1 ++ b :: lb2 = b0 :: lb1 ++ b :: lb2</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk118"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, b0 :: lb1 = b0 :: lab</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk119" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHla1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">a</span> : A) (<span class="nv">lb1</span> : list A) 
  (<span class="nv">b</span> : A) (<span class="nv">la2</span> <span class="nv">lb2</span> : list A),
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</span></span></span><br><span><var>a0, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 ∉ b :: la1 ++ a0 :: la2</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b :: la1 ++ a0 :: la2 = b :: la1 ++ a0 :: la2</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk119"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, [] = b :: la1 ++ a0 :: lab</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHla1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">a</span> : A) (<span class="nv">lb1</span> : list A) 
  (<span class="nv">b</span> : A) (<span class="nv">la2</span> <span class="nv">lb2</span> : list A),
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</span></span></span><br><span><var>a0, b0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la2, lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b0 :: la1 ++ a0 :: la2 = b0 :: lb1 ++ b :: lb2</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 ∉ b :: lb2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>la1 ++ a0 :: la2 = lb1 ++ b :: lb2</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk11a"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, b0 :: lb1 = b0 :: la1 ++ a0 :: lab</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>b ∉ b :: lb2</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b :: lb2 = b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, [] = b :: lab</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">contradict</span> Ha; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>b0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>b0 ∉ b :: lb2</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b0 :: lb1 ++ b :: lb2 = b0 :: lb1 ++ b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, b0 :: lb1 = b0 :: lab</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">lb1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk11d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHla1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">a</span> : A) (<span class="nv">lb1</span> : list A) 
  (<span class="nv">b</span> : A) (<span class="nv">la2</span> <span class="nv">lb2</span> : list A),
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</span></span></span><br><span><var>a0, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 ∉ b :: la1 ++ a0 :: la2</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b :: la1 ++ a0 :: la2 = b :: la1 ++ a0 :: la2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, [] = b :: la1 ++ a0 :: lab</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">contradict</span> Ha; <span class="nb">rewrite</span> elem_of_cons, elem_of_app, elem_of_cons; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHla1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> (<span class="nv">a</span> : A) (<span class="nv">lb1</span> : list A) 
  (<span class="nv">b</span> : A) (<span class="nv">la2</span> <span class="nv">lb2</span> : list A),
  la1 ++ a :: la2 = lb1 ++ b :: lb2
  → a ∉ b :: lb2
    → <span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a :: lab</span></span></span><br><span><var>a0, b0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la2, lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b0 :: la1 ++ a0 :: la2 = b0 :: lb1 ++ b :: lb2</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 ∉ b :: lb2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>la1 ++ a0 :: la2 = lb1 ++ b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, b0 :: lb1 = b0 :: la1 ++ a0 :: lab</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk11f"><span class="nb">specialize</span> (IHla1 a0 lb1 b la2 lb2 H1 Ha).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHla1</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">lab</span> : list A, lb1 = la1 ++ a0 :: lab</span></span></span><br><span><var>b0, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la2, lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b0 :: la1 ++ a0 :: la2 = b0 :: lb1 ++ b :: lb2</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 ∉ b :: lb2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>la1 ++ a0 :: la2 = lb1 ++ b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, b0 :: lb1 = b0 :: la1 ++ a0 :: lab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk120"><span class="nb">destruct</span> IHla1 <span class="kr">as</span> [la0b Hla0b].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>la1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>lb1, la0b</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hla0b</var><span class="hyp-type"><b>: </b><span>lb1 = la1 ++ a0 :: la0b</span></span></span><br><span><var>b0, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>la2, lb2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>b0 :: la1 ++ a0 :: la2 = b0 :: lb1 ++ b :: lb2</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a0 ∉ b :: lb2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>la1 ++ a0 :: la2 = lb1 ++ b :: lb2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">lab</span> : list A, b0 :: lb1 = b0 :: la1 ++ a0 :: lab</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">la0b</span>; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk121"><span class="kn">Lemma</span> <span class="nf">list_max_elem_of_exists</span>
   (<span class="nv">l</span> : list nat)
   (<span class="nv">nz</span> : list_max l &gt; <span class="mi">0</span>) :
   list_max l ∈ l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>nz</var><span class="hyp-type"><b>: </b><span>list_max l &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max l ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk122"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>nz</var><span class="hyp-type"><b>: </b><span>list_max l &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max l ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk123"><span class="nb">induction</span> l; <span class="nb">simpl</span> <span class="kr">in</span> *; [<span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>nz</var><span class="hyp-type"><b>: </b><span>a `max` list_max l &gt; <span class="mi">0</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_max l &gt; <span class="mi">0</span> → list_max l ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a `max` list_max l ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk124"><span class="nb">rewrite</span> elem_of_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>nz</var><span class="hyp-type"><b>: </b><span>a `max` list_max l &gt; <span class="mi">0</span></span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>list_max l &gt; <span class="mi">0</span> → list_max l ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a `max` list_max l = a ∨ a `max` list_max l ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (Nat.max_spec_le a (list_max l)) <span class="kr">as</span> [[H -&gt;] | [H -&gt;]]; itauto <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk125"><span class="kn">Lemma</span> <span class="nf">omap_subseteq</span>
  {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  (<span class="nv">f</span> : A -&gt; option B)
  (<span class="nv">l1</span> <span class="nv">l2</span> : list A)
  (<span class="nv">Hincl</span> : l1 ⊆ l2)
  : omap f l1 ⊆ omap f l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → option B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span>l1 ⊆ l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">omap f l1 ⊆ omap f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk126"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → option B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hincl</var><span class="hyp-type"><b>: </b><span>l1 ⊆ l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">omap f l1 ⊆ omap f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> b; <span class="nb">rewrite</span> !elem_of_list_omap; <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk127"><span class="kn">Lemma</span> <span class="nf">elem_of_cat_option</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">l</span> : list (option A))
  (<span class="nv">a</span> : A)
  : a ∈ cat_option l &lt;-&gt; <span class="kr">exists</span> <span class="nv">b</span> : option A, b ∈ l /\ b = Some a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (option A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ cat_option l
↔ (<span class="kr">∃</span> <span class="nv">b</span> : option A, b ∈ l ∧ b = Some a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk128"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (option A)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ cat_option l
↔ (<span class="kr">∃</span> <span class="nv">b</span> : option A, b ∈ l ∧ b = Some a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> elem_of_list_omap.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk129"><span class="kn">Lemma</span> <span class="nf">list_max_elem_of_exists2</span>
   (<span class="nv">l</span> : list nat)
   (<span class="nv">Hne</span> : l &lt;&gt; []) :
   list_max l ∈ l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max l ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk12a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max l ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk12b"><span class="nb">destruct</span> (list_max l) <span class="nb">eqn</span>: eq_max.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max l = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk12c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max l = S n</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk12c"><hr></label><div class="goal-conclusion">S n ∈ l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk12d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max l = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk12e"><span class="nb">destruct</span> l; [<span class="bp">by</span> itauto <span class="bp">congruence</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk12f"><span class="nb">specialize</span> (list_max_le (n :: l) <span class="mi">0</span>) <span class="kr">as</span> Hle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) ≤ <span class="mi">0</span>
↔ Forall (<span class="kr">λ</span> <span class="nv">k</span> : nat, k ≤ <span class="mi">0</span>) (n :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk130"><span class="nb">destruct</span> Hle <span class="kr">as</span> [Hle _].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) ≤ <span class="mi">0</span>
→ Forall (<span class="kr">λ</span> <span class="nv">k</span> : nat, k ≤ <span class="mi">0</span>) (n :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk131"><span class="nb">rewrite</span> eq_max <span class="kr">in</span> Hle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> ≤ <span class="mi">0</span> → Forall (<span class="kr">λ</span> <span class="nv">k</span> : nat, k ≤ <span class="mi">0</span>) (n :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk132">spec Hle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> ≤ <span class="mi">0</span> → Forall (<span class="kr">λ</span> <span class="nv">k</span> : nat, k ≤ <span class="mi">0</span>) (n :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ≤ <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk133" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">k</span> : nat, k ≤ <span class="mi">0</span>) (n :: l)</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk133"><hr></label><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk134"><span class="nb">apply</span> Nat.le_refl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">k</span> : nat, k ≤ <span class="mi">0</span>) (n :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk135"><span class="nb">rewrite</span> Forall_forall <span class="kr">in</span> Hle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : nat, x ∈ n :: l → x ≤ <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk136"><span class="nb">specialize</span> (Hle n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n ∈ n :: l → n ≤ <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk137">spec Hle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n ∈ n :: l → n ≤ <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n ∈ n :: l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk138" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n ≤ <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk138"><hr></label><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk139"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n ≤ <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13a"><span class="nb">assert</span> (Hn0 : n = <span class="mi">0</span>) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>n :: l ≠ []</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max (n :: l) = <span class="mi">0</span></span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n ≤ <span class="mi">0</span></span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span>n = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> ∈ n :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hn0; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max l = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13c"><span class="nb">specialize</span> (list_max_elem_of_exists l) <span class="kr">as</span> Hmax.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>eq_max</var><span class="hyp-type"><b>: </b><span>list_max l = S n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span>list_max l &gt; <span class="mi">0</span> → list_max l ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- eq_max; itauto <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13d"><span class="kn">Lemma</span> <span class="nf">mode_not_empty</span>
  `{EqDecision A}
  (l : list A)
  (Hne : l &lt;&gt; []) :
  mode l &lt;&gt; [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode l ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l ≠ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode l ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13f"><span class="nb">destruct</span> l; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>a :: l ≠ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode (a :: l) ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk140"><span class="nb">remember</span> (a :: l) <span class="kr">as</span> l&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk141"><span class="nb">remember</span> (List.map (count_occ decide_eq l&#39;) l&#39;) <span class="kr">as</span> occurrences.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk142"><span class="nb">assert</span> (Hmaxp : list_max occurrences &gt; <span class="mi">0</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max occurrences &gt; <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk143" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk143"><hr></label><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk144">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max occurrences &gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk145"><span class="nb">rewrite</span> Heqoccurrences, Heql&#39;; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (a = a)
 <span class="kr">then</span> S (count_occ decide_eq l a)
 <span class="kr">else</span> count_occ decide_eq l a)
`max` foldr Init.Nat.max <span class="mi">0</span>
        (map
           (<span class="kr">λ</span> <span class="nv">x</span> : A,
              <span class="kr">if</span> decide (a = x)
              <span class="kr">then</span> S (count_occ decide_eq l x)
              <span class="kr">else</span> count_occ decide_eq l x) l) &gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> decide_True; [<span class="bp">lia</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk146">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk147"><span class="nb">assert</span> (<span class="kr">exists</span> <span class="nv">a</span>, (count_occ decide_eq l&#39; a) = list_max occurrences).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk148" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk148"><hr></label><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk149">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk14a"><span class="nb">assert</span> (list_max occurrences ∈ occurrences).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max occurrences ∈ occurrences</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk14b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>list_max occurrences ∈ occurrences</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk14b"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk14c">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_max occurrences ∈ occurrences</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk14d"><span class="nb">apply</span> list_max_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">occurrences ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> occurrences; [<span class="nb">cbn</span> <span class="kr">in</span> Hmaxp; <span class="bp">lia</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk14e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>list_max occurrences ∈ occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk14f"><span class="nb">rewrite</span> Heqoccurrences, elem_of_list_fmap <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">y</span> : A,
  list_max (map (count_occ decide_eq l&#39;) l&#39;) =
  count_occ decide_eq l&#39; y ∧ 
  y ∈ l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk150"><span class="nb">destruct</span> H <span class="kr">as</span> (x &amp; Heq &amp; Hin).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>list_max (map (count_occ decide_eq l&#39;) l&#39;) =
count_occ decide_eq l&#39; x</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x ∈ l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Heqoccurrences; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk151">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk152"><span class="nb">assert</span> (<span class="kr">exists</span> <span class="nv">a</span>, a ∈ mode l&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A, a ∈ mode l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk153" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A, a ∈ mode l&#39;</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk153"><hr></label><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk154">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A, a ∈ mode l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk155"><span class="nb">destruct</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_occ decide_eq l&#39; x = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> <span class="nv">a</span> : A, a ∈ mode l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk156"><span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_occ decide_eq l&#39; x = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ mode l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk157"><span class="nb">unfold</span> mode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_occ decide_eq l&#39; x = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x
∈ filter
    (<span class="kr">λ</span> <span class="nv">a</span> : A,
       count_occ decide_eq l&#39; a =
       list_max (map (count_occ decide_eq l&#39;) l&#39;)) l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk158"><span class="nb">apply</span> elem_of_list_filter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_occ decide_eq l&#39; x = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">count_occ decide_eq l&#39; x =
list_max (map (count_occ decide_eq l&#39;) l&#39;) ∧ x ∈ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk159"><span class="nb">specialize</span> (count_occ_In decide_eq l&#39; x); <span class="nb">rewrite</span> &lt;- elem_of_list_In.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>count_occ decide_eq l&#39; x = list_max occurrences</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ l&#39; ↔ count_occ decide_eq l&#39; x &gt; <span class="mi">0</span>
→ count_occ decide_eq l&#39; x =
  list_max (map (count_occ decide_eq l&#39;) l&#39;) ∧ x ∈ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A, a ∈ mode l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mode l&#39; ≠ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15b"><span class="nb">intros</span> contra; <span class="nb">rewrite</span> contra <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A, a ∈ []</span></span></span><br><span><var>contra</var><span class="hyp-type"><b>: </b><span>mode l&#39; = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15c"><span class="nb">destruct</span> H0 <span class="kr">as</span> [? H0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heql'</var><span class="hyp-type"><b>: </b><span>l&#39; = a :: l</span></span></span><br><span><var>Hne</var><span class="hyp-type"><b>: </b><span>l&#39; ≠ []</span></span></span><br><span><var>occurrences</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Heqoccurrences</var><span class="hyp-type"><b>: </b><span>occurrences =
map (count_occ decide_eq l&#39;) l&#39;</span></span></span><br><span><var>Hmaxp</var><span class="hyp-type"><b>: </b><span>list_max occurrences &gt; <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> <span class="nv">a</span> : A,
  count_occ decide_eq l&#39; a = list_max occurrences</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>x ∈ []</span></span></span><br><span><var>contra</var><span class="hyp-type"><b>: </b><span>mode l&#39; = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> elem_of_nil <span class="kr">in</span> H0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  When a list contains two elements, either they are equal or we can split
  the list into three parts separated by the elements (and this can be done
  in two ways, depending on the order of the elements).

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15d"><span class="kn">Lemma</span> <span class="nf">elem_of_list_split_2</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">x</span> <span class="nv">y</span> : A),
    x ∈ l -&gt; y ∈ l -&gt;
      x = y \/ <span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A,
        l = l1 ++ x :: l2 ++ y :: l3 \/ l = l1 ++ y :: l2 ++ x :: l3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">x</span> <span class="nv">y</span> : A),
  x ∈ l
  → y ∈ l
    → x = y
      ∨ (<span class="kr">∃</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A,
           l = l1 ++ x :: l2 ++ y :: l3
           ∨ l = l1 ++ y :: l2 ++ x :: l3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">x</span> <span class="nv">y</span> : A),
  x ∈ l
  → y ∈ l
    → x = y
      ∨ (<span class="kr">∃</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A,
           l = l1 ++ x :: l2 ++ y :: l3
           ∨ l = l1 ++ y :: l2 ++ x :: l3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15f"><span class="nb">intros</span> A x y l Hx Hy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>y ∈ x</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>l ∈ x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A,
     x = l1 ++ y :: l2 ++ l :: l3
     ∨ x = l1 ++ l :: l2 ++ y :: l3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk160"><span class="nb">apply</span> elem_of_list_split <span class="kr">in</span> Hx <span class="kr">as</span> (l1 &amp; l2 &amp; -&gt;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>l ∈ l1 ++ y :: l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l3</span> <span class="nv">l4</span> <span class="nv">l5</span> : list A,
     l1 ++ y :: l2 = l3 ++ y :: l4 ++ l :: l5
     ∨ l1 ++ y :: l2 = l3 ++ l :: l4 ++ y :: l5)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk161"><span class="nb">rewrite</span> elem_of_app, elem_of_cons <span class="kr">in</span> Hy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>l ∈ l1 ∨ l = y ∨ l ∈ l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l3</span> <span class="nv">l4</span> <span class="nv">l5</span> : list A,
     l1 ++ y :: l2 = l3 ++ y :: l4 ++ l :: l5
     ∨ l1 ++ y :: l2 = l3 ++ l :: l4 ++ y :: l5)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk162"><span class="nb">destruct</span> Hy <span class="kr">as</span> [Hy | [-&gt; | Hy]]; [| <span class="bp">by</span> <span class="nb">left</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>l ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l3</span> <span class="nv">l4</span> <span class="nv">l5</span> : list A,
     l1 ++ y :: l2 = l3 ++ y :: l4 ++ l :: l5
     ∨ l1 ++ y :: l2 = l3 ++ l :: l4 ++ y :: l5)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk163" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>l ∈ l2</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk163"><hr></label><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l3</span> <span class="nv">l4</span> <span class="nv">l5</span> : list A,
     l1 ++ y :: l2 = l3 ++ y :: l4 ++ l :: l5
     ∨ l1 ++ y :: l2 = l3 ++ l :: l4 ++ y :: l5)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk164">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>l ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l3</span> <span class="nv">l4</span> <span class="nv">l5</span> : list A,
     l1 ++ y :: l2 = l3 ++ y :: l4 ++ l :: l5
     ∨ l1 ++ y :: l2 = l3 ++ l :: l4 ++ y :: l5)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk165"><span class="nb">apply</span> elem_of_list_split <span class="kr">in</span> Hy <span class="kr">as</span> (l11 &amp; l12 &amp; -&gt;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2, l11, l12</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l1</span> <span class="nv">l3</span> <span class="nv">l4</span> : list A,
     (l11 ++ l :: l12) ++ y :: l2 =
     l1 ++ y :: l3 ++ l :: l4
     ∨ (l11 ++ l :: l12) ++ y :: l2 =
       l1 ++ l :: l3 ++ y :: l4)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk166"><span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">l11</span>, l12, l2; <span class="nb">right</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2, l11, l12</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(l11 ++ l :: l12) ++ y :: l2 =
l11 ++ l :: l12 ++ y :: l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- app_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk167">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>l ∈ l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l3</span> <span class="nv">l4</span> <span class="nv">l5</span> : list A,
     l1 ++ y :: l2 = l3 ++ y :: l4 ++ l :: l5
     ∨ l1 ++ y :: l2 = l3 ++ l :: l4 ++ y :: l5)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk168"><span class="nb">apply</span> elem_of_list_split <span class="kr">in</span> Hy <span class="kr">as</span> (l21 &amp; l22 &amp; -&gt;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>y, l</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l21, l22</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">y = l
∨ (<span class="kr">∃</span> <span class="nv">l2</span> <span class="nv">l3</span> <span class="nv">l4</span> : list A,
     l1 ++ y :: l21 ++ l :: l22 =
     l2 ++ y :: l3 ++ l :: l4
     ∨ l1 ++ y :: l21 ++ l :: l22 =
       l2 ++ l :: l3 ++ y :: l4)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">l1</span>, l21, l22; <span class="nb">left</span>; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk169"><span class="kn">Lemma</span> <span class="nf">mjoin_app</span> {<span class="nv">A</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list (list A)) :
  mjoin (l1 ++ l2) = mjoin l1 ++ mjoin l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list (list A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mjoin (l1 ++ l2) = mjoin l1 ++ mjoin l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list (list A)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mjoin (l1 ++ l2) = mjoin l1 ++ mjoin l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16b"><span class="nb">induction</span> l1; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list (list A)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mjoin (l1 ++ l2) = mjoin l1 ++ mjoin l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ++ mjoin (l1 ++ l2) = (a ++ mjoin l1) ++ mjoin l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16c"><span class="nb">replace</span> (mjoin (l1 ++ l2)) <span class="kr">with</span> (mjoin l1 ++ mjoin l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list (list A)</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>mjoin (l1 ++ l2) = mjoin l1 ++ mjoin l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ++ mjoin l1 ++ mjoin l2 =
(a ++ mjoin l1) ++ mjoin l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_assoc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16d"><span class="kn">Lemma</span> <span class="nf">mbind_app</span> `(f : A -&gt; list B) (l1 l2 : list A) :
  mbind f (l1 ++ l2) = mbind f l1 ++ mbind f l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → list B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(l1 ++ l2) ≫= f = (l1 ≫= f) ++ l2 ≫= f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → list B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(l1 ++ l2) ≫= f = (l1 ≫= f) ++ l2 ≫= f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> l1; [| <span class="nb">cbn</span>; <span class="nb">rewrite</span> IHl1, app_assoc].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16f"><span class="kn">Lemma</span> <span class="nf">mbind_nils</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; list B) (<span class="nv">l</span> : list A),
    Forall (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x = []) l -&gt;
      mbind f l = [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A → list B) (<span class="nv">l</span> : list A),
  Forall (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = []) l → l ≫= f = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk170"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A → list B) (<span class="nv">l</span> : list A),
  Forall (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = []) l → l ≫= f = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk171"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → list B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x = []</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = []) l</span></span></span><br><span><var>IHForall</var><span class="hyp-type"><b>: </b><span>l ≫= f = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x ++ l ≫= f = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> H, IHForall; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk172"><span class="kn">Lemma</span> <span class="nf">list_subseteq_inv_app</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A),
    l1 ++ l2 ⊆ l3 -&gt; l1 ⊆ l3 /\ l2 ⊆ l3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A),
  l1 ++ l2 ⊆ l3 → l1 ⊆ l3 ∧ l2 ⊆ l3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk173"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A),
  l1 ++ l2 ⊆ l3 → l1 ⊆ l3 ∧ l2 ⊆ l3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk174"><span class="nb">unfold</span> subseteq, list_subseteq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">l3</span> : list A),
  (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 ++ l2 → x ∈ l3)
  → (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 → x ∈ l3)
    ∧ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l2 → x ∈ l3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk175"><span class="nb">intros</span> A l1 l2 l3 Hsub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2, l3</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 ++ l2 → x ∈ l3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 → x ∈ l3)
∧ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l2 → x ∈ l3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk176"><span class="nb">split</span>; <span class="nb">intros</span> x Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2, l3</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 ++ l2 → x ∈ l3</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ l3</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk177" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2, l3</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 ++ l2 → x ∈ l3</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x ∈ l2</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk177"><hr></label><div class="goal-conclusion">x ∈ l3</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk178">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2, l3</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 ++ l2 → x ∈ l3</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x ∈ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ l3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hsub, elem_of_app; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk179">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l2, l3</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l1 ++ l2 → x ∈ l3</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x ∈ l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ l3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hsub, elem_of_app; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk17a">#[export] <span class="kn">Instance</span> <span class="nf">sum_list_with_proper</span> `(f : index -&gt; nat) :
  Proper ((≡ₚ) ==&gt; (=)) (sum_list_with f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (Permutation ==&gt; eq) (sum_list_with f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk17b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (Permutation ==&gt; eq) (sum_list_with f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk17c"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">cbn</span>; [<span class="bp">done</span> | ..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l ≡ₚ l&#39;</span></span></span><br><span><var>IHPermutation</var><span class="hyp-type"><b>: </b><span>sum_list_with f l = sum_list_with f l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x + sum_list_with f l = f x + sum_list_with f l&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk17d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk17d"><hr></label><div class="goal-conclusion">f y + (f x + sum_list_with f l) =
f x + (f y + sum_list_with f l)</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk17e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l, l', l''</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l ≡ₚ l&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l&#39; ≡ₚ l&#39;&#39;</span></span></span><br><span><var>IHPermutation1</var><span class="hyp-type"><b>: </b><span>sum_list_with f l =
sum_list_with f l&#39;</span></span></span><br><span><var>IHPermutation2</var><span class="hyp-type"><b>: </b><span>sum_list_with f l&#39; =
sum_list_with f l&#39;&#39;</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk17e"><hr></label><div class="goal-conclusion">sum_list_with f l = sum_list_with f l&#39;&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk17f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l ≡ₚ l&#39;</span></span></span><br><span><var>IHPermutation</var><span class="hyp-type"><b>: </b><span>sum_list_with f l = sum_list_with f l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x + sum_list_with f l = f x + sum_list_with f l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHPermutation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk180">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f y + (f x + sum_list_with f l) =
f x + (f y + sum_list_with f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk181">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l, l', l''</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l ≡ₚ l&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l&#39; ≡ₚ l&#39;&#39;</span></span></span><br><span><var>IHPermutation1</var><span class="hyp-type"><b>: </b><span>sum_list_with f l =
sum_list_with f l&#39;</span></span></span><br><span><var>IHPermutation2</var><span class="hyp-type"><b>: </b><span>sum_list_with f l&#39; =
sum_list_with f l&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_list_with f l = sum_list_with f l&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk182"><span class="kn">Lemma</span> <span class="nf">sum_list_with_ext_forall</span> <span class="nv">index</span> (<span class="nv">f</span> <span class="nv">g</span> : index -&gt; nat) (<span class="nv">l</span> : list index) :
  (<span class="kr">forall</span> (<span class="nv">i</span> : index), i ∈ l -&gt; f i = g i) -&gt;
    sum_list_with f l = sum_list_with g l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = g i)
→ sum_list_with f l = sum_list_with g l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk183"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = g i)
→ sum_list_with f l = sum_list_with g l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk184"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span> Heq; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = g i)
→ sum_list_with f l = sum_list_with g l</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ a :: l → f i = g i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a + sum_list_with f l = g a + sum_list_with g l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk185"><span class="nb">rewrite</span> Heq <span class="bp">by</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = g i)
→ sum_list_with f l = sum_list_with g l</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ a :: l → f i = g i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g a + sum_list_with f l = g a + sum_list_with g l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk186"><span class="nb">rewrite</span> IHl; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = g i)
→ sum_list_with f l = sum_list_with g l</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ a :: l → f i = g i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = g i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">apply</span> Heq; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk187"><span class="kn">Lemma</span> <span class="nf">sum_list_with_zero</span> `(f : index -&gt; nat) (l : list index) :
  sum_list_with  f l = <span class="mi">0</span> &lt;-&gt; <span class="kr">forall</span> (<span class="nv">i</span> : index), i ∈ l -&gt; f i = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_list_with f l = <span class="mi">0</span> ↔ (<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk188"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_list_with f l = <span class="mi">0</span> ↔ (<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk189"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_list_with f l = <span class="mi">0</span> → <span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk18a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk18a"><hr></label><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span>) → sum_list_with f l = <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk18b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_list_with f l = <span class="mi">0</span> → <span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk18c"><span class="nb">intros</span> Hsum i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hsum</var><span class="hyp-type"><b>: </b><span>sum_list_with f l = <span class="mi">0</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f i = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk18d"><span class="nb">apply</span> sum_list_with_in <span class="kr">with</span> (f := f) <span class="kr">in</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hsum</var><span class="hyp-type"><b>: </b><span>sum_list_with f l = <span class="mi">0</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>f i ≤ sum_list_with f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f i = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk18e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span>) → sum_list_with f l = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk18f"><span class="nb">induction</span> l; <span class="nb">intros</span> Hall; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span>)
→ sum_list_with f l = <span class="mi">0</span></span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ a :: l → f i = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a + sum_list_with f l = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk190"><span class="nb">rewrite</span> Hall <span class="bp">by</span> <span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span>)
→ sum_list_with f l = <span class="mi">0</span></span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ a :: l → f i = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> + sum_list_with f l = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk191"><span class="nb">rewrite</span> IHl; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index → nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span>)
→ sum_list_with f l = <span class="mi">0</span></span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ a :: l → f i = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">i</span> : index, i ∈ l → f i = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">apply</span> Hall; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk192"><span class="kn">Lemma</span> <span class="nf">dsig_NoDup_map</span> `(P : A -&gt; <span class="kt">Prop</span>) `{Pdec : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)} :
  <span class="kr">forall</span> (<span class="nv">l</span> : list (dsig P)),
    NoDup l &lt;-&gt; NoDup (map proj1_sig l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list (dsig P), NoDup l ↔ NoDup (map proj1_sig l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk193"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list (dsig P), NoDup l ↔ NoDup (map proj1_sig l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk194"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup l → NoDup (map proj1_sig l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk195" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk195"><hr></label><div class="goal-conclusion">NoDup (map proj1_sig l) → NoDup l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk196">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup l → NoDup (map proj1_sig l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk197"><span class="nb">induction</span> <span class="mi">1</span> <span class="kr">as</span> [| da dl Hda]; <span class="nb">cbn</span>; <span class="nb">constructor</span>; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>da</var><span class="hyp-type"><b>: </b><span>dsig P</span></span></span><br><span><var>dl</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br><span><var>Hda</var><span class="hyp-type"><b>: </b><span>da ∉ dl</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>NoDup dl</span></span></span><br><span><var>IHNoDup</var><span class="hyp-type"><b>: </b><span>NoDup (map proj1_sig dl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">`da ∉ map proj1_sig dl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk198"><span class="nb">rewrite</span> elem_of_list_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>da</var><span class="hyp-type"><b>: </b><span>dsig P</span></span></span><br><span><var>dl</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br><span><var>Hda</var><span class="hyp-type"><b>: </b><span>da ∉ dl</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>NoDup dl</span></span></span><br><span><var>IHNoDup</var><span class="hyp-type"><b>: </b><span>NoDup (map proj1_sig dl)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ (<span class="kr">∃</span> <span class="nv">y</span> : {x : A | bool_decide (P x)},
     `da = `y ∧ y ∈ dl)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk199"><span class="nb">intros</span> (_da &amp; Heq &amp; H_da).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>da</var><span class="hyp-type"><b>: </b><span>dsig P</span></span></span><br><span><var>dl</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br><span><var>Hda</var><span class="hyp-type"><b>: </b><span>da ∉ dl</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>NoDup dl</span></span></span><br><span><var>IHNoDup</var><span class="hyp-type"><b>: </b><span>NoDup (map proj1_sig dl)</span></span></span><br><span><var>_da</var><span class="hyp-type"><b>: </b><span>{x : A | bool_decide (P x)}</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>`da = `_da</span></span></span><br><span><var>H_da</var><span class="hyp-type"><b>: </b><span>_da ∈ dl</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> dsig_eq <span class="kr">in</span> Heq <span class="kr">as</span> &lt;-.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (map proj1_sig l) → NoDup l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19b"><span class="nb">induction</span> l; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">constructor</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>dsig P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup (map proj1_sig l) → NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (`a :: map proj1_sig l) → NoDup (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19c"><span class="nb">rewrite</span> !NoDup_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>dsig P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup (map proj1_sig l) → NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(`a ∉ map proj1_sig l) ∧ NoDup (map proj1_sig l)
→ (a ∉ l) ∧ NoDup l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19d"><span class="nb">intros</span> [Ha ?]; <span class="nb">split</span>; [| <span class="bp">by</span> <span class="nb">apply</span> IHl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>dsig P</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list (dsig P)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup (map proj1_sig l) → NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>`a ∉ map proj1_sig l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>NoDup (map proj1_sig l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∉ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">contradict</span> Ha; <span class="nb">apply</span> elem_of_list_fmap; <span class="nb">eexists</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19e"><span class="kn">Lemma</span> <span class="nf">is_Some_proj_elim</span> {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">m</span> : option A) (<span class="nv">Hsome</span> : is_Some m) (<span class="nv">f</span> : A) (<span class="nv">H</span> : m = Some f) :
  is_Some_proj Hsome = f.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>option A</span></span></span><br><span><var>Hsome</var><span class="hyp-type"><b>: </b><span>is_Some m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m = Some f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_Some_proj Hsome = f</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>option A</span></span></span><br><span><var>Hsome</var><span class="hyp-type"><b>: </b><span>is_Some m</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>m = Some f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_Some_proj Hsome = f</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">subst</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">set_Forall2</span> `{ElemOf A C} (R : relation A) (X : C) :=
  <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ∈ X -&gt; y ∈ X -&gt; x &lt;&gt; y -&gt; R x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">set_Exists2</span> `{ElemOf A C} (R : relation A) (X : C) :=
  <span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ∈ X /\ y ∈ X /\ x &lt;&gt; y /\ R x y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_Forall2_Exists2_props</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  `{SemiSet A C}
  (R : relation A)
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a0"><span class="kn">Lemma</span> <span class="nf">set_Forall2_empty</span> : set_Forall2 R (∅ : C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R (∅ : C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R (∅ : C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Forall2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a2"><span class="kn">Lemma</span> <span class="nf">set_Forall2_singleton</span> (<span class="nv">x</span> : A) : set_Forall2 R ({[ x ]} : C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R ({[x]} : C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R ({[x]} : C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Forall2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a4"><span class="kn">Lemma</span> <span class="nf">set_Forall2_pair</span> (<span class="nv">x</span> <span class="nv">y</span> : A) :
  x &lt;&gt; y -&gt; set_Forall2 R ({[ x; y ]} : C) &lt;-&gt; R x y /\ R y x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ≠ y → set_Forall2 R ({[x; y]} : C) ↔ R x y ∧ R y x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ≠ y → set_Forall2 R ({[x; y]} : C) ↔ R x y ∧ R y x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Forall2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a6"><span class="kn">Lemma</span> <span class="nf">set_Forall2_union</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) :
  set_Forall2 R X -&gt; set_Forall2 R Y -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ∈ X -&gt; y ∈ Y -&gt; x &lt;&gt; y -&gt; R x y /\ R y x) -&gt;
  set_Forall2 R (X ∪ Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R X
→ set_Forall2 R Y
  → (<span class="kr">∀</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ∈ X → y ∈ Y → x ≠ y → R x y ∧ R y x)
    → set_Forall2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R X
→ set_Forall2 R Y
  → (<span class="kr">∀</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ∈ X → y ∈ Y → x ≠ y → R x y ∧ R y x)
    → set_Forall2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Forall2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a8"><span class="kn">Lemma</span> <span class="nf">set_Forall2_union_inv_1</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) :
  set_Forall2 R (X ∪ Y) -&gt; set_Forall2 R X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R (X ∪ Y) → set_Forall2 R X</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R (X ∪ Y) → set_Forall2 R X</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Forall2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1aa"><span class="kn">Lemma</span> <span class="nf">set_Forall2_union_inv_2</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) :
  set_Forall2 R (X ∪ Y) -&gt; set_Forall2 R Y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R (X ∪ Y) → set_Forall2 R Y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1ab"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Forall2 R (X ∪ Y) → set_Forall2 R Y</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Forall2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1ac"><span class="kn">Lemma</span> <span class="nf">set_Exists2_empty</span> : ~ set_Exists2 R (∅ : C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ set_Exists2 R (∅ : C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1ad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ set_Exists2 R (∅ : C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Exists2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1ae"><span class="kn">Lemma</span> <span class="nf">set_Exists2_singleton</span> <span class="nv">x</span> : ~ set_Exists2 R ({[ x ]} : C).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ set_Exists2 R ({[x]} : C)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1af"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ set_Exists2 R ({[x]} : C)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> set_Exists2; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b0"><span class="kn">Lemma</span> <span class="nf">set_Exists2_pair</span> (<span class="nv">x</span> <span class="nv">y</span> : A) :
  set_Exists2 R ({[ x; y ]} : C) &lt;-&gt; x &lt;&gt; y /\ (R x y \/ R y x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R ({[x; y]} : C) ↔ x ≠ y ∧ (R x y ∨ R y x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R ({[x; y]} : C) ↔ x ≠ y ∧ (R x y ∨ R y x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b2"><span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">unfold</span> set_Exists2; set_solver |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ≠ y ∧ (R x y ∨ R y x) → set_Exists2 R {[x; y]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b3"><span class="nb">intros</span> [? []].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R {[x; y]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk1b4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>R y x</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk1b4"><hr></label><div class="goal-conclusion">set_Exists2 R {[x; y]}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R {[x; y]}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>, y; set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>R y x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R {[x; y]}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">y</span>, x; set_solver.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b7"><span class="kn">Lemma</span> <span class="nf">set_Exists2_union_1</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) :
  set_Exists2 R X -&gt; set_Exists2 R (X ∪ Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [x [y Hxy]]; <span class="kr">exists</span> <span class="nv">x</span>, y; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b9"><span class="kn">Lemma</span> <span class="nf">set_Exists2_union_2</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) :
  set_Exists2 R Y -&gt; set_Exists2 R (X ∪ Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R Y → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1ba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R Y → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [x [y Hxy]]; <span class="kr">exists</span> <span class="nv">x</span>, y; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1bb"><span class="kn">Lemma</span> <span class="nf">set_Exists2_union_3</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) (<span class="nv">x</span> <span class="nv">y</span> : A) :
  x ∈ X -&gt; y ∈ Y -&gt; x &lt;&gt; y -&gt; R x y -&gt; set_Exists2 R (X ∪ Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ X → y ∈ Y → x ≠ y → R x y → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1bc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ X → y ∈ Y → x ≠ y → R x y → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>, y; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1bd"><span class="kn">Lemma</span> <span class="nf">set_Exists2_union_4</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) (<span class="nv">x</span> <span class="nv">y</span> : A) :
  x ∈ X -&gt; y ∈ Y -&gt; x &lt;&gt; y -&gt; R y x -&gt; set_Exists2 R (X ∪ Y).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ X → y ∈ Y → x ≠ y → R y x → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1be"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ X → y ∈ Y → x ≠ y → R y x → set_Exists2 R (X ∪ Y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="kr">exists</span> <span class="nv">y</span>, x; set_solver.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1bf"><span class="kn">Lemma</span> <span class="nf">set_Exists2_union_inv</span> (<span class="nv">X</span> <span class="nv">Y</span> : C) :
  set_Exists2 R (X ∪ Y) -&gt;
    set_Exists2 R X \/ set_Exists2 R Y \/
    <span class="kr">exists</span> <span class="nv">x</span> <span class="nv">y</span> : A, x ∈ X /\ y ∈ Y /\ x &lt;&gt; y /\ (R x y \/ R y x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R (X ∪ Y)
→ set_Exists2 R X
  ∨ set_Exists2 R Y
    ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
         x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R (X ∪ Y)
→ set_Exists2 R X
  ∨ set_Exists2 R Y
    ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
         x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c1"><span class="nb">intros</span> (x &amp; y &amp; Hx &amp; Hy &amp; Hneq &amp; Hxy).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>x ∈ X ∪ Y</span></span></span><br><span><var>Hy</var><span class="hyp-type"><b>: </b><span>y ∈ X ∪ Y</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c2"><span class="nb">apply</span> elem_of_union <span class="kr">in</span> Hx <span class="kr">as</span> [], Hy <span class="kr">as</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ X</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ X</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk1c3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ X</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ Y</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk1c3"><hr></label><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk1c4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ Y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ X</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk1c4"><hr></label><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk1c5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ Y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ Y</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk1c5"><hr></label><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ X</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ X</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">x</span>, y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ X</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ Y</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">x</span>, y; <span class="kp">repeat</span> <span class="nb">split</span>; [.. | <span class="nb">left</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ Y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ X</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">right</span>; <span class="kr">exists</span> <span class="nv">y</span>, x; <span class="kp">repeat</span> <span class="nb">split</span>; [.. | <span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1c9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, C</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ElemOf A C</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Empty C</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Singleton A C</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Union C</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>SemiSet A C</span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>relation A</span></span></span><br><span><var>X, Y</var><span class="hyp-type"><b>: </b><span>C</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>x ∈ Y</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>y ∈ Y</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>x ≠ y</span></span></span><br><span><var>Hxy</var><span class="hyp-type"><b>: </b><span>R x y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">set_Exists2 R X
∨ set_Exists2 R Y
  ∨ (<span class="kr">∃</span> <span class="nv">x</span> <span class="nv">y</span> : A,
       x ∈ X ∧ y ∈ Y ∧ x ≠ y ∧ (R x y ∨ R y x))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">left</span>; <span class="kr">exists</span> <span class="nv">x</span>, y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_Forall2_Exists2_props</span>.</span></span></pre></article></body></html>