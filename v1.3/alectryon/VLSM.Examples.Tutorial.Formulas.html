<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Formulas.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.18.0+0.18.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> FunctionalExtensionality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk0"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> prelude.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk1"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> ListExtras.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file coq-itauto.plugin ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> VLSM.Core <span class="kn">Require Import</span> VLSM Composition ProjectionTraces.</span></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Tutorial: VLSMs that Generate Logical Formulas</h1>
<div class="paragraph"> </div>

  This module shows how VLSMs can be used to generate propositional logic formulas.
  To achieve this, we define a family of VLSMs, one for each formula grammar rule, which
  generates messages according to the given rule. By composition, we obtain that
  the valid messages are precisely the "strings" which can be produced by the
  formula grammar.

<div class="paragraph"> </div>

  To strengthen the connection between formulas and VLSMs, we also define formulas
  as an inductive type and prove an equivalence between the inductively defined formulas
  and those obtained as valid messages of the composition of VLSMs from above.

<div class="paragraph"> </div>

  To simplify the presentation, the grammar we consider for formulas is
  unambiguous and uses prefix notation:

<div class="paragraph"> </div>
<code>f ::= ‚ä§ | ‚ä• | x | ¬¨ f | ‚àß f f | ‚à® f f | ‚Üí f f | ‚Üî f f</code>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_formula</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  `{EqDecision Var}
  `{base.Infinite Var}
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">symbol</span> : <span class="kt">Type</span> :=
| Top
| Bot
| PVar (x : Var)
| Neg
| Conj
| Disj
| Impl
| Iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk2">#[export] <span class="kn">Instance</span> <span class="nf">symbol_dec</span> : EqDecision symbol.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision symbol</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision symbol</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk4"><span class="nb">unfold</span> EqDecision, Decision; <span class="bp">decide equality</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>x0, x1</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 = x1} + {x0 ‚â† x1}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (decide (x0 = x1)); [<span class="nb">left</span> | <span class="nb">right</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression</span> : <span class="kt">Type</span> := list symbol.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Formula</span> : <span class="kt">Type</span> :=
| FTop
| FBot
| FVar (x : Var)
| FNeg (f : Formula)
| FConj (f1 f2 : Formula)
| FDisj (f1 f2 : Formula)
| FImpl (f1 f2 : Formula)
| FIff (f1 f2 : Formula).</span></span></pre><div class="doc">
  We introduce the following notations to allow us to more easily write formulas.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;‚ä§&quot;</span> := FTop.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;‚ä•&quot;</span> := FBot.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;x ‚à® y&quot;</span> := (FDisj x y) (<span class="kn">at level</span> <span class="mi">85</span>, <span class="kn">right associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;x ‚àß y&quot;</span> := (FConj x y) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;x ‚Üí y&quot;</span> := (FImpl x y) (<span class="kn">at level</span> <span class="mi">99</span>, y <span class="kn">at level</span> <span class="mi">200</span>, <span class="kn">right associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;x ‚Üî y&quot;</span> := (FIff x y) (<span class="kn">at level</span> <span class="mi">95</span>, <span class="kn">no associativity</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input">#[local] <span class="kn">Notation</span> <span class="s2">&quot;¬¨ x&quot;</span> := (FNeg x) (<span class="kn">at level</span> <span class="mi">75</span>, <span class="kn">right associativity</span>).</span></span></pre><div class="doc">
  Similarly to the notations above, the purpose of this coercion is to allow
  using variables directly as formulas.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">FVar</span> : Var &gt;-&gt; Formula.</span></span></pre><div class="doc">
A <span class="inlinecode"><span class="id" title="var">Formula</span></span> is flattened to an <span class="inlinecode"><span class="id" title="var">expression</span></span> using prefix notation. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">flatten_formula</span> (<span class="nv">f</span> : Formula) : expression :=
  <span class="kr">match</span> f <span class="kr">with</span>
  | FTop =&gt; [Top]
  | FBot =&gt; [Bot]
  | FVar x =&gt; [PVar x]
  | ¬¨ f =&gt; Neg :: flatten_formula f
  | f1 ‚àß f2 =&gt; Conj :: flatten_formula f1 ++ flatten_formula f2
  | f1 ‚à® f2 =&gt; Disj :: flatten_formula f1 ++ flatten_formula f2
  | f1 ‚Üí f2 =&gt; Impl :: flatten_formula f1 ++ flatten_formula f2
  | f1 ‚Üî f2 =&gt; Iff :: flatten_formula f1 ++ flatten_formula f2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk5"><span class="kn">Lemma</span> <span class="nf">flatten_formula_nzlen</span> :
  <span class="kr">forall</span> (<span class="nv">f</span> : Formula),
    length (flatten_formula f) &gt; <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">f</span> : Formula, length (flatten_formula f) &gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">f</span> : Formula, length (flatten_formula f) &gt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> []; <span class="nb">cbn</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<a id="lab2"></a><h2 class="section">Encoding formulas as VLSMs</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<a id="lab3"></a><h3 class="section">VLSM for top and bottom rules</h3>
<div class="paragraph"> </div>

  This is a very simple VLSM, with a single state and a single label, accepting
  no input and outputing the expression containing just the symbol parameter.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_expression_const_vlsm</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  (<span class="nv">ct</span> : symbol)
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_const_vlsm_type</span> : VLSMType expression :=
{|
  state := unit;
  label := unit;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_const_vlsm_machine</span> : VLSMMachine expression_const_vlsm_type :=
{|
  initial_state_prop := const <span class="kt">True</span>;
  s0 := populate (exist _ () I);
  initial_message_prop := const <span class="kt">False</span>;
  transition := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; ((), Some [ct]);
  valid := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">som</span> =&gt; som.<span class="mi">2</span> = None;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_const_vlsm</span> : VLSM expression :=
  mk_vlsm expression_const_vlsm_machine.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_expression_const_vlsm</span>.</span></span></pre><div class="doc">
<a id="lab4"></a><h3 class="section">VLSM for the variable rule</h3>
<div class="paragraph"> </div>

  This VLSM has a single state and its labels are the variables.
  Its behavior is to accept no input and to output the expression containing
  just the variable specified by the label of the transition.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_expression_var_vlsm</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_var_vlsm_type</span> : VLSMType expression :=
{|
  state := unit;
  label := Var;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_var_vlsm_machine</span> : VLSMMachine expression_var_vlsm_type :=
{|
  initial_state_prop := const <span class="kt">True</span>;
  s0 := populate (exist _ () I);
  initial_message_prop := const <span class="kt">False</span>;
  transition := <span class="kr">fun</span> <span class="nv">l</span> <span class="nv">_</span> =&gt; ((), Some [PVar l]);
  valid := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">som</span> =&gt; som.<span class="mi">2</span> = None;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_var_vlsm</span> : VLSM expression :=
  mk_vlsm expression_var_vlsm_machine.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_expression_var_vlsm</span>.</span></span></pre><div class="doc">
<a id="lab5"></a><h3 class="section">VLSM for the negation rule</h3>
<div class="paragraph"> </div>

  This VLSM has a single state and a single label, accepts as input an expression
  and outputs the expression obtained by prefixing the input with the negation
  symbol.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_expression_neg_vlsm</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_neg_vlsm_type</span> : VLSMType expression :=
{|
  state := unit;
  label := unit;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_neg_vlsm_transition</span> (<span class="nv">_</span> : unit)
  (<span class="nv">som</span> : unit * option expression) : unit * option expression :=
  <span class="kr">match</span> som.<span class="mi">2</span> <span class="kr">with</span>
  | None =&gt; som
  | Some m =&gt; ((), Some (Neg :: m))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_neg_vlsm_machine</span> : VLSMMachine expression_neg_vlsm_type :=
{|
  initial_state_prop := const <span class="kt">True</span>;
  s0 := populate (exist _ () I);
  initial_message_prop := const <span class="kt">False</span>;
  transition := expression_neg_vlsm_transition;
  valid := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">som</span> =&gt; is_Some som.<span class="mi">2</span>;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_neg_vlsm</span> : VLSM expression :=
  mk_vlsm expression_neg_vlsm_machine.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_expression_neg_vlsm</span>.</span></span></pre><div class="doc">
<a id="lab6"></a><h3 class="section">VLSM for binary connective rules</h3>
<div class="paragraph"> </div>

  This VLSM has a single label and its states are <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">expression</span></span> with
  <span class="inlinecode"><span class="id" title="var">None</span></span> being the initial state.
  From the initial state it accepts as input an expression and transitions
  to the state holding that expression.
  From a state holding an expression it accepts as input an expression and
  outputs the connective symbol (parameter) followed by the concatenation of
  the expression in the state and that in the input.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_expression_binop_vlsm</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  (<span class="nv">binop</span> : symbol)
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_binop_vlsm_type</span> : VLSMType expression :=
{|
  state := option expression;
  label := unit;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_binop_vlsm_transition</span> (<span class="nv">_</span> : unit)
  (<span class="nv">som</span> : option expression * option expression) :
  option expression * option expression :=
  <span class="kr">match</span> som <span class="kr">with</span>
  | (_, None) =&gt; som
  | (None, Some f) =&gt; (Some f, None)
  | (Some f1, Some f2) =&gt; (None, Some (binop :: f1 ++ f2))
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_binop_vlsm_machine</span> : VLSMMachine expression_binop_vlsm_type :=
{|
  initial_state_prop := <span class="kr">fun</span> <span class="nv">o</span> =&gt; o = None;
  s0 := populate (exist _ None eq_refl);
  initial_message_prop := const <span class="kt">False</span>;
  transition := expression_binop_vlsm_transition;
  valid := <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">som</span> =&gt; is_Some som.<span class="mi">2</span>;
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_binop_vlsm</span> : VLSM expression :=
  mk_vlsm expression_binop_vlsm_machine.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_expression_binop_vlsm</span>.</span></span></pre><div class="doc">
<a id="lab7"></a><h3 class="section">VLSM for expressions</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_expression_vlsm</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">index</span> :=
| ITop
| IBot
| IVar
| INeg
| IConj
| IDisj
| IImpl
| IIff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk7">#[export] <span class="kn">Instance</span> <span class="nf">index_dec</span> : EqDecision index.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision index</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision index</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> ? ?; <span class="nb">unfold</span> Decision; <span class="bp">decide equality</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">symbol_to_index</span> (<span class="nv">s</span> : symbol) : index :=
  <span class="kr">match</span> s <span class="kr">with</span>
  | Top =&gt; ITop
  | Bot =&gt; IBot
  | PVar _ =&gt; IVar
  | Neg =&gt; INeg
  | Conj =&gt; IConj
  | Disj =&gt; IDisj
  | Impl =&gt; IImpl
  | Iff =&gt; IIff
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_components</span> (<span class="nv">i</span> : index) : VLSM expression :=
  <span class="kr">match</span> i <span class="kr">with</span>
  | ITop =&gt; expression_const_vlsm Top
  | IBot =&gt; expression_const_vlsm Bot
  | IVar =&gt; expression_var_vlsm
  | INeg =&gt; expression_neg_vlsm
  | IConj =&gt; expression_binop_vlsm Conj
  | IDisj =&gt; expression_binop_vlsm Disj
  | IImpl =&gt; expression_binop_vlsm Impl
  | IIff =&gt; expression_binop_vlsm Iff
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">default_label</span> (<span class="nv">i</span> : index) : label (expression_components i) :=
  <span class="kr">match</span> i <span class="kr">with</span>
  | IVar =&gt; <span class="kp">fresh</span> []
  | _ =&gt; ()
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">default_composite_label</span>
  (<span class="nv">i</span> : index) : composite_label expression_components :=
    existT i (default_label i).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expression_vlsm</span> : VLSM expression :=
  free_composite_vlsm expression_components.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_expression_vlsm</span>.</span></span></pre><div class="doc">
<a id="lab8"></a><h2 class="section">Characterization of valid messages as formulas</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_valid_message_char</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">well_formed_expression</span> : expression -&gt; <span class="kt">Prop</span> :=
  valid_message_prop expression_vlsm.</span></span></pre><div class="doc">
  We will show below (lemma <span class="inlinecode"><span class="id" title="var">flatten_formula_prefix</span></span>) that no (strict) prefix of
  a flattened formula can be the flattening of another formula, which is a key
  result for establishing the injectivity of the <span class="inlinecode"><span class="id" title="var">flatten_formula</span></span> function.

<div class="paragraph"> </div>

  To reach this result, we first define this property and prove several results
  about formulas satisfying it.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">formula_prefix_is_not_formula_prop</span> (<span class="nv">f1</span> : Formula) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> (<span class="nv">s</span> : expression), strict prefix s (flatten_formula f1) -&gt;
  <span class="kr">forall</span> (<span class="nv">f2</span> : Formula), flatten_formula f2 &lt;&gt; s.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk9"><span class="kn">Lemma</span> <span class="nf">flatten_formula_formula_prefix_is_not_formula_prop_app</span> :
  <span class="kr">forall</span> (<span class="nv">fa</span> : Formula), formula_prefix_is_not_formula_prop fa -&gt;
  <span class="kr">forall</span> (<span class="nv">fb</span> : Formula), formula_prefix_is_not_formula_prop fb -&gt;
  <span class="kr">forall</span> (<span class="nv">sufa</span> <span class="nv">sufb</span> : expression),
    flatten_formula fa ++ sufa = flatten_formula fb ++ sufb -&gt;
    flatten_formula fa = flatten_formula fb /\ sufa = sufb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">fa</span> : Formula,
  formula_prefix_is_not_formula_prop fa
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fb</span> : Formula,
      formula_prefix_is_not_formula_prop fb
      ‚Üí <span class="kr">‚àÄ</span> <span class="nv">sufa</span> <span class="nv">sufb</span> : expression,
          flatten_formula fa ++ sufa =
          flatten_formula fb ++ sufb
          ‚Üí flatten_formula fa = flatten_formula fb
            ‚àß sufa = sufb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">fa</span> : Formula,
  formula_prefix_is_not_formula_prop fa
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fb</span> : Formula,
      formula_prefix_is_not_formula_prop fb
      ‚Üí <span class="kr">‚àÄ</span> <span class="nv">sufa</span> <span class="nv">sufb</span> : expression,
          flatten_formula fa ++ sufa =
          flatten_formula fb ++ sufb
          ‚Üí flatten_formula fa = flatten_formula fb
            ‚àß sufa = sufb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb"><span class="nb">intros</span> fa Hfa fb Hfb sufa sufb Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(flatten_formula fa = flatten_formula fb ‚àß sufa = sufb)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkc"><span class="nb">cut</span> (flatten_formula fa = flatten_formula fb);
    [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span>; simplify_list_eq |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkd"><span class="nb">destruct</span> (decide (prefix (flatten_formula fa) (flatten_formula fb))) <span class="kr">as</span> [Hab | Hab],
    (decide (prefix (flatten_formula fb) (flatten_formula fa))) <span class="kr">as</span> [Hba | Hba].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>flatten_formula fa
`prefix_of` flatten_formula fb</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>flatten_formula fb
`prefix_of` flatten_formula fa</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>flatten_formula fa
`prefix_of` flatten_formula fb</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chke"><hr></label><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>flatten_formula fb
`prefix_of` flatten_formula fa</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkf"><hr></label><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk10"><hr></label><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>flatten_formula fa
`prefix_of` flatten_formula fb</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>flatten_formula fb
`prefix_of` flatten_formula fa</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk12"><span class="nb">apply</span> prefix_length_eq; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>flatten_formula fa
`prefix_of` flatten_formula fb</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>flatten_formula fb
`prefix_of` flatten_formula fa</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (flatten_formula fb)
‚â§ length (flatten_formula fa)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> Hba <span class="kr">as</span> [suf -&gt;]; <span class="nb">rewrite</span> app_length; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk13">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>flatten_formula fa
`prefix_of` flatten_formula fb</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">exfalso</span>; <span class="nb">eapply</span> Hfb.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk14">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>flatten_formula fb
`prefix_of` flatten_formula fa</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">exfalso</span>; <span class="nb">eapply</span> Hfa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk15">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa = flatten_formula fb</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk16"><span class="nb">exfalso</span>; <span class="nb">revert</span> sufb Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">sufb</span> : expression,
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk17"><span class="nb">induction</span> sufa <span class="nb">using</span> rev_ind; <span class="nb">intros</span>;
      [<span class="bp">by</span> simplify_list_eq; <span class="bp">contradict</span> Hba; <span class="nb">eexists</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>sufa</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br><span><var>IHsufa</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">sufb</span> : expression,
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb ‚Üí <span class="kt">False</span></span></span></span><br><span><var>sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa ++ [x] =
flatten_formula fb ++ sufb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk18">destruct_list_last sufb sufb&#39; b Hsufb; simplify_list_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>sufa</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br><span><var>IHsufa</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">sufb</span> : expression,
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb ‚Üí <span class="kt">False</span></span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa ++ [x] =
flatten_formula fb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br><span><var>IHsufa</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">sufb</span> : expression,
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb ‚Üí <span class="kt">False</span></span></span></span><br><span><var>sufb'</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb&#39;</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk19"><hr></label><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk1a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>sufa</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br><span><var>IHsufa</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">sufb</span> : expression,
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb ‚Üí <span class="kt">False</span></span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa ++ [x] =
flatten_formula fb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">contradict</span> Hab; <span class="nb">eexists</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk1b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa</span></span></span><br><span><var>fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb</span></span></span><br><span><var>sufa</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fa
   `prefix_of` flatten_formula fb)%type</span></span></span><br><span><var>Hba</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula fb
   `prefix_of` flatten_formula fa)%type</span></span></span><br><span><var>IHsufa</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">sufb</span> : expression,
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb ‚Üí <span class="kt">False</span></span></span></span><br><span><var>sufb'</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> IHsufa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk1c"><span class="kn">Lemma</span> <span class="nf">flatten_formula_formula_prefix_is_not_formula_prop_app_prefix</span> :
  <span class="kr">forall</span> (<span class="nv">fa1</span> : Formula), formula_prefix_is_not_formula_prop fa1 -&gt;
  <span class="kr">forall</span> (<span class="nv">fa2</span> : Formula), formula_prefix_is_not_formula_prop fa2 -&gt;
  <span class="kr">forall</span> (<span class="nv">fb1</span> : Formula), formula_prefix_is_not_formula_prop fb1 -&gt;
  <span class="kr">forall</span> (<span class="nv">fb2</span> : Formula), formula_prefix_is_not_formula_prop fb2 -&gt;
    flatten_formula fb1 ++ flatten_formula fb2 `prefix_of`
      flatten_formula fa1 ++ flatten_formula fa2 -&gt;
    flatten_formula fa1 ++ flatten_formula fa2
      =
    flatten_formula fb1 ++ flatten_formula fb2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">fa1</span> : Formula,
  formula_prefix_is_not_formula_prop fa1
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fa2</span> : Formula,
      formula_prefix_is_not_formula_prop fa2
      ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fb1</span> : Formula,
          formula_prefix_is_not_formula_prop fb1
          ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fb2</span> : Formula,
              formula_prefix_is_not_formula_prop fb2
              ‚Üí flatten_formula fb1 ++
                flatten_formula fb2
                `prefix_of` flatten_formula fa1 ++
                            flatten_formula fa2
                ‚Üí flatten_formula fa1 ++
                  flatten_formula fa2 =
                  flatten_formula fb1 ++
                  flatten_formula fb2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk1d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">fa1</span> : Formula,
  formula_prefix_is_not_formula_prop fa1
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fa2</span> : Formula,
      formula_prefix_is_not_formula_prop fa2
      ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fb1</span> : Formula,
          formula_prefix_is_not_formula_prop fb1
          ‚Üí <span class="kr">‚àÄ</span> <span class="nv">fb2</span> : Formula,
              formula_prefix_is_not_formula_prop fb2
              ‚Üí flatten_formula fb1 ++
                flatten_formula fb2
                `prefix_of` flatten_formula fa1 ++
                            flatten_formula fa2
                ‚Üí flatten_formula fa1 ++
                  flatten_formula fa2 =
                  flatten_formula fb1 ++
                  flatten_formula fb2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk1e"><span class="nb">intros</span> fa1 Hfa1 fa2 Hfa2 fb1 Hfb1 fb2 Hfb2 [suf Hpre].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa1</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa1</span></span></span><br><span><var>fa2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa2</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa2</span></span></span><br><span><var>fb1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb1</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb1</span></span></span><br><span><var>fb2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb2</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb2</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula fa1 ++ flatten_formula fa2 =
(flatten_formula fb1 ++ flatten_formula fb2) ++
suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa1 ++ flatten_formula fa2 =
flatten_formula fb1 ++ flatten_formula fb2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk1f"><span class="nb">rewrite</span> &lt;- app_assoc, &lt;- (app_nil_r (flatten_formula fa2)) <span class="kr">in</span> Hpre.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa1</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa1</span></span></span><br><span><var>fa2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa2</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa2</span></span></span><br><span><var>fb1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb1</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb1</span></span></span><br><span><var>fb2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb2</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb2</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula fa1 ++
flatten_formula fa2 ++ [] =
flatten_formula fb1 ++
flatten_formula fb2 ++ suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fa1 ++ flatten_formula fa2 =
flatten_formula fb1 ++ flatten_formula fb2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk20"><span class="nb">apply</span> flatten_formula_formula_prefix_is_not_formula_prop_app <span class="kr">in</span> Hpre <span class="kr">as</span> [-&gt; Hpre]; [| <span class="bp">done</span>..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa1</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa1</span></span></span><br><span><var>fa2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfa2</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fa2</span></span></span><br><span><var>fb1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb1</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb1</span></span></span><br><span><var>fb2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hfb2</var><span class="hyp-type"><b>: </b><span>formula_prefix_is_not_formula_prop fb2</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula fa2 ++ [] =
flatten_formula fb2 ++ suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flatten_formula fb1 ++ flatten_formula fa2 =
flatten_formula fb1 ++ flatten_formula fb2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> flatten_formula_formula_prefix_is_not_formula_prop_app <span class="kr">in</span> Hpre <span class="kr">as</span> [-&gt; _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk21"><span class="kn">Lemma</span> <span class="nf">flatten_formula_prefix_helper</span>
  (<span class="nv">f1_1</span> <span class="nv">f1_2</span> : Formula)
  (<span class="nv">IHn</span> : <span class="kr">forall</span> (<span class="nv">y</span> : nat),
    y &lt; S (length (flatten_formula f1_1 ++ flatten_formula f1_2)) -&gt;
    <span class="kr">forall</span> (<span class="nv">f1</span> : Formula), y = length (flatten_formula f1) -&gt;
    formula_prefix_is_not_formula_prop f1)
  (<span class="nv">suf</span> : list symbol)
  (<span class="nv">f2_1</span> <span class="nv">f2_2</span> : Formula)
  (<span class="nv">Hpre</span> : flatten_formula f1_1 ++ flatten_formula f1_2 =
    flatten_formula f2_1 ++ flatten_formula f2_2 ++ suf)
  (<span class="nv">s</span> : symbol) :
    s :: flatten_formula f1_1 ++ flatten_formula f1_2
      `prefix_of`
    s :: flatten_formula f2_1 ++ flatten_formula f2_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
flatten_formula f2_1 ++
flatten_formula f2_2 ++ suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s :: flatten_formula f1_1 ++ flatten_formula f1_2
`prefix_of` s
            :: flatten_formula f2_1 ++
               flatten_formula f2_2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk22"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
flatten_formula f2_1 ++
flatten_formula f2_2 ++ suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s :: flatten_formula f1_1 ++ flatten_formula f1_2
`prefix_of` s
            :: flatten_formula f2_1 ++
               flatten_formula f2_2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk23"><span class="nb">rewrite</span> app_assoc <span class="kr">in</span> Hpre.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s :: flatten_formula f1_1 ++ flatten_formula f1_2
`prefix_of` s
            :: flatten_formula f2_1 ++
               flatten_formula f2_2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk24"><span class="nb">erewrite</span> flatten_formula_formula_prefix_is_not_formula_prop_app_prefix;
    [<span class="bp">done</span> | .. | <span class="bp">by</span> <span class="nb">eexists</span>]; (<span class="nb">eapply</span> IHn; [| <span class="bp">done</span>]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (flatten_formula f1_1) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk25"><hr></label><div class="goal-conclusion">length (flatten_formula f1_2) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk26"><hr></label><div class="goal-conclusion">length (flatten_formula f2_1) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk27"><hr></label><div class="goal-conclusion">length (flatten_formula f2_2) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk28">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (flatten_formula f1_1) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_length; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk29">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (flatten_formula f1_2) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_length; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk2a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (flatten_formula f2_1) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hpre, !app_length; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1_1, f1_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1_1 ++
        flatten_formula f1_2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2_1, f2_2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1_1 ++ flatten_formula f1_2 =
(flatten_formula f2_1 ++ flatten_formula f2_2) ++
suf</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (flatten_formula f2_2) &lt;
S
  (length
     (flatten_formula f1_1 ++ flatten_formula f1_2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hpre, !app_length; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk2c"><span class="kn">Lemma</span> <span class="nf">flatten_formula_prefix</span> :
  <span class="kr">forall</span> (<span class="nv">f1</span> : Formula),
    formula_prefix_is_not_formula_prop f1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula, formula_prefix_is_not_formula_prop f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk2d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula, formula_prefix_is_not_formula_prop f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk2e"><span class="nb">intros</span> f1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">formula_prefix_is_not_formula_prop f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk2f"><span class="nb">remember</span> (length (flatten_formula f1)) <span class="kr">as</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqn</var><span class="hyp-type"><b>: </b><span>n = length (flatten_formula f1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">formula_prefix_is_not_formula_prop f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk30"><span class="nb">revert</span> f1 Heqn; <span class="nb">induction</span> n <span class="kr">as</span> [n IHn] <span class="nb">using</span> (well_founded_induction lt_wf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; n
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
  n = length (flatten_formula f1)
  ‚Üí formula_prefix_is_not_formula_prop f1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk31"><span class="nb">intros</span> f1 -&gt; s [[suf Hpre] Hproper] f2 &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length (flatten_formula f1)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hproper</var><span class="hyp-type"><b>: </b><span>(¬¨ flatten_formula f1
   `prefix_of` flatten_formula f2)%type</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1 = flatten_formula f2 ++ suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk32"><span class="nb">destruct</span> f1, f2; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="kp">try</span> <span class="bp">congruence</span>; simplify_list_eq;
    [<span class="bp">done</span> | <span class="bp">done</span> | <span class="bp">done</span> | | <span class="bp">by</span> <span class="bp">contradict</span> Hproper; <span class="nb">eapply</span> flatten_formula_prefix_helper..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (flatten_formula f1))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hproper</var><span class="hyp-type"><b>: </b><span>(¬¨ Neg :: flatten_formula f1
   `prefix_of` Neg :: flatten_formula f2)%type</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1 = flatten_formula f2 ++ suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk33"><span class="nb">eapply</span> IHn <span class="kr">with</span> (f1 := f1) (f2 := f2); <span class="nb">cycle</span> <span class="mi">1</span>; [<span class="bp">done</span> | | <span class="bp">done</span> | <span class="bp">by</span> <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (flatten_formula f1))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hproper</var><span class="hyp-type"><b>: </b><span>(¬¨ Neg :: flatten_formula f1
   `prefix_of` Neg :: flatten_formula f2)%type</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1 = flatten_formula f2 ++ suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">strict prefix (flatten_formula f2)
  (flatten_formula f1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk34"><span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">eexists</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (flatten_formula f1))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hproper</var><span class="hyp-type"><b>: </b><span>(¬¨ Neg :: flatten_formula f1
   `prefix_of` Neg :: flatten_formula f2)%type</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1 = flatten_formula f2 ++ suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(¬¨ flatten_formula f1 `prefix_of` flatten_formula f2)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk35"><span class="nb">intros</span> [suf&#39; Hsuf&#39;]; <span class="bp">contradict</span> Hproper.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (flatten_formula f1))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> : Formula,
      y = length (flatten_formula f1)
      ‚Üí formula_prefix_is_not_formula_prop f1</span></span></span><br><span><var>suf</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula f1 = flatten_formula f2 ++ suf</span></span></span><br><span><var>suf'</var><span class="hyp-type"><b>: </b><span>list symbol</span></span></span><br><span><var>Hsuf'</var><span class="hyp-type"><b>: </b><span>flatten_formula f2 =
flatten_formula f1 ++ suf&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Neg :: flatten_formula f1
`prefix_of` Neg :: flatten_formula f2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">suf&#39;</span>; <span class="nb">rewrite</span> Hsuf&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk36"><span class="kn">Lemma</span> <span class="nf">flatten_formula_common_prefix</span> :
  <span class="kr">forall</span> (<span class="nv">fa</span> <span class="nv">fb</span> : Formula) (<span class="nv">sufa</span> <span class="nv">sufb</span> : expression),
    flatten_formula fa ++ sufa = flatten_formula fb ++ sufb -&gt;
    flatten_formula fa = flatten_formula fb /\ sufa = sufb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">fa</span> <span class="nv">fb</span> : Formula) (<span class="nv">sufa</span> <span class="nv">sufb</span> : expression),
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb
  ‚Üí flatten_formula fa = flatten_formula fb
    ‚àß sufa = sufb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk37"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">fa</span> <span class="nv">fb</span> : Formula) (<span class="nv">sufa</span> <span class="nv">sufb</span> : expression),
  flatten_formula fa ++ sufa =
  flatten_formula fb ++ sufb
  ‚Üí flatten_formula fa = flatten_formula fb
    ‚àß sufa = sufb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk38"><span class="nb">intros</span> * Hpre.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>fa, fb</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>sufa, sufb</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hpre</var><span class="hyp-type"><b>: </b><span>flatten_formula fa ++ sufa =
flatten_formula fb ++ sufb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(flatten_formula fa = flatten_formula fb ‚àß sufa = sufb)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> flatten_formula_formula_prefix_is_not_formula_prop_app;
    [<span class="nb">apply</span> flatten_formula_prefix.. |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk39">#[export] <span class="kn">Instance</span> <span class="nf">flatten_formula_inj</span> : Inj (=) (=) flatten_formula.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Inj eq eq flatten_formula</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Inj eq eq flatten_formula</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> f; <span class="nb">induction</span> f; <span class="nb">intros</span> []; <span class="nb">cbn</span>; <span class="nb">inversion</span> <span class="mi">1</span> <span class="kr">as</span> [Heq];
    [| | | <span class="bp">by</span> <span class="nb">apply</span> IHf <span class="kr">in</span> Heq <span class="kr">as</span> -&gt;
    | <span class="nb">apply</span> flatten_formula_common_prefix <span class="kr">in</span> Heq <span class="kr">as</span> []; <span class="nb">erewrite</span> IHf1, IHf2..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">binop_state_cast</span>
  (<span class="nv">si</span> : expression) (<span class="nv">j</span> : index) : state (expression_components j) :=
  <span class="kr">match</span> j <span class="kr">with</span>
  | ITop | IBot | IVar | INeg =&gt; ()
  | _ =&gt; Some si
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">BinOp</span> : symbol -&gt; <span class="kt">Prop</span> :=
| bin_op_conj : BinOp Conj
| bin_op_disj : BinOp Disj
| bin_op_impl : BinOp Impl
| bin_op_iff : BinOp Iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk3b"><span class="kn">Lemma</span> <span class="nf">well_formed_flatten_formula_helper</span> :
  <span class="kr">forall</span> (<span class="nv">binop</span> : symbol), BinOp binop -&gt;
  <span class="kr">forall</span> (<span class="nv">f1</span> <span class="nv">f2</span> : Formula),
    well_formed_expression (flatten_formula f1) -&gt;
    well_formed_expression (flatten_formula f2) -&gt;
    well_formed_expression (binop :: flatten_formula f1 ++ flatten_formula f2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">binop</span> : symbol,
  BinOp binop
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> <span class="nv">f2</span> : Formula,
      well_formed_expression (flatten_formula f1)
      ‚Üí well_formed_expression (flatten_formula f2)
        ‚Üí well_formed_expression
            (binop
             :: flatten_formula f1 ++
                flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">binop</span> : symbol,
  BinOp binop
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">f1</span> <span class="nv">f2</span> : Formula,
      well_formed_expression (flatten_formula f1)
      ‚Üí well_formed_expression (flatten_formula f2)
        ‚Üí well_formed_expression
            (binop
             :: flatten_formula f1 ++
                flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk3d"><span class="nb">intros</span> binop Hbinop f1 f2 Hf1 Hf2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (binop :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk3e"><span class="nb">pose</span> (i := symbol_to_index binop).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (binop :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk3f"><span class="nb">pose</span> (s0 := ` (composite_s0 expression_components)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (binop :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk40"><span class="nb">pose</span> (s1 := state_update expression_components s0 i
    (binop_state_cast (flatten_formula f1) i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (binop :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk41"><span class="nb">assert</span> (Ht1 : input_valid_transition expression_vlsm
    (default_composite_label i) (s0, Some (flatten_formula f1)) (s1, None)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (s1, None)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk42"><hr></label><div class="goal-conclusion">well_formed_expression
  (binop :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk43">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (s1, None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk44"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm s0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk45"><hr></label><div class="goal-conclusion">option_valid_message_prop expression_vlsm
  (Some (flatten_formula f1))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk46"><hr></label><div class="goal-conclusion">valid (default_composite_label i)
  (s0, Some (flatten_formula f1))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk47"><hr></label><div class="goal-conclusion">transition (default_composite_label i)
  (s0, Some (flatten_formula f1)) = (
s1, None)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk48">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm s0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> initial_state_is_valid; <span class="nb">destruct</span> composite_s0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk49">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop expression_vlsm
  (Some (flatten_formula f1))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk4a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (default_composite_label i)
  (s0, Some (flatten_formula f1))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hbinop; <span class="nb">subst</span>; <span class="nb">eexists</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transition (default_composite_label i)
  (s0, Some (flatten_formula f1)) = (s1, None)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hbinop; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk4c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (binop :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk4d"><span class="nb">cut</span> (input_valid_transition expression_vlsm
    (default_composite_label i) (s1, Some (flatten_formula f2))
    (s0, Some (binop :: flatten_formula f1 ++ flatten_formula f2)));
    [<span class="bp">by</span> <span class="nb">eapply</span> input_valid_transition_out |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition expression_vlsm
  (default_composite_label i)
  (s1, Some (flatten_formula f2))
  (s0,
   Some
     (binop
      :: flatten_formula f1 ++ flatten_formula f2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk4e"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm s1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk4f"><hr></label><div class="goal-conclusion">option_valid_message_prop expression_vlsm
  (Some (flatten_formula f2))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk50"><hr></label><div class="goal-conclusion">valid (default_composite_label i)
  (s1, Some (flatten_formula f2))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk51"><hr></label><div class="goal-conclusion">transition (default_composite_label i)
  (s1, Some (flatten_formula f2)) =
(s0,
 Some
   (binop :: flatten_formula f1 ++ flatten_formula f2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk52">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> input_valid_transition_destination.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk53">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop expression_vlsm
  (Some (flatten_formula f2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (default_composite_label i)
  (s1, Some (flatten_formula f2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hbinop; <span class="nb">subst</span>; <span class="nb">eexists</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk55">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>s0</var><span><span class="hyp-body"><b>:= </b><span>`(composite_s0 expression_components)</span></span><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span></span><br><span><var>s1</var><span><span class="hyp-body"><b>:= </b><span>state_update expression_components s0 i
  (binop_state_cast (flatten_formula f1) i)</span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">j</span> : index, state (expression_components j)</span></span></span></span><br><span><var>Ht1</var><span class="hyp-type"><b>: </b><span>input_valid_transition expression_vlsm
  (default_composite_label i)
  (s0, Some (flatten_formula f1)) (
  s1, None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transition (default_composite_label i)
  (s1, Some (flatten_formula f2)) =
(s0,
 Some
   (binop :: flatten_formula f1 ++ flatten_formula f2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hbinop; <span class="nb">subst</span> binop i s1; <span class="nb">cbn</span> <span class="kr">in</span> *;
      <span class="nb">rewrite</span> state_update_eq, state_update_twice, state_update_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
The flattening of a <span class="inlinecode"><span class="id" title="var">Formula</span></span> is a <span class="inlinecode"><span class="id" title="var">well_formed_expression</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk56"><span class="kn">Theorem</span> <span class="nf">flatten_formulas_are_well_formed_expressions</span> :
  <span class="kr">forall</span> (<span class="nv">f</span> : Formula),
    well_formed_expression (flatten_formula f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">f</span> : Formula,
  well_formed_expression (flatten_formula f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">f</span> : Formula,
  well_formed_expression (flatten_formula f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk58"><span class="nb">induction</span> f; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression [Top]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk59"><hr></label><div class="goal-conclusion">well_formed_expression [Bot]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk5a"><hr></label><div class="goal-conclusion">well_formed_expression [PVar x]</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk5b"><hr></label><div class="goal-conclusion">well_formed_expression (Neg :: flatten_formula f)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk5c"><hr></label><div class="goal-conclusion">well_formed_expression
  (Conj :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk5d"><hr></label><div class="goal-conclusion">well_formed_expression
  (Disj :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk5e"><hr></label><div class="goal-conclusion">well_formed_expression
  (Impl :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk5f"><hr></label><div class="goal-conclusion">well_formed_expression
  (Iff :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression [Top]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk61"><span class="nb">cut</span> (input_valid_transition expression_vlsm (existT ITop ())
      (` (composite_s0 expression_components), None)
      (` (composite_s0 expression_components), Some ([Top])));
      [<span class="bp">by</span> <span class="nb">eapply</span> input_valid_transition_out |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition expression_vlsm
  (existT ITop ())
  (`(composite_s0 expression_components), None)
  (`(composite_s0 expression_components), Some [Top])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk62"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk63"><hr></label><div class="goal-conclusion">option_valid_message_prop expression_vlsm None</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk64"><hr></label><div class="goal-conclusion">transition (existT ITop ())
  (`(composite_s0 expression_components), None) =
(`(composite_s0 expression_components), Some [Top])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk65">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> initial_state_is_valid; <span class="nb">destruct</span> composite_s0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk66">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop expression_vlsm None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> option_valid_message_None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk67">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transition (existT ITop ())
  (`(composite_s0 expression_components), None) =
(`(composite_s0 expression_components), Some [Top])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">cbn</span>; <span class="nb">rewrite</span> state_update_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk68">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression [Bot]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk69"><span class="nb">cut</span> (input_valid_transition expression_vlsm (existT IBot ())
      (` (composite_s0 expression_components), None)
      (` (composite_s0 expression_components), Some ([Bot])));
      [<span class="bp">by</span> <span class="nb">eapply</span> input_valid_transition_out |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition expression_vlsm
  (existT IBot ())
  (`(composite_s0 expression_components), None)
  (`(composite_s0 expression_components), Some [Bot])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk6a"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk6b"><hr></label><div class="goal-conclusion">option_valid_message_prop expression_vlsm None</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk6c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk6c"><hr></label><div class="goal-conclusion">transition (existT IBot ())
  (`(composite_s0 expression_components), None) =
(`(composite_s0 expression_components), Some [Bot])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk6d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> initial_state_is_valid; <span class="nb">destruct</span> composite_s0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk6e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop expression_vlsm None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> option_valid_message_None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk6f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transition (existT IBot ())
  (`(composite_s0 expression_components), None) =
(`(composite_s0 expression_components), Some [Bot])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">cbn</span>; <span class="nb">rewrite</span> state_update_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk70">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression [PVar x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk71"><span class="nb">cut</span> (input_valid_transition expression_vlsm (existT IVar x)
      (` (composite_s0 expression_components), None)
      (` (composite_s0 expression_components), Some ([PVar x])));
      [<span class="bp">by</span> <span class="nb">eapply</span> input_valid_transition_out |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition expression_vlsm (existT IVar x)
  (`(composite_s0 expression_components), None)
  (`(composite_s0 expression_components),
   Some [PVar x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk72"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk73"><hr></label><div class="goal-conclusion">option_valid_message_prop expression_vlsm None</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk74"><hr></label><div class="goal-conclusion">transition (existT IVar x)
  (`(composite_s0 expression_components), None) =
(`(composite_s0 expression_components), Some [PVar x])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk75">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> initial_state_is_valid; <span class="nb">destruct</span> composite_s0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk76">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop expression_vlsm None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> option_valid_message_None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk77">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transition (existT IVar x)
  (`(composite_s0 expression_components), None) =
(`(composite_s0 expression_components), Some [PVar x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">cbn</span>; <span class="nb">rewrite</span> state_update_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk78">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression (Neg :: flatten_formula f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk79"><span class="nb">cut</span> (input_valid_transition expression_vlsm (existT INeg ())
      (` (composite_s0 expression_components), Some (flatten_formula f))
      (` (composite_s0 expression_components), Some (Neg :: flatten_formula f)));
      [<span class="bp">by</span> <span class="nb">eapply</span> input_valid_transition_out |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition expression_vlsm
  (existT INeg ())
  (`(composite_s0 expression_components),
   Some (flatten_formula f))
  (`(composite_s0 expression_components),
   Some (Neg :: flatten_formula f))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk7a"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk7b"><hr></label><div class="goal-conclusion">option_valid_message_prop expression_vlsm
  (Some (flatten_formula f))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk7c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk7c"><hr></label><div class="goal-conclusion">valid (existT INeg ())
  (`(composite_s0 expression_components),
   Some (flatten_formula f))</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk7d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk7d"><hr></label><div class="goal-conclusion">transition (existT INeg ())
  (`(composite_s0 expression_components),
   Some (flatten_formula f)) =
(`(composite_s0 expression_components),
 Some (Neg :: flatten_formula f))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk7e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop expression_vlsm
  (`(composite_s0 expression_components))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> initial_state_is_valid; <span class="nb">destruct</span> composite_s0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk7f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop expression_vlsm
  (Some (flatten_formula f))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk80">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (existT INeg ())
  (`(composite_s0 expression_components),
   Some (flatten_formula f))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eexists</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk81">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transition (existT INeg ())
  (`(composite_s0 expression_components),
   Some (flatten_formula f)) =
(`(composite_s0 expression_components),
 Some (Neg :: flatten_formula f))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">cbn</span>; <span class="nb">rewrite</span> state_update_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk82">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (Conj :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> well_formed_flatten_formula_helper; [<span class="nb">constructor</span> | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk83">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (Disj :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> well_formed_flatten_formula_helper; [<span class="nb">constructor</span> | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk84">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (Impl :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> well_formed_flatten_formula_helper; [<span class="nb">constructor</span> | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk85">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>IHf1</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f1)</span></span></span><br><span><var>IHf2</var><span class="hyp-type"><b>: </b><span>well_formed_expression (flatten_formula f2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression
  (Iff :: flatten_formula f1 ++ flatten_formula f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> well_formed_flatten_formula_helper; [<span class="nb">constructor</span> | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">binop_state_proj</span>
  (<span class="nv">s</span> : composite_state expression_components) (<span class="nv">i</span> : index) : option expression :=
  <span class="kr">match</span> i <span class="kr">with</span>
  | ITop | IBot | IVar | INeg =&gt; None
  | i =&gt; s i
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk86"><span class="kn">Lemma</span> <span class="nf">well_formed_is_flatten_formula_helper</span>
  (<span class="nv">binop</span> : symbol)
  (<span class="nv">Hbinop</span> : BinOp binop)
  (<span class="nv">i</span> := symbol_to_index binop)
  (<span class="nv">e</span> : expression)
  (<span class="nv">Hind</span> : <span class="kr">forall</span> (<span class="nv">y</span> : nat),
    y &lt; length e -&gt;
    <span class="kr">forall</span> (<span class="nv">e</span> : expression), y = length e -&gt; well_formed_expression e -&gt;
    <span class="kr">exists</span> (<span class="nv">f</span> : Formula), flatten_formula f = e)
  (<span class="nv">s0</span> : composite_state expression_components)
  (<span class="nv">si&#39;</span> : option expression)
  (<span class="nv">om</span> : option expression)
  (<span class="nv">Hom</span> : option_valid_message_prop expression_vlsm om)
  (<span class="nv">Hti</span> : transition (VLSMMachine := expression_binop_vlsm_machine binop) ()
    (binop_state_proj s0 i, om) = (si&#39;, Some e))
  (<span class="nv">Hs0</span> : valid_state_prop expression_vlsm s0) :
    <span class="kr">exists</span> <span class="nv">f</span> : Formula, flatten_formula f = e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si', om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm om</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition () (binop_state_proj s0 i, om) =
(si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si', om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm om</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition () (binop_state_proj s0 i, om) =
(si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk88"><span class="nb">destruct</span> (binop_state_proj s0 i) <span class="kr">as</span> [e1 |] <span class="nb">eqn</span>: Hs0i;
    [| <span class="bp">by</span> <span class="nb">destruct</span> om; <span class="nb">inversion</span> Hti].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si', om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm om</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition () (Some e1, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk89"><span class="nb">destruct</span> om <span class="kr">as</span> [m |]; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm
  (Some m)</span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition () (Some e1, Some m) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk8a"><span class="nb">inversion</span> Hti; <span class="nb">subst</span>; <span class="nb">clear</span> Hti.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length (binop :: e1 ++ m)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm
  (Some m)</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = binop :: e1 ++ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk8b"><span class="nb">apply</span> (free_valid_state_component_initial_or_transition i) <span class="kr">in</span> Hs0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length (binop :: e1 ++ m)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm
  (Some m)</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>(initial_state_prop (s0 i)
 ‚à® (<span class="kr">‚àÉ</span> (<span class="nv">l</span> : label (expression_components i)) 
      (<span class="nv">si0</span> : state (expression_components i)) 
      (<span class="nv">om</span> <span class="nv">om&#39;</span> : option expression),
      input_valid_transition
        (free_composite_vlsm
           expression_components) 
        (existT i l)
        (state_update expression_components s0 i
           si0, om) (
        s0, om&#39;)))%type</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = binop :: e1 ++ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk8c"><span class="nb">destruct</span> Hs0 <span class="kr">as</span> [Hs0 | (l &amp; si &amp; iom &amp; oom &amp; (_ &amp; Hiom &amp; Hvs0) &amp; Ht)];
    [<span class="bp">by</span> <span class="nb">inversion</span> Hbinop; <span class="nb">subst</span>; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="bp">congruence</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length (binop :: e1 ++ m)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm
  (Some m)</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid (existT i l)
  (state_update expression_components s0 i si,
   iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition (existT i l)
  (state_update expression_components s0 i si,
   iom) = (s0, oom)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = binop :: e1 ++ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk8d"><span class="nb">cbn</span> <span class="kr">in</span> *; state_update_simpl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ m))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop expression_vlsm
  (Some m)</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = binop :: e1 ++ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk8e"><span class="nb">eapply</span> Hind <span class="kr">in</span> Hom <span class="kr">as</span> [f2 Hf2]; <span class="nb">cycle</span> <span class="mi">2</span>;
    [<span class="bp">done</span> | | <span class="bp">by</span> <span class="nb">rewrite</span> app_length; <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ m))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>flatten_formula f2 = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = binop :: e1 ++ m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk8f"><span class="nb">cut</span> (<span class="kr">exists</span> <span class="nv">f1</span> : Formula, flatten_formula f1 = e1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ m))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>flatten_formula f2 = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">‚àÉ</span> <span class="nv">f1</span> : Formula, flatten_formula f1 = e1)
 ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = binop :: e1 ++ m)%type</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ m))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>flatten_formula f2 = m</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk90"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f1</span> : Formula, flatten_formula f1 = e1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk91">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ m))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>flatten_formula f2 = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">‚àÉ</span> <span class="nv">f1</span> : Formula, flatten_formula f1 = e1)
 ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = binop :: e1 ++ m)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk92"><span class="nb">subst</span> m; <span class="nb">intros</span> [f1 &lt;-]; <span class="nb">inversion</span> Hbinop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Conj = binop</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Conj :: flatten_formula f1 ++ flatten_formula f2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Disj = binop</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk93"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Disj :: flatten_formula f1 ++ flatten_formula f2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Impl = binop</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk94"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Impl :: flatten_formula f1 ++ flatten_formula f2</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chk95" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Iff = binop</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chk95"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Iff :: flatten_formula f1 ++ flatten_formula f2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk96">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Conj = binop</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Conj :: flatten_formula f1 ++ flatten_formula f2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f1</span> ‚àß f2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk97">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Disj = binop</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Disj :: flatten_formula f1 ++ flatten_formula f2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f1</span> ‚à® f2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk98">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Impl = binop</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Impl :: flatten_formula f1 ++ flatten_formula f2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f1</span> ‚Üí f2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk99">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>f2, f1</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt;
  S
    (length
       (flatten_formula f1 ++
        flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i =
Some (flatten_formula f1)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Iff = binop</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula,
  flatten_formula f =
  Iff :: flatten_formula f1 ++ flatten_formula f2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">f1</span> ‚Üî f2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk9a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ m))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>flatten_formula f2 = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f1</span> : Formula, flatten_formula f1 = e1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk9b"><span class="nb">eapply</span> Hind; <span class="nb">cycle</span> <span class="mi">1</span>; [<span class="bp">done</span> | | <span class="bp">by</span> <span class="nb">rewrite</span> app_length; <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>m, e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ m))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition l (si, iom) <span class="kr">in</span>
 (state_update expression_components
    (state_update expression_components s0 i si)
    i si&#39;, om&#39;)) = (s0, oom)</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hf2</var><span class="hyp-type"><b>: </b><span>flatten_formula f2 = m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression e1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk9c"><span class="nb">destruct</span> (transition l (si, iom)) <span class="nb">eqn</span>: Hti; <span class="nb">inversion</span> Ht <span class="kr">as</span> [Heq]; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj s0 i = Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>si</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(state_update expression_components
   (state_update expression_components s0 i si) i
   s, oom) = (s0, oom)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition l (si, iom) = (s, oom)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>state_update expression_components
  (state_update expression_components s0 i si) i
  s = s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression e1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk9d"><span class="nb">rewrite</span> &lt;- Heq, state_update_twice <span class="kr">in</span> Hs0i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>binop</var><span class="hyp-type"><b>: </b><span>symbol</span></span></span><br><span><var>Hbinop</var><span class="hyp-type"><b>: </b><span>BinOp binop</span></span></span><br><span><var>i</var><span><span class="hyp-body"><b>:= </b><span>symbol_to_index binop</span></span><span class="hyp-type"><b>: </b><span>index</span></span></span></span><br><span><var>e1</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>Formula</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; S (length (e1 ++ flatten_formula f2))
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>Hs0i</var><span class="hyp-type"><b>: </b><span>binop_state_proj
  (state_update expression_components s0 i s) i =
Some e1</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hiom</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop
  (free_composite_vlsm expression_components)
  iom</span></span></span><br><span><var>Hvs0</var><span class="hyp-type"><b>: </b><span>valid l (si, iom)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(state_update expression_components
   (state_update expression_components s0 i si) i
   s, oom) = (s0, oom)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition l (si, iom) = (s, oom)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>state_update expression_components
  (state_update expression_components s0 i si) i
  s = s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_formed_expression e1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hbinop; <span class="nb">subst</span> binop i; <span class="nb">destruct</span> Hvs0 <span class="kr">as</span> [im Him]; <span class="nb">cbn</span> <span class="kr">in</span> *;
    state_update_simpl; <span class="nb">subst</span>; (<span class="nb">destruct</span> si; [<span class="bp">done</span> |]);
    <span class="nb">inversion</span> Hti; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Any <span class="inlinecode"><span class="id" title="var">well_formed_expression</span></span> is the flattening of a <span class="inlinecode"><span class="id" title="var">Formula</span></span>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk9e"><span class="kn">Theorem</span> <span class="nf">well_formed_expression_are_flatten_formulas</span> :
  <span class="kr">forall</span> (<span class="nv">e</span> : expression), well_formed_expression e -&gt;
    <span class="kr">exists</span> (<span class="nv">f</span> : Formula), flatten_formula f = e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
  well_formed_expression e
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chk9f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
  well_formed_expression e
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka0"><span class="nb">intros</span> e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed_expression e
 ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka1"><span class="nb">remember</span> (length e) <span class="kr">as</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Heqn</var><span class="hyp-type"><b>: </b><span>n = length e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed_expression e
 ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)%type</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka2"><span class="nb">revert</span> e Heqn; <span class="nb">induction</span> n <span class="kr">as</span> [n Hind] <span class="nb">using</span> (well_founded_ind lt_wf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; n
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
  n = length e
  ‚Üí well_formed_expression e
    ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka3"><span class="nb">intros</span> e -&gt; [s He].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state expression_vlsm</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s
  (Some e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka4"><span class="nb">inversion</span> He; <span class="nb">subst</span>; [<span class="bp">by</span> <span class="nb">destruct</span> Hom <span class="kr">as</span> ([] &amp; [im Him] &amp; Hom) |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state expression_vlsm</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s
  (Some e)</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state expression_vlsm</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>state expression_vlsm</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label expression_vlsm</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid l (s0, om)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition l (s0, om) = (s, Some e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka5"><span class="nb">destruct</span> l <span class="kr">as</span> [i li]; <span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s
  (Some e)</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 i, om)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition li (s0 i, om) <span class="kr">in</span>
 (state_update expression_components s0 i si&#39;,
  om&#39;)) = (s, Some e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka6"><span class="nb">assert</span> (Hs0 : valid_state_prop expression_vlsm s0) <span class="bp">by</span> (<span class="nb">eexists</span>; <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s
  (Some e)</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 i, om)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(<span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := transition li (s0 i, om) <span class="kr">in</span>
 (state_update expression_components s0 i si&#39;,
  om&#39;)) = (s, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka7"><span class="nb">destruct</span> (transition li (s0 i, om)) <span class="kr">as</span> [si&#39; om&#39;] <span class="nb">eqn</span>: Hti.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s
  (Some e)</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 i, om)</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>om'</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 i, om) = (si&#39;, om&#39;)</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>(state_update expression_components s0 i si&#39;, om&#39;) =
(s, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka8"><span class="nb">inversion</span> Ht; <span class="nb">subst</span>; <span class="nb">clear</span> Ht.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components i)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 i si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components i)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 i, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 i, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chka9"><span class="nb">destruct</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components ITop)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 ITop si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components ITop)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 ITop, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 ITop, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkaa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IBot)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IBot si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IBot)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IBot, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IBot, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkaa"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IVar)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IVar si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IVar)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IVar, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IVar, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkab"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components INeg)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 INeg si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components INeg)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 INeg, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 INeg, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkac"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IConj)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IConj
     si&#39;) (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IConj)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IConj, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IConj, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkad"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IDisj)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IDisj
     si&#39;) (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IDisj)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IDisj, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IDisj, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkae"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IImpl)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IImpl
     si&#39;) (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IImpl)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IImpl, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IImpl, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkaf"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IIff)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IIff si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IIff)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IIff, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IIff, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkb0"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components ITop)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 ITop si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components ITop)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 ITop, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 ITop, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hti; <span class="kr">exists</span> ‚ä§.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IBot)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IBot si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IBot)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IBot, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IBot, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hti; <span class="kr">exists</span> ‚ä•.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IVar)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IVar si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IVar)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IVar, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IVar, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hti; <span class="kr">exists</span> <span class="nv">li</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components INeg)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 INeg si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components INeg)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 INeg, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 INeg, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb5"><span class="nb">destruct</span> om <span class="kr">as</span> [m |]; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components INeg)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 INeg si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components INeg)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s
  (Some m)</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 INeg, Some m)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 INeg, Some m) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb6"><span class="nb">inversion</span> Hti; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length (Neg :: m)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 INeg ())
  (Some (Neg :: m))</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components INeg)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s
  (Some m)</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 INeg, Some m)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 INeg, Some m) =
((), Some (Neg :: m))</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = Neg :: m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb7"><span class="nb">assert</span> (Hm : well_formed_expression m) <span class="bp">by</span> (<span class="nb">eexists</span>; <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length (Neg :: m)
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 INeg ())
  (Some (Neg :: m))</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components INeg)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s
  (Some m)</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 INeg, Some m)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 INeg, Some m) =
((), Some (Neg :: m))</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>well_formed_expression m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = Neg :: m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> (Hind (length m)) <span class="kr">in</span> Hm <span class="kr">as</span> [fm &lt;-]; [<span class="kr">exists</span> (<span class="nv">FNeg</span> <span class="nv">fm</span>) | <span class="nb">cbn</span>; <span class="bp">lia</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IConj)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IConj
     si&#39;) (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IConj)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IConj, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IConj, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> well_formed_is_flatten_formula_helper;
      [<span class="nb">constructor</span> | | <span class="kr">exists</span> <span class="nv">_s</span> | <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">apply</span> Hti | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkb9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IDisj)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IDisj
     si&#39;) (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IDisj)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IDisj, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IDisj, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> well_formed_is_flatten_formula_helper;
      [<span class="nb">constructor</span> | | <span class="kr">exists</span> <span class="nv">_s</span> | <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">apply</span> Hti | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IImpl)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IImpl
     si&#39;) (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IImpl)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IImpl, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IImpl, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> well_formed_is_flatten_formula_helper;
      [<span class="nb">constructor</span> | | <span class="kr">exists</span> <span class="nv">_s</span> | <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">apply</span> Hti | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkbb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">y</span> : nat,
  y &lt; length e
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
      y = length e
      ‚Üí well_formed_expression e
        ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>si'</var><span class="hyp-type"><b>: </b><span>state (expression_components IIff)</span></span></span><br><span><var>He</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm
  (state_update expression_components s0 IIff si&#39;)
  (Some e)</span></span></span><br><span><var>_om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>composite_state expression_components</span></span></span><br><span><var>om</var><span class="hyp-type"><b>: </b><span>option expression</span></span></span><br><span><var>li</var><span class="hyp-type"><b>: </b><span>label (expression_components IIff)</span></span></span><br><span><var>Hps</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm s0 _om</span></span></span><br><span><var>Hpm</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop expression_vlsm _s om</span></span></span><br><span><var>Hv</var><span class="hyp-type"><b>: </b><span>valid li (s0 IIff, om)</span></span></span><br><span><var>Hti</var><span class="hyp-type"><b>: </b><span>transition li (s0 IIff, om) = (si&#39;, Some e)</span></span></span><br><span><var>Hs0</var><span class="hyp-type"><b>: </b><span>valid_state_prop expression_vlsm s0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> well_formed_is_flatten_formula_helper;
      [<span class="nb">constructor</span> | | <span class="kr">exists</span> <span class="nv">_s</span> | <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">apply</span> Hti | ..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">well_formed_expression</span></span>s, that is, valid messages of the <span class="inlinecode"><span class="id" title="var">expression_vlsm</span></span>
  coincide with flatten <span class="inlinecode"><span class="id" title="var">Formula</span></span>s.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkbc"><span class="kn">Corollary</span> <span class="nf">well_formed_expression_flatten_formula_equiv</span> :
  <span class="kr">forall</span> (<span class="nv">e</span> : expression), well_formed_expression e &lt;-&gt;
  <span class="kr">exists</span> (<span class="nv">f</span> : Formula), flatten_formula f = e.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
  well_formed_expression e
  ‚Üî (<span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkbd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">e</span> : expression,
  well_formed_expression e
  ‚Üî (<span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkbe"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed_expression e
 ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)%type</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Formulas-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br></div><label class="goal-separator" for="Formulas-v-chkbf"><hr></label><div class="goal-conclusion">((<span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)
 ‚Üí well_formed_expression e)%type</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkc0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(well_formed_expression e
 ‚Üí <span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> well_formed_expression_are_flatten_formulas.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Formulas-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="Formulas-v-chkc1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Var</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision Var</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>base.Infinite Var</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>expression</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="kr">‚àÉ</span> <span class="nv">f</span> : Formula, flatten_formula f = e)
 ‚Üí well_formed_expression e)%type</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [f &lt;-]; <span class="nb">apply</span> flatten_formulas_are_well_formed_expressions.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_valid_message_char</span>.</span></span></pre><div class="doc">
<a id="lab9"></a><h2 class="section">Interpretation of formulas</h2>
<div class="paragraph"> </div>

  We define a function to interpret formulas as Coq terms in the <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> sort,
  given that all atoms are mapped to <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> terms.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_formula_interpretation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  (<span class="nv">formula_var_interp</span> : Var -&gt; <span class="kt">Prop</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">formula_vars</span> (<span class="nv">f</span> : Formula) : listset Var :=
  <span class="kr">match</span> f <span class="kr">with</span>
  | ‚ä§ | ‚ä• =&gt; ‚àÖ
  | FVar x =&gt; {[x]}
  | ¬¨ f =&gt; formula_vars f
  | f1 ‚àß f2 | f1 ‚à® f2 | f1 ‚Üí f2 | f1 ‚Üî f2 =&gt; formula_vars f1 ‚à™ formula_vars f2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">formula_interp</span> (<span class="nv">f</span> : Formula) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> f <span class="kr">with</span>
  | ‚ä§ =&gt; <span class="kt">True</span>
  | ‚ä• =&gt; <span class="kt">False</span>
  | FVar x =&gt; formula_var_interp x
  | ¬¨ f =&gt; ~ formula_interp f
  | f1 ‚àß f2 =&gt; formula_interp f1 /\ formula_interp f2
  | f1 ‚à® f2 =&gt; formula_interp f1 \/ formula_interp f2
  | f1 ‚Üí f2 =&gt; formula_interp f1 -&gt; formula_interp f2
  | f1 ‚Üî f2 =&gt; formula_interp f1 &lt;-&gt; formula_interp f2
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_formula_interpretation</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">formula_holds_prop</span> (<span class="nv">f</span> : Formula) : <span class="kt">Prop</span> :=
  <span class="kr">forall</span> (<span class="nv">i</span> : Var -&gt; <span class="kt">Prop</span>), formula_interp i f.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_formula</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Formula : <span class="kn">clear implicits</span>.</span></span></pre><div class="doc">
  The formula notations we introduced above were local to this module.
  To allow these notations to be used elsewhere, while also allowing them to
  be enabled and disabled by need, we declare them as part of a scope.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Declare Scope</span> formula_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Bind Scope</span> formula_scope <span class="kr">with</span> Formula.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;‚ä§&quot;</span> := FTop : formula_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;‚ä•&quot;</span> := FBot : formula_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ‚à® y&quot;</span> := (FDisj x y) (<span class="kn">at level</span> <span class="mi">85</span>, <span class="kn">right associativity</span>) : formula_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ‚àß y&quot;</span> := (FConj x y) (<span class="kn">at level</span> <span class="mi">80</span>, <span class="kn">right associativity</span>) : formula_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ‚Üí y&quot;</span> := (FImpl x y) (<span class="kn">at level</span> <span class="mi">99</span>, y <span class="kn">at level</span> <span class="mi">200</span>, <span class="kn">right associativity</span>) : formula_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;x ‚Üî y&quot;</span> := (FIff x y) (<span class="kn">at level</span> <span class="mi">95</span>, <span class="kn">no associativity</span>): formula_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;¬¨ x&quot;</span> := (FNeg x) (<span class="kn">at level</span> <span class="mi">75</span>, <span class="kn">right associativity</span>) : formula_scope.</span></span></pre></article></body></html>