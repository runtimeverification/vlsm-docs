<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Plans.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.18.0+0.18.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk0"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> Itauto.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file coq-itauto.plugin ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> prelude.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> VLSM.Core <span class="kn">Require Import</span> VLSM.</span></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Core: VLSM Plans</h1>
<div class="paragraph"> </div>

  A plan is a (sequence of actions) which can be attempted on a
  given state to yield a trace.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_plans</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  {<span class="nv">message</span> : <span class="kt">Type</span>}
  {<span class="nv">T</span> : VLSMType message}.</span></span></pre><div class="doc">
  A <span class="inlinecode"><span class="id" title="var">plan_item</span></span> is a singleton plan, and contains a label and an input
  which would allow to transition from any given state
  (note that we don't address validity for now).

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">plan_item</span> : <span class="kt">Type</span> :=
{
  label_a : label T;
  input_a : option message;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_plans</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> plan_item {message T}, {message} T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Build_plan_item {message T}, {message} T.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_apply_plans</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  {<span class="nv">message</span> : <span class="kt">Type</span>}
  {<span class="nv">T</span> : VLSMType message}
  {<span class="nv">transition</span> : label T -&gt; state T * option message -&gt; state T * option message}
  .</span></span></pre><div class="doc">
  If we don't concern ourselves with the validity of the traces obtained
  upon applying a plan, then a <span class="inlinecode"><span class="id" title="var">VLSMType</span></span> and a <span class="inlinecode"><span class="id" title="var">transition</span></span> function
  suffice for defining plan application and related results.
  The advantage of this approach is that the same definition works for
  preloaded versions as well as for all constrained variants of a composition.

<div class="paragraph"> </div>

  Applying a plan (list of <span class="inlinecode"><span class="id" title="var">plan_item</span></span>s) to a state we obtain a
  final state and a trace. We define that in the <span class="inlinecode"><span class="id" title="var">_apply_plan</span></span> definition below
  using a folding operation on the <span class="inlinecode"><span class="id" title="var">_apply_plan_folder</span></span> function.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">_apply_plan_folder</span>
  (<span class="nv">a</span> : plan_item)
  (<span class="nv">sl</span> : state T * list transition_item)
  : state T * list transition_item
  :=
  <span class="kr">let</span> (<span class="nv">s</span>, items) := sl <span class="kr">in</span>
  <span class="kr">match</span> a <span class="kr">with</span> {| label_a := l&#39;; input_a := input&#39; |} =&gt;
    <span class="kr">let</span> (<span class="nv">dest</span>, out) := (transition l&#39; (s, input&#39;)) <span class="kr">in</span>
    (dest
    , {| l := l&#39;;
         input := input&#39;;
         output := out;
         destination := dest
       |} :: items)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk1"><span class="kn">Lemma</span> <span class="nf">_apply_plan_folder_additive</span>
  (<span class="nv">start</span> : state T)
  (<span class="nv">aitems</span> : list plan_item)
  (<span class="nv">seed_items</span> : list transition_item)
  : <span class="kr">let</span> (<span class="nv">final</span>, items) := fold_right _apply_plan_folder (start, []) aitems <span class="kr">in</span>
    fold_right _apply_plan_folder (start, seed_items) aitems = (final, items ++ seed_items).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>seed_items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> (<span class="nv">final</span>, items) :=
  foldr _apply_plan_folder (start, []) aitems <span class="kr">in</span>
foldr _apply_plan_folder (start, seed_items) aitems =
(final, items ++ seed_items)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>seed_items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> (<span class="nv">final</span>, items) :=
  foldr _apply_plan_folder (start, []) aitems <span class="kr">in</span>
foldr _apply_plan_folder (start, seed_items) aitems =
(final, items ++ seed_items)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk3"><span class="nb">generalize dependent</span> seed_items.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">seed_items</span> : list transition_item,
  <span class="kr">let</span> (<span class="nv">final</span>, items) :=
    foldr _apply_plan_folder (start, []) aitems <span class="kr">in</span>
  foldr _apply_plan_folder (start, seed_items) aitems =
  (final, items ++ seed_items)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk4"><span class="nb">induction</span> aitems; <span class="nb">simpl</span>; <span class="nb">intros</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHaitems</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">seed_items</span> : list transition_item,
  <span class="kr">let</span> (<span class="nv">final</span>, items) :=
    foldr _apply_plan_folder (
      start, []) aitems <span class="kr">in</span>
  foldr _apply_plan_folder
    (start, seed_items) aitems =
  (final, items ++ seed_items)</span></span></span><br><span><var>seed_items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> (<span class="nv">final</span>, items) :=
  _apply_plan_folder a
    (foldr _apply_plan_folder (start, []) aitems) <span class="kr">in</span>
_apply_plan_folder a
  (foldr _apply_plan_folder (start, seed_items) aitems) =
(final, items ++ seed_items)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk5"><span class="nb">destruct</span> (fold_right _apply_plan_folder (start, []) aitems) <span class="kr">as</span> (afinal, aitemsX).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitemsX</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>IHaitems</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">seed_items</span> : list transition_item,
  foldr _apply_plan_folder
    (start, seed_items) aitems =
  (afinal, aitemsX ++ seed_items)</span></span></span><br><span><var>seed_items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> (<span class="nv">final</span>, items) :=
  _apply_plan_folder a (afinal, aitemsX) <span class="kr">in</span>
_apply_plan_folder a
  (foldr _apply_plan_folder (start, seed_items) aitems) =
(final, items ++ seed_items)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk6"><span class="nb">rewrite</span> IHaitems; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitemsX</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>IHaitems</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">seed_items</span> : list transition_item,
  foldr _apply_plan_folder
    (start, seed_items) aitems =
  (afinal, aitemsX ++ seed_items)</span></span></span><br><span><var>seed_items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> (<span class="nv">final</span>, items) :=
  <span class="kr">match</span> a <span class="kr">with</span>
  | {| label_a := l&#39;; input_a := input&#39; |} =&gt;
      <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
        transition l&#39; (afinal, input&#39;) <span class="kr">in</span>
      (dest,
       {|
         l := l&#39;;
         input := input&#39;;
         destination := dest;
         output := out
       |} :: aitemsX)
  <span class="kr">end</span> <span class="kr">in</span>
<span class="kr">match</span> a <span class="kr">with</span>
| {| label_a := l&#39;; input_a := input&#39; |} =&gt;
    <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
      transition l&#39; (afinal, input&#39;) <span class="kr">in</span>
    (dest,
     {|
       l := l&#39;;
       input := input&#39;;
       destination := dest;
       output := out
     |} :: aitemsX ++ seed_items)
<span class="kr">end</span> = (final, items ++ seed_items)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> a, (transition label_a0 (afinal, input_a0)) <span class="kr">as</span> [dest out].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">_apply_plan</span>
  (<span class="nv">start</span> : state T)
  (<span class="nv">a</span> : list plan_item)
  : list transition_item * state T
  :=
  <span class="kr">let</span> (<span class="nv">final</span>, items) :=
    fold_right _apply_plan_folder (@pair (state T) _ start []) (rev a) <span class="kr">in</span>
  (rev items, final).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk7"><span class="kn">Lemma</span> <span class="nf">_apply_plan_last</span>
  (<span class="nv">start</span> : state T)
  (<span class="nv">a</span> : list plan_item)
  (<span class="nv">after_a</span> := _apply_plan start a)
  : finite_trace_last start (fst after_a) = snd after_a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>after_a</var><span><span class="hyp-body"><b>:= </b><span>_apply_plan start a</span></span><span class="hyp-type"><b>: </b><span>(list transition_item * state T)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>after_a</var><span><span class="hyp-body"><b>:= </b><span>_apply_plan start a</span></span><span class="hyp-type"><b>: </b><span>(list transition_item * state T)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk9"><span class="nb">induction</span> a <span class="nb">using</span> rev_ind; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>after_a</var><span><span class="hyp-body"><b>:= </b><span>_apply_plan start (a ++ [x])</span></span><span class="hyp-type"><b>: </b><span>(list transition_item * state T)%type</span></span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := _apply_plan start a <span class="kr">in</span>
finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka"><span class="nb">unfold</span> after_a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>after_a</var><span><span class="hyp-body"><b>:= </b><span>_apply_plan start (a ++ [x])</span></span><span class="hyp-type"><b>: </b><span>(list transition_item * state T)%type</span></span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := _apply_plan start a <span class="kr">in</span>
finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (_apply_plan start (a ++ [x])).<span class="mi">1</span> =
(_apply_plan start (a ++ [x])).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb"><span class="nb">clear</span> after_a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := _apply_plan start a <span class="kr">in</span>
finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (_apply_plan start (a ++ [x])).<span class="mi">1</span> =
(_apply_plan start (a ++ [x])).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc"><span class="nb">unfold</span> _apply_plan.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := _apply_plan start a <span class="kr">in</span>
finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (start, [])
       (rev (a ++ [x])) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (start, [])
     (rev (a ++ [x])) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkd"><span class="nb">rewrite</span> rev_unit.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := _apply_plan start a <span class="kr">in</span>
finite_trace_last start after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (start, []) (x :: rev a) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (start, []) (x :: rev a) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chke"><span class="nb">unfold</span> _apply_plan <span class="kr">in</span> IHa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (
       start, []) (rev a) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (start, []) (rev a) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (start, []) (x :: rev a) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (start, []) (x :: rev a) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkf"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (
       start, []) (rev a) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (start, []) (rev a) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     _apply_plan_folder x
       (foldr _apply_plan_folder (start, []) (rev a)) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   _apply_plan_folder x
     (foldr _apply_plan_folder (start, []) (rev a)) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk10"><span class="nb">destruct</span> (fold_right _apply_plan_folder (start, []) (rev a)) <span class="kr">as</span> (final, items)
    <span class="nb">eqn</span>: Happly.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Happly</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (start, []) (rev a) =
(final, items)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_trace_last start (rev items, final).<span class="mi">1</span> =
(rev items, final).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     _apply_plan_folder x (final, items) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   _apply_plan_folder x (final, items) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk11"><span class="nb">simpl</span> <span class="kr">in</span> IHa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Happly</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (start, []) (rev a) =
(final, items)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_trace_last start (rev items) = final</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     _apply_plan_folder x (final, items) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   _apply_plan_folder x (final, items) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk12"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Happly</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (start, []) (rev a) =
(final, items)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_trace_last start (rev items) = final</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">match</span> x <span class="kr">with</span>
     | {| label_a := l&#39;; input_a := input&#39; |} =&gt;
         <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
           transition l&#39; (final, input&#39;) <span class="kr">in</span>
         (dest,
          {|
            l := l&#39;;
            input := input&#39;;
            destination := dest;
            output := out
          |} :: items)
     <span class="kr">end</span> <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   <span class="kr">match</span> x <span class="kr">with</span>
   | {| label_a := l&#39;; input_a := input&#39; |} =&gt;
       <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
         transition l&#39; (final, input&#39;) <span class="kr">in</span>
       (dest,
        {|
          l := l&#39;;
          input := input&#39;;
          destination := dest;
          output := out
        |} :: items)
   <span class="kr">end</span> <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk13"><span class="nb">destruct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label T</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Happly</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (start, []) (rev a) =
(final, items)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_trace_last start (rev items) = final</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (final, input_a0) <span class="kr">in</span>
     (dest,
      {|
        l := label_a0;
        input := input_a0;
        destination := dest;
        output := out
      |} :: items) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span> =
(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
     transition label_a0 (final, input_a0) <span class="kr">in</span>
   (dest,
    {|
      l := label_a0;
      input := input_a0;
      destination := dest;
      output := out
    |} :: items) <span class="kr">in</span>
 (rev items, final)).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk14"><span class="nb">destruct</span> (transition label_a0 (final, input_a0)) <span class="kr">as</span> (dest, out) <span class="nb">eqn</span>: Ht.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label T</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Happly</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (start, []) (rev a) =
(final, items)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_trace_last start (rev items) = final</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (final, input_a0) =
(dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_trace_last start
  (rev
     ({|
        l := label_a0;
        input := input_a0;
        destination := dest;
        output := out
      |} :: items), dest).<span class="mi">1</span> =
(rev
   ({|
      l := label_a0;
      input := input_a0;
      destination := dest;
      output := out
    |} :: items), dest).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">simpl</span>; <span class="nb">rewrite</span> finite_trace_last_is_last.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk15"><span class="kn">Lemma</span> <span class="nf">_apply_plan_app</span>
  (<span class="nv">start</span> : state T)
  (<span class="nv">a</span> <span class="nv">a&#39;</span> : list plan_item)
  : _apply_plan start (a ++ a&#39;) =
    <span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start a <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
     (aitems ++ a&#39;items, a&#39;final).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">_apply_plan start (a ++ a&#39;) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start a <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk16"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">_apply_plan start (a ++ a&#39;) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start a <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk17"><span class="nb">unfold</span> _apply_plan.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (start, [])
     (rev (a ++ a&#39;)) <span class="kr">in</span>
 (rev items, final)) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (start, []) (rev a) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (afinal, []) (rev a&#39;) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk18"><span class="nb">rewrite</span> rev_app_distr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (start, [])
     (rev a&#39; ++ rev a) <span class="kr">in</span>
 (rev items, final)) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (start, []) (rev a) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (afinal, []) (rev a&#39;) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk19"><span class="nb">rewrite</span> fold_right_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder
     (foldr _apply_plan_folder (start, []) (rev a))
     (rev a&#39;) <span class="kr">in</span>
 (rev items, final)) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (start, []) (rev a) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (afinal, []) (rev a&#39;) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk1a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder
     (foldr _apply_plan_folder (start, []) (rev a))
     (rev a&#39;) <span class="kr">in</span>
 (rev items, final)) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (start, []) (rev a) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (afinal, []) (rev a&#39;) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk1b"><span class="nb">destruct</span>
    (fold_right _apply_plan_folder (@pair (state T) _ start []) (rev  a))
    <span class="kr">as</span> (afinal, aitems) <span class="nb">eqn</span>: Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (start, []) (rev a) =
(afinal, aitems)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (afinal, aitems) (rev a&#39;) <span class="kr">in</span>
 (rev items, final)) =
(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (afinal, []) (rev a&#39;) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (rev aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk1c"><span class="nb">destruct</span>
    (fold_right _apply_plan_folder (@pair (state T) _ afinal []) (rev a&#39;))
    <span class="kr">as</span> (final, items) <span class="nb">eqn</span>: Ha&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>a, a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (start, []) (rev a) =
(afinal, aitems)</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (afinal, []) (rev a&#39;) =
(final, items)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (afinal, aitems) (rev a&#39;) <span class="kr">in</span>
 (rev items, final)) =
(rev aitems ++ rev items, final)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk1d"><span class="nb">clear</span> - Ha&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (afinal, []) (rev a&#39;) =
(final, items)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (afinal, aitems) (rev a&#39;) <span class="kr">in</span>
 (rev items, final)) =
(rev aitems ++ rev items, final)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk1e"><span class="nb">specialize</span> (_apply_plan_folder_additive afinal (rev a&#39;) aitems) <span class="kr">as</span> Hadd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (afinal, []) (rev a&#39;) =
(final, items)</span></span></span><br><span><var>Hadd</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> (<span class="nv">final</span>, items) :=
  foldr _apply_plan_folder (
    afinal, []) (rev a&#39;) <span class="kr">in</span>
foldr _apply_plan_folder (
  afinal, aitems) (rev a&#39;) =
(final, items ++ aitems)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (afinal, aitems) (rev a&#39;) <span class="kr">in</span>
 (rev items, final)) =
(rev aitems ++ rev items, final)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk1f"><span class="nb">rewrite</span> Ha&#39; <span class="kr">in</span> Hadd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>final</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>items</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (afinal, []) (rev a&#39;) =
(final, items)</span></span></span><br><span><var>Hadd</var><span class="hyp-type"><b>: </b><span>foldr _apply_plan_folder (
  afinal, aitems) (rev a&#39;) =
(final, items ++ aitems)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">final</span>, items) :=
   foldr _apply_plan_folder (afinal, aitems) (rev a&#39;) <span class="kr">in</span>
 (rev items, final)) =
(rev aitems ++ rev items, final)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hadd, rev_app_distr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk20"><span class="kn">Lemma</span> <span class="nf">_apply_plan_cons</span>
  (<span class="nv">start</span> : state T)
  (<span class="nv">ai</span> : plan_item)
  (<span class="nv">a&#39;</span> : list plan_item)
  : _apply_plan start (ai :: a&#39;) =
    <span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start [ai] <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
     (aitems ++ a&#39;items, a&#39;final).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">_apply_plan start (ai :: a&#39;) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start [ai] <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">_apply_plan start (ai :: a&#39;) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start [ai] <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk22"><span class="nb">replace</span> (ai :: a&#39;) <span class="kr">with</span> ([ai] ++ a&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">_apply_plan start ([ai] ++ a&#39;) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start [ai] <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Plans-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk23"><hr></label><div class="goal-conclusion">[ai] ++ a&#39; = ai :: a&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk24">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">_apply_plan start ([ai] ++ a&#39;) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := _apply_plan start [ai] <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := _apply_plan afinal a&#39; <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> _apply_plan_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk25">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>T</var><span class="hyp-type"><b>: </b><span>VLSMType message</span></span></span><br><span><var>transition</var><span class="hyp-type"><b>: </b><span>label T
â†’ state T * option message
  â†’ state T * option message</span></span></span><br><span><var>start</var><span class="hyp-type"><b>: </b><span>state T</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[ai] ++ a&#39; = ai :: a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
We can forget information from a trace to obtain a plan. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">_transition_item_to_plan_item</span>
  (<span class="nv">item</span> : transition_item T)
  : plan_item
  := {| label_a := l item; input_a := input item |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">_trace_to_plan</span>
  (<span class="nv">items</span> : list transition_item)
  : list plan_item
  := map _transition_item_to_plan_item items.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">_messages_a</span>
  (<span class="nv">a</span> : list (plan_item T)) :
  list message :=
  ListExtras.cat_option (List.map input_a a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_apply_plans</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_valid_plans</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  {<span class="nv">message</span> : <span class="kt">Type</span>}
  (<span class="nv">X</span> : VLSM message)
  .</span></span></pre><div class="doc">
  We define several notations useful when we want to use the results above
  for a specific <span class="inlinecode"><span class="id" title="var">VLSM</span></span>, by instantiating the generic definitions with the
  corresponding <span class="inlinecode"><span class="id" title="keyword">type</span></span> and <span class="inlinecode"><span class="id" title="var">transition</span></span>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">plan</span> : <span class="kt">Type</span> := list (plan_item X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apply_plan</span> := (@_apply_plan _ X (@transition _ _ X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trace_to_plan</span> := (@_trace_to_plan _ X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apply_plan_app</span>
  (<span class="nv">start</span> : state X)
  (<span class="nv">a</span> <span class="nv">a&#39;</span> : plan)
  : apply_plan start (a ++ a&#39;) =
    <span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := apply_plan start a <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := apply_plan afinal a&#39; <span class="kr">in</span>
     (aitems ++ a&#39;items, a&#39;final)
  := (@_apply_plan_app _ X (@transition _ _ X) start a a&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">apply_plan_last</span>
  (<span class="nv">start</span> : state X)
  (<span class="nv">a</span> : plan)
  (<span class="nv">after_a</span> := apply_plan start a)
  : finite_trace_last start (fst after_a) = snd after_a
  := (@_apply_plan_last _ X (@transition _ _ X) start a).</span></span></pre><div class="doc">
  A plan is valid w.r.t. a state if by applying it to that state we
  obtain a valid trace sequence.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finite_valid_plan_from</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">a</span> : plan)
  : <span class="kt">Prop</span> :=
  finite_valid_trace_from _ s (fst (apply_plan s a)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk26"><span class="kn">Lemma</span> <span class="nf">finite_valid_plan_from_app_iff</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">a</span> <span class="nv">b</span> : plan)
  (<span class="nv">s_a</span> := snd (apply_plan s a))
  : finite_valid_plan_from s a /\ finite_valid_plan_from s_a b &lt;-&gt; finite_valid_plan_from s (a ++ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>s_a</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s a).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s a
âˆ§ finite_valid_plan_from s_a b
â†” finite_valid_plan_from s (a ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk27"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>s_a</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s a).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s a
âˆ§ finite_valid_plan_from s_a b
â†” finite_valid_plan_from s (a ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk28"><span class="nb">unfold</span> finite_valid_plan_from.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>s_a</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s a).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s (apply_plan s a).<span class="mi">1</span>
âˆ§ finite_valid_trace_from X s_a (apply_plan s_a b).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (apply_plan s (a ++ b)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk29"><span class="nb">specialize</span> (apply_plan_app s a b) <span class="kr">as</span> Happ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>s_a</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s a).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := apply_plan s a <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan afinal b <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s (apply_plan s a).<span class="mi">1</span>
âˆ§ finite_valid_trace_from X s_a (apply_plan s_a b).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (apply_plan s (a ++ b)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk2a"><span class="nb">specialize</span> (apply_plan_last s a) <span class="kr">as</span> Hlst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>s_a</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s a).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := apply_plan s a <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan afinal b <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := apply_plan s a <span class="kr">in</span>
finite_trace_last s after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s (apply_plan s a).<span class="mi">1</span>
âˆ§ finite_valid_trace_from X s_a (apply_plan s_a b).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (apply_plan s (a ++ b)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk2b"><span class="nb">destruct</span> (apply_plan s a) <span class="kr">as</span> (aitems, afinal) <span class="nb">eqn</span>: Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>s_a</var><span><span class="hyp-body"><b>:= </b><span>(aitems, afinal).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan afinal b <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := (aitems, afinal) <span class="kr">in</span>
finite_trace_last s after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s (aitems, afinal).<span class="mi">1</span>
âˆ§ finite_valid_trace_from X s_a (apply_plan s_a b).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (apply_plan s (a ++ b)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk2c"><span class="nb">subst</span> s_a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan afinal b <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := (aitems, afinal) <span class="kr">in</span>
finite_trace_last s after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s (aitems, afinal).<span class="mi">1</span>
âˆ§ finite_valid_trace_from X (aitems, afinal).<span class="mi">2</span>
    (apply_plan (aitems, afinal).<span class="mi">2</span> b).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (apply_plan s (a ++ b)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk2d"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan afinal b <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final))</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s aitems = afinal</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s aitems
âˆ§ finite_valid_trace_from X afinal
    (apply_plan afinal b).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (apply_plan s (a ++ b)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk2e"><span class="nb">destruct</span> (apply_plan afinal b) <span class="kr">as</span> (bitems, bfinal).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(aitems ++ bitems, bfinal)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s aitems = afinal</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s aitems
âˆ§ finite_valid_trace_from X afinal (bitems, bfinal).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (apply_plan s (a ++ b)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk2f"><span class="nb">rewrite</span> Happ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(aitems ++ bitems, bfinal)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s aitems = afinal</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s aitems
âˆ§ finite_valid_trace_from X afinal (bitems, bfinal).<span class="mi">1</span>
â†” finite_valid_trace_from X s
    (aitems ++ bitems, bfinal).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk30"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Happ</var><span class="hyp-type"><b>: </b><span>apply_plan s (a ++ b) =
(aitems ++ bitems, bfinal)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s aitems = afinal</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s aitems
âˆ§ finite_valid_trace_from X afinal bitems
â†” finite_valid_trace_from X s (aitems ++ bitems)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk31"><span class="nb">clear</span> Happ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s aitems = afinal</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s aitems
âˆ§ finite_valid_trace_from X afinal bitems
â†” finite_valid_trace_from X s (aitems ++ bitems)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk32"><span class="nb">subst</span> afinal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a =
(aitems, finite_trace_last s aitems)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s aitems
âˆ§ finite_valid_trace_from X
    (finite_trace_last s aitems) bitems
â†” finite_valid_trace_from X s (aitems ++ bitems)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> finite_valid_trace_from_app_iff.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk33"><span class="kn">Lemma</span> <span class="nf">finite_valid_plan_empty</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">Hpr</span> : valid_state_prop X s)  :
  finite_valid_plan_from s [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> finite_valid_trace_from_empty.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk35"><span class="kn">Lemma</span> <span class="nf">apply_plan_last_valid</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">a</span> : plan)
  (<span class="nv">Hpra</span> : finite_valid_plan_from s a)
  (<span class="nv">after_a</span> := apply_plan s a) :
  valid_state_prop X (snd after_a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Hpra</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>after_a</var><span><span class="hyp-body"><b>:= </b><span>apply_plan s a</span></span><span class="hyp-type"><b>: </b><span>(list transition_item * state X)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X after_a.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk36"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Hpra</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>after_a</var><span><span class="hyp-body"><b>:= </b><span>apply_plan s a</span></span><span class="hyp-type"><b>: </b><span>(list transition_item * state X)%type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X after_a.<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk37"><span class="nb">subst</span> after_a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Hpra</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X (apply_plan s a).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk38"><span class="nb">rewrite</span> &lt;- apply_plan_last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Hpra</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X
  (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> finite_valid_trace_last_pstate.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">finite_valid_plan_from_to</span> (<span class="nv">s</span> : state X) (<span class="nv">a</span> : plan) : <span class="kt">Prop</span> :=
  finite_valid_trace_from_to _ s (apply_plan s a).<span class="mi">2</span> (apply_plan s a).<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk39"><span class="kn">Lemma</span> <span class="nf">finite_valid_plan_from_to_app_iff</span> :
  <span class="kr">forall</span> (<span class="nv">s</span> : state X) (<span class="nv">a</span> <span class="nv">b</span> : plan),
    finite_valid_plan_from_to s (a ++ b)
      &lt;-&gt;
    finite_valid_plan_from_to s a /\ finite_valid_plan_from_to (apply_plan s a).<span class="mi">2</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">s</span> : state X) (<span class="nv">a</span> <span class="nv">b</span> : plan),
  finite_valid_plan_from_to s (a ++ b)
  â†” finite_valid_plan_from_to s a
    âˆ§ finite_valid_plan_from_to (apply_plan s a).<span class="mi">2</span> b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">s</span> : state X) (<span class="nv">a</span> <span class="nv">b</span> : plan),
  finite_valid_plan_from_to s (a ++ b)
  â†” finite_valid_plan_from_to s a
    âˆ§ finite_valid_plan_from_to (apply_plan s a).<span class="mi">2</span> b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk3b"><span class="nb">intros</span> s a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from_to s (a ++ b)
â†” finite_valid_plan_from_to s a
  âˆ§ finite_valid_plan_from_to (apply_plan s a).<span class="mi">2</span> b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk3c"><span class="nb">unfold</span> finite_valid_plan_from_to.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s
  (apply_plan s (a ++ b)).<span class="mi">2</span> (apply_plan s (a ++ b)).<span class="mi">1</span>
â†” finite_valid_trace_from_to X s (apply_plan s a).<span class="mi">2</span>
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X (apply_plan s a).<span class="mi">2</span>
      (apply_plan (apply_plan s a).<span class="mi">2</span> b).<span class="mi">2</span>
      (apply_plan (apply_plan s a).<span class="mi">2</span> b).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk3d"><span class="nb">rewrite</span> apply_plan_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s
  (<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := apply_plan s a <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := apply_plan afinal b <span class="kr">in</span>
   (aitems ++ a&#39;items, a&#39;final)).<span class="mi">2</span>
  (<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) := apply_plan s a <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) := apply_plan afinal b <span class="kr">in</span>
   (aitems ++ a&#39;items, a&#39;final)).<span class="mi">1</span>
â†” finite_valid_trace_from_to X s (apply_plan s a).<span class="mi">2</span>
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X (apply_plan s a).<span class="mi">2</span>
      (apply_plan (apply_plan s a).<span class="mi">2</span> b).<span class="mi">2</span>
      (apply_plan (apply_plan s a).<span class="mi">2</span> b).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk3e"><span class="nb">destruct</span> (apply_plan _ a) <span class="kr">as</span> [aitems afinal] <span class="nb">eqn</span>: Ha,
    (apply_plan _ b) <span class="kr">as</span> [bitems bfinal] <span class="nb">eqn</span>: Hb; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s bfinal
  (aitems ++ bitems)
â†” finite_valid_trace_from_to X s afinal aitems
  âˆ§ finite_valid_trace_from_to X afinal bfinal bitems</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk3f"><span class="nb">replace</span> aitems <span class="kr">with</span> (apply_plan s a).<span class="mi">1</span> <span class="bp">by</span> (<span class="nb">rewrite</span> Ha; <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s bfinal
  ((apply_plan s a).<span class="mi">1</span> ++ bitems)
â†” finite_valid_trace_from_to X s afinal
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X afinal bfinal bitems</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk40"><span class="nb">replace</span> afinal <span class="kr">with</span> (apply_plan s a).<span class="mi">2</span> <span class="bp">by</span> (<span class="nb">rewrite</span> Ha; <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s bfinal
  ((apply_plan s a).<span class="mi">1</span> ++ bitems)
â†” finite_valid_trace_from_to X s (apply_plan s a).<span class="mi">2</span>
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X (apply_plan s a).<span class="mi">2</span>
      bfinal bitems</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk41"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s bfinal
  ((apply_plan s a).<span class="mi">1</span> ++ bitems)
â†” finite_valid_trace_from_to X s (apply_plan s a).<span class="mi">2</span>
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X (apply_plan s a).<span class="mi">2</span>
      bfinal bitems</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk42"><span class="nb">rewrite</span> &lt;- apply_plan_last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s bfinal
  ((apply_plan s a).<span class="mi">1</span> ++ bitems)
â†” finite_valid_trace_from_to X s
    (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X
      (finite_trace_last s (apply_plan s a).<span class="mi">1</span>) bfinal
      bitems</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk43"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s bfinal
  ((apply_plan s a).<span class="mi">1</span> ++ bitems)
â†’ finite_valid_trace_from_to X s
    (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X
      (finite_trace_last s (apply_plan s a).<span class="mi">1</span>) bfinal
      bitems</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Plans-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk44"><hr></label><div class="goal-conclusion">finite_valid_trace_from_to X s
  (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)
  (apply_plan s a).<span class="mi">1</span>
âˆ§ finite_valid_trace_from_to X
    (finite_trace_last s (apply_plan s a).<span class="mi">1</span>) bfinal
    bitems
â†’ finite_valid_trace_from_to X s bfinal
    ((apply_plan s a).<span class="mi">1</span> ++ bitems)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk45">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s bfinal
  ((apply_plan s a).<span class="mi">1</span> ++ bitems)
â†’ finite_valid_trace_from_to X s
    (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)
    (apply_plan s a).<span class="mi">1</span>
  âˆ§ finite_valid_trace_from_to X
      (finite_trace_last s (apply_plan s a).<span class="mi">1</span>) bfinal
      bitems</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> finite_valid_trace_from_to_app_split.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>aitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>afinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>apply_plan s a = (aitems, afinal)</span></span></span><br><span><var>bitems</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>bfinal</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hb</var><span class="hyp-type"><b>: </b><span>apply_plan afinal b = (bitems, bfinal)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from_to X s
  (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)
  (apply_plan s a).<span class="mi">1</span>
âˆ§ finite_valid_trace_from_to X
    (finite_trace_last s (apply_plan s a).<span class="mi">1</span>) bfinal
    bitems
â†’ finite_valid_trace_from_to X s bfinal
    ((apply_plan s a).<span class="mi">1</span> ++ bitems)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> []; <span class="nb">eapply</span> finite_valid_trace_from_to_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  By extracting a plan from a <span class="inlinecode"><span class="id" title="var">valid_trace</span></span> based on a state <code>s</code>
  and reapplying the plan to the same state <code>s</code> we obtain the original trace.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk47"><span class="kn">Lemma</span> <span class="nf">trace_to_plan_to_trace_from_to</span>
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : state X)
  (<span class="nv">tr</span> : list (transition_item X))
  (<span class="nv">Htr</span> : finite_valid_trace_from_to X s s&#39; tr)
  : apply_plan s (trace_to_plan tr) = (tr, s&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X s s&#39; tr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_plan s (trace_to_plan tr) = (tr, s&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X s s&#39; tr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_plan s (trace_to_plan tr) = (tr, s&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk49"><span class="nb">induction</span> Htr <span class="nb">using</span> finite_valid_trace_from_to_rev_ind; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X l (s, iom) (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_plan si
  (trace_to_plan
     (tr ++
      [{|
         l := l;
         input := iom;
         destination := sf;
         output := oom
       |}])) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk4a"><span class="nb">unfold</span> trace_to_plan, _trace_to_plan.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X l (s, iom) (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">apply_plan si
  (map _transition_item_to_plan_item
     (tr ++
      [{|
         l := l;
         input := iom;
         destination := sf;
         output := oom
       |}])) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk4b"><span class="nb">rewrite</span> map_last, apply_plan_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X l (s, iom) (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) :=
   apply_plan si
     (map _transition_item_to_plan_item tr) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan afinal
     [_transition_item_to_plan_item
        {|
          l := l;
          input := iom;
          destination := sf;
          output := oom
        |}] <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final)) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk4c"><span class="nb">change</span> (map _ tr) <span class="kr">with</span> (trace_to_plan tr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X l (s, iom) (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">aitems</span>, afinal) :=
   apply_plan si (trace_to_plan tr) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan afinal
     [_transition_item_to_plan_item
        {|
          l := l;
          input := iom;
          destination := sf;
          output := oom
        |}] <span class="kr">in</span>
 (aitems ++ a&#39;items, a&#39;final)) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk4d"><span class="nb">rewrite</span> IHHtr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X l (s, iom) (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   apply_plan s
     [_transition_item_to_plan_item
        {|
          l := l;
          input := iom;
          destination := sf;
          output := oom
        |}] <span class="kr">in</span>
 (tr ++ a&#39;items, a&#39;final)) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk4e"><span class="nb">unfold</span> _transition_item_to_plan_item, apply_plan, _apply_plan.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X l (s, iom) (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (s, [])
       (rev
          [{|
             label_a :=
               VLSM.l
                 {|
                   l := l;
                   input := iom;
                   destination := sf;
                   output := oom
                 |};
             input_a :=
               input
                 {|
                   l := l;
                   input := iom;
                   destination := sf;
                   output := oom
                 |}
           |}]) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (tr ++ a&#39;items, a&#39;final)) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk4f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X l (s, iom) (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) := transition l (s, iom) <span class="kr">in</span>
     (dest,
      [{|
         l := l;
         input := iom;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (tr ++ a&#39;items, a&#39;final)) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk50"><span class="nb">destruct</span> Ht <span class="kr">as</span> [Hvx Hx].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>si, s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from_to X si s tr</span></span></span><br><span><var>sf</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Hvx</var><span class="hyp-type"><b>: </b><span>input_valid X l (s, iom)</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>transition l (s, iom) = (sf, oom)</span></span></span><br><span><var>IHHtr</var><span class="hyp-type"><b>: </b><span>apply_plan si (trace_to_plan tr) = (tr, s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">a&#39;items</span>, a&#39;final) :=
   <span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) := transition l (s, iom) <span class="kr">in</span>
     (dest,
      [{|
         l := l;
         input := iom;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final) <span class="kr">in</span>
 (tr ++ a&#39;items, a&#39;final)) =
(tr ++
 [{|
    l := l;
    input := iom;
    destination := sf;
    output := oom
  |}], sf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Hx.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk51"><span class="kn">Lemma</span> <span class="nf">trace_to_plan_to_trace</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">tr</span> : list (transition_item X))
  (<span class="nv">Htr</span> : finite_valid_trace_from X s tr)
  : fst (apply_plan s (trace_to_plan tr)) = tr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s tr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apply_plan s (trace_to_plan tr)).<span class="mi">1</span> = tr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s tr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apply_plan s (trace_to_plan tr)).<span class="mi">1</span> = tr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk53"><span class="nb">apply</span> valid_trace_add_default_last, trace_to_plan_to_trace_from_to <span class="kr">in</span> Htr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>apply_plan s (trace_to_plan tr) =
(tr, finite_trace_last s tr)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(apply_plan s (trace_to_plan tr)).<span class="mi">1</span> = tr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Htr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  The plan extracted from a valid trace is valid w.r.t. the starting
  state of the trace.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk54"><span class="kn">Lemma</span> <span class="nf">finite_valid_trace_from_to_plan</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">tr</span> : list (transition_item X))
  (<span class="nv">Htr</span> : finite_valid_trace_from X s tr)
  : finite_valid_plan_from s (trace_to_plan tr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s tr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (trace_to_plan tr)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk55"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>Htr</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s tr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (trace_to_plan tr)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> finite_valid_plan_from; <span class="nb">rewrite</span> trace_to_plan_to_trace.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
Characterization of valid plans. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk56"><span class="kn">Lemma</span> <span class="nf">finite_valid_plan_iff</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">a</span> : plan)
  : finite_valid_plan_from s a
  &lt;-&gt; valid_state_prop X s
  /\ Forall (<span class="kr">fun</span> <span class="nv">ai</span> =&gt; option_valid_message_prop X (input_a ai)) a
  /\ <span class="kr">forall</span>
      (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan)
      (<span class="nv">ai</span> : plan_item)
      (<span class="nv">Heqa</span> : a = prefa ++ [ai] ++ suffa)
      (<span class="nv">lst</span> := snd (apply_plan s prefa)),
      valid X (label_a ai) (lst, input_a ai).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk58"><span class="nb">induction</span> a <span class="nb">using</span> rev_ind; <span class="kp">repeat</span> <span class="nb">split</span>; <span class="nb">intros</span>
  ; <span class="kp">try</span>
    (<span class="nb">apply</span> finite_valid_plan_from_app_iff <span class="kr">in</span> H
    ; <span class="nb">destruct</span> H <span class="kr">as</span> [Ha Hx]; <span class="nb">apply</span> IHa <span class="kr">in</span> Ha <span class="kr">as</span> Ha&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X s</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Plans-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s []</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk59"><hr></label><div class="goal-conclusion">Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai)) []</div></blockquote><input class="alectryon-extra-goal-toggle" id="Plans-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s []</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>[] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><label class="goal-separator" for="Plans-v-chk5a"><hr></label><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Plans-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    []
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       [] = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk5b"><hr></label><div class="goal-conclusion">finite_valid_plan_from s []</div></blockquote><input class="alectryon-extra-goal-toggle" id="Plans-v-chk5c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk5c"><hr></label><div class="goal-conclusion">valid_state_prop X s</div></blockquote><input class="alectryon-extra-goal-toggle" id="Plans-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk5d"><hr></label><div class="goal-conclusion">Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  (a ++ [x])</div></blockquote><input class="alectryon-extra-goal-toggle" id="Plans-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk5e"><hr></label><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote><input class="alectryon-extra-goal-toggle" id="Plans-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    (a ++ [x])
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a ++ [x] = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk5f"><hr></label><div class="goal-conclusion">finite_valid_plan_from s (a ++ [x])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk61">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai)) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk62">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s []</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>[] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> prefa; <span class="nb">simpl</span> <span class="kr">in</span> Heqa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk63">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    []
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       [] = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> H <span class="kr">as</span> [Hs _]; <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk64">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X s</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> Ha&#39; <span class="kr">as</span> [Hs _].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  (a ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk66"><span class="nb">destruct</span> Ha&#39; <span class="kr">as</span> [_ [Hmsgs _]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  (a ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk67"><span class="nb">apply</span> Forall_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai)) a
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai)) [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk68"><span class="nb">split</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai)) [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk69"><span class="kp">repeat</span> <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X (input_a x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk6a"><span class="nb">unfold</span> finite_valid_plan_from <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X 
  (apply_plan s a).<span class="mi">2</span>
  (apply_plan (apply_plan s a).<span class="mi">2</span> [x]).<span class="mi">1</span></span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X (input_a x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk6b"><span class="nb">remember</span> (snd (apply_plan s a)) <span class="kr">as</span> lst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (apply_plan lst [x]).<span class="mi">1</span></span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X (input_a x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk6c"><span class="nb">unfold</span> apply_plan, _apply_plan <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (lst, []) (rev [x]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X (input_a x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk6d"><span class="nb">simpl</span> <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">match</span> x <span class="kr">with</span>
     | {| label_a := l&#39;; input_a := input&#39; |} =&gt;
         <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
           transition l&#39; (lst, input&#39;) <span class="kr">in</span>
         (dest,
          [{|
             l := l&#39;;
             input := input&#39;;
             destination := dest;
             output := out
           |}])
     <span class="kr">end</span> <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X (input_a x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk6e"><span class="nb">destruct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (lst, input_a0) <span class="kr">in</span>
     (dest,
      [{|
         l := label_a0;
         input := input_a0;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X
  (input_a
     {| label_a := label_a0; input_a := input_a0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk6f"><span class="nb">destruct</span> (transition X label_a0 (lst, input_a0)) <span class="kr">as</span> (dest, out).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (rev
     [{|
        l := label_a0;
        input := input_a0;
        destination := dest;
        output := out
      |}], dest).<span class="mi">1</span></span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X
  (input_a
     {| label_a := label_a0; input_a := input_a0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk70"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (rev
     [{|
        l := label_a0;
        input := input_a0;
        destination := dest;
        output := out
      |}], dest).<span class="mi">1</span></span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X input_a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk71"><span class="nb">simpl</span> <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X input_a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk72"><span class="nb">inversion</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Htl</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X dest []</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0 (
  lst, input_a0) (dest, out)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>s&#39; = lst</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>l = label_a0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>iom = input_a0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>s0 = dest</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>oom = out</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>tl = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X input_a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk73"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X 
  (apply_plan s a).<span class="mi">2</span>
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</span></span></span><br><span><var>Hmsgs</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Htl</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X dest []</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0
  ((apply_plan s a).<span class="mi">2</span>, input_a0) (
  dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">option_valid_message_prop X input_a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Ht.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk74">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk75"><span class="nb">assert</span> (Hsuffa : suffa = [] \/ suffa &lt;&gt; []) <span class="bp">by</span>
      (<span class="nb">destruct</span> suffa; <span class="kp">try</span> (<span class="nb">left</span>; <span class="bp">congruence</span>); <span class="nb">right</span>; <span class="bp">congruence</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hsuffa</var><span class="hyp-type"><b>: </b><span>suffa = [] âˆ¨ suffa â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk76"><span class="nb">destruct</span> Hsuffa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>suffa = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Plans-v-chk77" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>suffa â‰  []</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk77"><hr></label><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk78">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>suffa = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk79"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ []</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk7a"><span class="nb">rewrite</span> app_assoc <span class="kr">in</span> Heqa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = (prefa ++ [ai]) ++ []</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk7b"><span class="nb">rewrite</span> app_nil_r <span class="kr">in</span> Heqa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai]</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk7c"><span class="nb">apply</span> app_inj_tail <span class="kr">in</span> Heqa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a = prefa âˆ§ x = ai</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk7d"><span class="nb">destruct</span> Heqa; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from 
  (apply_plan s prefa).<span class="mi">2</span> [ai]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk7e"><span class="nb">unfold</span> lst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from 
  (apply_plan s prefa).<span class="mi">2</span> [ai]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai)
  ((apply_plan s prefa).<span class="mi">2</span>, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk7f"><span class="nb">clear</span> lst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from 
  (apply_plan s prefa).<span class="mi">2</span> [ai]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai)
  ((apply_plan s prefa).<span class="mi">2</span>, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk80"><span class="nb">remember</span> (snd (apply_plan s prefa)) <span class="kr">as</span> lst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from lst [ai]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk81"><span class="nb">unfold</span> finite_valid_plan_from <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (apply_plan lst [ai]).<span class="mi">1</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk82"><span class="nb">unfold</span> apply_plan, _apply_plan <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (
       lst, []) (rev [ai]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk83"><span class="nb">simpl</span> <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">match</span> ai <span class="kr">with</span>
     | {| label_a := l&#39;; input_a := input&#39; |} =&gt;
         <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
           transition l&#39; (lst, input&#39;) <span class="kr">in</span>
         (dest,
          [{|
             l := l&#39;;
             input := input&#39;;
             destination := dest;
             output := out
           |}])
     <span class="kr">end</span> <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk84"><span class="nb">destruct</span> ai.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (lst, input_a0) <span class="kr">in</span>
     (dest,
      [{|
         l := label_a0;
         input := input_a0;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid
  (label_a
     {| label_a := label_a0; input_a := input_a0 |})
  (lst,
   input_a
     {| label_a := label_a0; input_a := input_a0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk85"><span class="nb">destruct</span> (transition X label_a0 (lst, input_a0)) <span class="kr">as</span> (dest, out).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (rev
     [{|
        l := label_a0;
        input := input_a0;
        destination := dest;
        output := out
      |}], dest).<span class="mi">1</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid
  (label_a
     {| label_a := label_a0; input_a := input_a0 |})
  (lst,
   input_a
     {| label_a := label_a0; input_a := input_a0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk86"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  (rev
     [{|
        l := label_a0;
        input := input_a0;
        destination := dest;
        output := out
      |}], dest).<span class="mi">1</span></span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid label_a0 (lst, input_a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk87"><span class="nb">simpl</span> <span class="kr">in</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid label_a0 (lst, input_a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk88"><span class="nb">inversion</span> Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>lst</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqlst</var><span class="hyp-type"><b>: </b><span>lst = (apply_plan s prefa).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X lst
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list transition_item</span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>iom, oom</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>Htl</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X dest []</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0 (
  lst, input_a0) (dest, out)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>s&#39; = lst</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>l = label_a0</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>iom = input_a0</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>s0 = dest</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>oom = out</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>tl = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid label_a0 (lst, input_a0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk89"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X 
  (apply_plan s prefa).<span class="mi">2</span>
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s prefa
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) prefa
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         prefa = prefa0 ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    prefa
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       prefa = prefa0 ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Htl</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X dest []</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0
  ((apply_plan s prefa).<span class="mi">2</span>, input_a0) (
  dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid label_a0 ((apply_plan s prefa).<span class="mi">2</span>, input_a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Ht.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk8a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>suffa â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk8b"><span class="nb">apply</span> exists_last <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>{l&#39; : list plan_item &amp;
{a : plan_item | suffa = l&#39; ++ [a]}}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk8c"><span class="nb">destruct</span> H <span class="kr">as</span> [suffa&#39; [x&#39; Heq]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>suffa'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>suffa = suffa&#39; ++ [x&#39;]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk8d"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>suffa'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa&#39; ++ [x&#39;]</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk8e"><span class="kp">repeat</span> <span class="nb">rewrite</span> app_assoc <span class="kr">in</span> Heqa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>suffa'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a ++ [x] = ((prefa ++ [ai]) ++ suffa&#39;) ++ [x&#39;]</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk8f"><span class="nb">apply</span> app_inj_tail <span class="kr">in</span> Heqa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>suffa'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a = (prefa ++ [ai]) ++ suffa&#39; âˆ§ x = x&#39;</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk90"><span class="nb">rewrite</span> &lt;- app_assoc <span class="kr">in</span> Heqa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>suffa'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a = prefa ++ [ai] ++ suffa&#39; âˆ§ x = x&#39;</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    a
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk91"><span class="nb">destruct</span> Heqa; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>suffa'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from
  (apply_plan s (prefa ++ [ai] ++ suffa&#39;)).<span class="mi">2</span> [x&#39;]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s
  (prefa ++ [ai] ++ suffa&#39;)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s
  (prefa ++ [ai] ++ suffa&#39;)
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai))
      (prefa ++ [ai] ++ suffa&#39;)
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai0</span> : plan_item),
         prefa ++ [ai] ++ suffa&#39; =
         prefa0 ++ [ai0] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai0)
             (lst, input_a ai0))</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    (prefa ++ [ai] ++ suffa&#39;)
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai0</span> : plan_item),
       prefa ++ [ai] ++ suffa&#39; =
       prefa0 ++ [ai0] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai0) (lst, input_a ai0))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk92"><span class="nb">destruct</span> Ha&#39; <span class="kr">as</span> [_ [_ Ha&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>prefa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>suffa'</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from
  (apply_plan s (prefa ++ [ai] ++ suffa&#39;)).<span class="mi">2</span> [x&#39;]</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s
  (prefa ++ [ai] ++ suffa&#39;)</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s
  (prefa ++ [ai] ++ suffa&#39;)
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai))
      (prefa ++ [ai] ++ suffa&#39;)
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai0</span> : plan_item),
         prefa ++ [ai] ++ suffa&#39; =
         prefa0 ++ [ai0] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai0)
             (lst, input_a ai0))</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa0</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai0</span> : plan_item),
  prefa ++ [ai] ++ suffa&#39; =
  prefa0 ++ [ai0] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa0).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai0) (lst, input_a ai0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> IHa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk93">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X (input_a ai))
    (a ++ [x])
  âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
       a ++ [x] = prefa ++ [ai] ++ suffa
       â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
         valid (label_a ai) (lst, input_a ai))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (a ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk94"><span class="nb">destruct</span> H <span class="kr">as</span> [Hs [Hinput Hvalid]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  (a ++ [x])</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (a ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk95"><span class="nb">apply</span> Forall_app <span class="kr">in</span> Hinput.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a
âˆ§ Forall
    (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
       option_valid_message_prop X
         (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (a ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk96"><span class="nb">destruct</span> Hinput <span class="kr">as</span> [Hinput Hinput_ai].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (a ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk97"><span class="nb">apply</span> finite_valid_plan_from_app_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s a
âˆ§ finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk98"><span class="nb">assert</span> (Ha : finite_valid_plan_from s a); <span class="kp">try</span> (<span class="bp">by</span> <span class="nb">split</span>)
    ; <span class="kp">try</span> <span class="nb">apply</span> IHa; <span class="kp">repeat</span> <span class="nb">split</span>; <span class="kp">try</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Plans-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><label class="goal-separator" for="Plans-v-chk99"><hr></label><div class="goal-conclusion">finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk9a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk9b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk9c"><span class="nb">specialize</span> (Hvalid prefa (suffa ++ [x]) ai).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span>a ++ [x] = prefa ++ [ai] ++ suffa ++ [x]
â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
  valid (label_a ai) (lst, input_a ai)</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a = prefa ++ [ai] ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk9d"><span class="kp">repeat</span> <span class="nb">rewrite</span> app_assoc <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>prefa, suffa</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>ai</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span>a ++ [x] = ((prefa ++ [ai]) ++ suffa) ++ [x]
â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
  valid (label_a ai) (lst, input_a ai)</span></span></span><br><span><var>Heqa</var><span class="hyp-type"><b>: </b><span>a = (prefa ++ [ai]) ++ suffa</span></span></span><br><span><var>lst</var><span><span class="hyp-body"><b>:= </b><span>(apply_plan s prefa).<span class="mi">2</span></span></span><span class="hyp-type"><b>: </b><span>state X</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid (label_a ai) (lst, input_a ai)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">subst</span> a; <span class="nb">apply</span> Hvalid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk9e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> [x]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chk9f"><span class="nb">unfold</span> finite_valid_plan_from.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
  a ++ [x] = prefa ++ [ai] ++ suffa
  â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
    valid (label_a ai) (lst, input_a ai)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X (apply_plan s a).<span class="mi">2</span>
  (apply_plan (apply_plan s a).<span class="mi">2</span> [x]).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka0"><span class="nb">specialize</span> (Hvalid a [] x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span>a ++ [x] = a ++ [x] ++ []
â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s a).<span class="mi">2</span> <span class="kr">in</span>
  valid (label_a x) (lst, input_a x)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X (apply_plan s a).<span class="mi">2</span>
  (apply_plan (apply_plan s a).<span class="mi">2</span> [x]).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka1"><span class="nb">rewrite</span> app_assoc <span class="kr">in</span> Hvalid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span>a ++ [x] = (a ++ [x]) ++ []
â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s a).<span class="mi">2</span> <span class="kr">in</span>
  valid (label_a x) (lst, input_a x)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X (apply_plan s a).<span class="mi">2</span>
  (apply_plan (apply_plan s a).<span class="mi">2</span> [x]).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka2"><span class="nb">rewrite</span> app_nil_r <span class="kr">in</span> Hvalid.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span>a ++ [x] = a ++ [x]
â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s a).<span class="mi">2</span> <span class="kr">in</span>
  valid (label_a x) (lst, input_a x)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X (apply_plan s a).<span class="mi">2</span>
  (apply_plan (apply_plan s a).<span class="mi">2</span> [x]).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka3"><span class="nb">specialize</span> (Hvalid eq_refl).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s a).<span class="mi">2</span> <span class="kr">in</span>
valid (label_a x) (lst, input_a x)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X (apply_plan s a).<span class="mi">2</span>
  (apply_plan (apply_plan s a).<span class="mi">2</span> [x]).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka4"><span class="nb">remember</span> (snd (apply_plan s a)) <span class="kr">as</span> sa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid (label_a x) (lst, input_a x)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa (apply_plan sa [x]).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka5"><span class="nb">unfold</span> apply_plan, _apply_plan.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid (label_a x) (lst, input_a x)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     foldr _apply_plan_folder (sa, []) (rev [x]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai)) [x]</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid (label_a x) (lst, input_a x)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">match</span> x <span class="kr">with</span>
     | {| label_a := l&#39;; input_a := input&#39; |} =&gt;
         <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
           transition l&#39; (sa, input&#39;) <span class="kr">in</span>
         (dest,
          [{|
             l := l&#39;;
             input := input&#39;;
             destination := dest;
             output := out
           |}])
     <span class="kr">end</span> <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka7"><span class="nb">destruct</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai))
  [{|
     label_a := label_a0;
     input_a := input_a0
   |}]</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (sa, input_a0) <span class="kr">in</span>
     (dest,
      [{|
         l := label_a0;
         input := input_a0;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka8"><span class="nb">destruct</span> (transition X label_a0 (sa, input_a0)) <span class="kr">as</span> (dest, out) <span class="nb">eqn</span>: Ht.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai))
  [{|
     label_a := label_a0;
     input_a := input_a0
   |}]</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  (rev
     [{|
        l := label_a0;
        input := input_a0;
        destination := dest;
        output := out
      |}], dest).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chka9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X
       (input_a ai))
  [{|
     label_a := label_a0;
     input_a := input_a0
   |}]</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkaa"><span class="nb">apply</span> Forall_inv <span class="kr">in</span> Hinput_ai.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X
  (input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkab"><span class="nb">simpl</span> <span class="kr">in</span> Hinput_ai.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkac"><span class="nb">unfold</span> finite_valid_plan_from <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s (apply_plan s a).<span class="mi">1</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkad"><span class="nb">apply</span> finite_valid_trace_last_pstate <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>valid_state_prop X
  (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkae"><span class="nb">specialize</span> (apply_plan_last s a) <span class="kr">as</span> Hlst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>valid_state_prop X
  (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">after_a</span> := apply_plan s a <span class="kr">in</span>
finite_trace_last s after_a.<span class="mi">1</span> = after_a.<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkaf"><span class="nb">simpl</span> <span class="kr">in</span> Hlst, Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>valid_state_prop X
  (finite_trace_last s (apply_plan s a).<span class="mi">1</span>)</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s (apply_plan s a).<span class="mi">1</span> =
(apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb0"><span class="nb">setoid_rewrite</span> Hlst <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>valid_state_prop X (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s (apply_plan s a).<span class="mi">1</span> =
(apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb1"><span class="nb">setoid_rewrite</span> &lt;- Heqsa <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>valid_state_prop X sa</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s (apply_plan s a).<span class="mi">1</span> =
(apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X sa
  [{|
     l := label_a0;
     input := input_a0;
     destination := dest;
     output := out
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb2"><span class="kp">repeat</span> <span class="nb">constructor</span>; [| <span class="bp">done</span> ..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>valid_state_prop X sa</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s (apply_plan s a).<span class="mi">1</span> =
(apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X dest</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb3"><span class="kr">exists</span> <span class="nv">out</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>valid_state_prop X sa</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s (apply_plan s a).<span class="mi">1</span> =
(apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_message_prop X dest out</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb4"><span class="nb">destruct</span> Ha <span class="kr">as</span> [_oma Hsa].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>Hinput_ai</var><span class="hyp-type"><b>: </b><span>option_valid_message_prop X input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>_oma</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hsa</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop X sa _oma</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s (apply_plan s a).<span class="mi">1</span> =
(apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_message_prop X dest out</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb5"><span class="nb">destruct</span> Hinput_ai <span class="kr">as</span> [_s Hinput_a0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>list plan_item</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a
â†” valid_state_prop X s
  âˆ§ Forall
      (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
         option_valid_message_prop X
           (input_a ai)) a
    âˆ§ (<span class="kr">âˆ€</span> (<span class="nv">prefa</span> <span class="nv">suffa</span> : plan) (<span class="nv">ai</span> : plan_item),
         a = prefa ++ [ai] ++ suffa
         â†’ <span class="kr">let</span> <span class="nv">lst</span> := (apply_plan s prefa).<span class="mi">2</span> <span class="kr">in</span>
           valid (label_a ai) (lst, input_a ai))</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Hinput</var><span class="hyp-type"><b>: </b><span>Forall
  (<span class="kr">Î»</span> <span class="nv">ai</span> : plan_item,
     option_valid_message_prop X (input_a ai))
  a</span></span></span><br><span><var>_s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hinput_a0</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop X _s input_a0</span></span></span><br><span><var>sa</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqsa</var><span class="hyp-type"><b>: </b><span>sa = (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>Hvalid</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">lst</span> := sa <span class="kr">in</span>
valid
  (label_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})
  (lst,
   input_a
     {|
       label_a := label_a0;
       input_a := input_a0
     |})</span></span></span><br><span><var>_oma</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Hsa</var><span class="hyp-type"><b>: </b><span>valid_state_message_prop X sa _oma</span></span></span><br><span><var>dest</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>out</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>Ht</var><span class="hyp-type"><b>: </b><span>transition label_a0 (sa, input_a0) = (dest, out)</span></span></span><br><span><var>Hlst</var><span class="hyp-type"><b>: </b><span>finite_trace_last s (apply_plan s a).<span class="mi">1</span> =
(apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_message_prop X dest out</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> valid_generated_state_message <span class="kr">with</span> sa _oma _s input_a0 label_a0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
Characterizing a singleton valid plan as a input valid transition. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb6"><span class="kn">Lemma</span> <span class="nf">finite_valid_plan_from_one</span>
  (<span class="nv">s</span> : state X)
  (<span class="nv">a</span> : plan_item) :
  <span class="kr">let</span> <span class="nv">res</span> := transition X (label_a a) (s, input_a a) <span class="kr">in</span>
  finite_valid_plan_from s [a] &lt;-&gt; input_valid_transition X (label_a a) (s, input_a a) res.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">res</span> := transition (label_a a) (s, input_a a) <span class="kr">in</span>
finite_valid_plan_from s [a]
â†” input_valid_transition X (label_a a) (s, input_a a)
    res</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>plan_item</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> <span class="nv">res</span> := transition (label_a a) (s, input_a a) <span class="kr">in</span>
finite_valid_plan_from s [a]
â†” input_valid_transition X (label_a a) (s, input_a a)
    res</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkb8"><span class="nb">split</span>;
  <span class="nb">intros</span>;
  <span class="nb">destruct</span> a;
  <span class="nb">unfold</span> apply_plan, _apply_plan <span class="kr">in</span> *; <span class="nb">simpl</span> <span class="kr">in</span> *;
  <span class="nb">unfold</span> finite_valid_plan_from <span class="kr">in</span> *;
  <span class="nb">unfold</span> apply_plan, _apply_plan <span class="kr">in</span> *; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (s, input_a0) <span class="kr">in</span>
     (dest,
      [{|
         l := label_a0;
         input := input_a0;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition X label_a0 (s, input_a0)
  (transition label_a0 (s, input_a0))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Plans-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0 (
  s, input_a0) (transition label_a0 (s, input_a0))</span></span></span><br></div><label class="goal-separator" for="Plans-v-chkb9"><hr></label><div class="goal-conclusion">finite_valid_trace_from X s
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (s, input_a0) <span class="kr">in</span>
     (dest,
      [{|
         l := label_a0;
         input := input_a0;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (s, input_a0) <span class="kr">in</span>
     (dest,
      [{|
         l := label_a0;
         input := input_a0;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition X label_a0 (s, input_a0)
  (transition label_a0 (s, input_a0))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkbb"><span class="nb">destruct</span> (transition label_a0 (s, input_a0)); <span class="nb">cbn</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>o</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>finite_valid_trace_from X s
  [{|
     l := label_a0;
     input := input_a0;
     destination := s0;
     output := o
   |}]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">input_valid_transition X label_a0 (s, input_a0)
  (s0, o)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> H; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkbc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0 (
  s, input_a0) (transition label_a0 (s, input_a0))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s
  (<span class="kr">let</span> (<span class="nv">final</span>, items) :=
     <span class="kr">let</span> (<span class="nv">dest</span>, out) :=
       transition label_a0 (s, input_a0) <span class="kr">in</span>
     (dest,
      [{|
         l := label_a0;
         input := input_a0;
         destination := dest;
         output := out
       |}]) <span class="kr">in</span>
   (rev items, final)).<span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkbd"><span class="nb">destruct</span> (transition label_a0 (s, input_a0)); <span class="nb">cbn</span> <span class="kr">in</span> H |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>o</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0 (
  s, input_a0) (s0, o)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s
  [{|
     l := label_a0;
     input := input_a0;
     destination := s0;
     output := o
   |}]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkbe"><span class="nb">apply</span> finite_valid_trace_from_extend; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>o</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0 (
  s, input_a0) (s0, o)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_trace_from X s0 []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkbf"><span class="nb">apply</span> finite_valid_trace_from_empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>label_a0</var><span class="hyp-type"><b>: </b><span>label X</span></span></span><br><span><var>input_a0</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>o</var><span class="hyp-type"><b>: </b><span>option message</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>input_valid_transition X label_a0 (
  s, input_a0) (s0, o)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X s0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> input_valid_transition_destination <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">preserves</span>
  (<span class="nv">a</span> : plan)
  (<span class="nv">P</span> : state X -&gt; <span class="kt">Prop</span>) :
  <span class="kt">Prop</span> :=
  <span class="kr">forall</span> (<span class="nv">s</span> : state X),
  (P s -&gt; valid_state_prop X s -&gt; finite_valid_plan_from s a -&gt; P (snd (apply_plan s a))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ensures</span>
  (<span class="nv">a</span> : plan)
  (<span class="nv">P</span> : state X -&gt; <span class="kt">Prop</span>) :
  <span class="kt">Prop</span> :=
  <span class="kr">forall</span> (<span class="nv">s</span> : state X),
  (valid_state_prop X s -&gt; P s -&gt; finite_valid_plan_from s a).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*</span>
<span class="c">  If some property of a state guarantees a plan `b` applied to the state is valid,</span>
<span class="c">  and this property is preserved by the application of some other plan `a`,</span>
<span class="c">  then these two plans can be composed and the application of `a ++ b` will also</span>
<span class="c">  be valid.</span>
<span class="c">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc0"><span class="kn">Lemma</span> <span class="nf">plan_independence</span>
  (<span class="nv">a</span> <span class="nv">b</span> : plan)
  (<span class="nv">Pb</span> : state X -&gt; <span class="kt">Prop</span>)
  (<span class="nv">s</span> : state X)
  (<span class="nv">Hpr</span> : valid_state_prop X s)
  (<span class="nv">Ha</span> : finite_valid_plan_from s a)
  (<span class="nv">Hhave</span> : Pb s)
  (<span class="nv">Hensures</span> : ensures b Pb)
  (<span class="nv">Hpreserves</span> : preserves a Pb) :
    finite_valid_plan_from s (a ++ b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span>ensures b Pb</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span>preserves a Pb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (a ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span>ensures b Pb</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span>preserves a Pb</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (a ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc2"><span class="nb">unfold</span> ensures, preserves <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s (a ++ b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc3"><span class="nb">apply</span> finite_valid_plan_from_app_iff.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s a
âˆ§ finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc4"><span class="nb">split</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc5"><span class="nb">remember</span> (snd (apply_plan s a)) <span class="kr">as</span> s&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqs'</var><span class="hyp-type"><b>: </b><span>s&#39; = (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from s&#39; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc6"><span class="nb">rewrite</span> Heqs&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqs'</var><span class="hyp-type"><b>: </b><span>s&#39; = (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">finite_valid_plan_from (apply_plan s a).<span class="mi">2</span> b</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc7"><span class="nb">apply</span> Hensures.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqs'</var><span class="hyp-type"><b>: </b><span>s&#39; = (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X (apply_plan s a).<span class="mi">2</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="Plans-v-chkc8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqs'</var><span class="hyp-type"><b>: </b><span>s&#39; = (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="Plans-v-chkc8"><hr></label><div class="goal-conclusion">Pb (apply_plan s a).<span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkc9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqs'</var><span class="hyp-type"><b>: </b><span>s&#39; = (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">valid_state_prop X (apply_plan s a).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> apply_plan_last_valid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Plans-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="Plans-v-chkca">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>message</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span>VLSM message</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>plan</span></span></span><br><span><var>Pb</var><span class="hyp-type"><b>: </b><span>state X â†’ <span class="kt">Prop</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Hpr</var><span class="hyp-type"><b>: </b><span>valid_state_prop X s</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>finite_valid_plan_from s a</span></span></span><br><span><var>Hhave</var><span class="hyp-type"><b>: </b><span>Pb s</span></span></span><br><span><var>Hensures</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  valid_state_prop X s
  â†’ Pb s â†’ finite_valid_plan_from s b</span></span></span><br><span><var>Hpreserves</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">s</span> : state X,
  Pb s
  â†’ valid_state_prop X s
    â†’ finite_valid_plan_from s a
      â†’ Pb (apply_plan s a).<span class="mi">2</span></span></span></span><br><span><var>s'</var><span class="hyp-type"><b>: </b><span>state X</span></span></span><br><span><var>Heqs'</var><span class="hyp-type"><b>: </b><span>s&#39; = (apply_plan s a).<span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Pb (apply_plan s a).<span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hpreserves.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_valid_plans</span>.</span></span></pre></article></body></html>