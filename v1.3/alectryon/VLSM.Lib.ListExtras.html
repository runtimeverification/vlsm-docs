<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>ListExtras.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.18.0+0.18.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk0"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> Itauto.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file coq-itauto.plugin ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> prelude finite.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> FinFun.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> Preamble.</span></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Utility: Lemmas About Lists</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
  A list is either empty or it can be decomposed into an initial prefix
  and the last element.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1"><span class="kn">Lemma</span> <span class="nf">has_last_or_null</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A),
    {l&#39; : list A &amp; {a : A | l = l&#39; ++ (a :: nil)}} + {l = nil}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
  {l&#39; : list A &amp; {a : A | l = l&#39; ++ [a]}} + {l = []}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A),
  {l&#39; : list A &amp; {a : A | l = l&#39; ++ [a]}} + {l = []}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk3"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{l&#39; : list A &amp; {a : A | [] = l&#39; ++ [a]}} + {[] = []}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk4"><hr></label><div class="goal-conclusion">{l&#39; : list A &amp; {a0 : A | a :: l = l&#39; ++ [a0]}} +
{a :: l = []}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{l&#39; : list A &amp; {a : A | [] = l&#39; ++ [a]}} + {[] = []}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{l&#39; : list A &amp; {a0 : A | a :: l = l&#39; ++ [a0]}} +
{a :: l = []}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span> exists_last.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Decompose a list in into a prefix <code>l'</code> and the last element <code>a</code>
  with an equation <code>Heq</code> stating that <code>l = l' ++ [a]</code>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Ltac</span> <span class="nf">destruct_list_last</span> l l&#39; a Heq :=
 <span class="nb">destruct</span> (has_last_or_null l) <span class="kr">as</span> [[l&#39; [a Heq]] | Heq]; <span class="nb">rewrite</span> Heq <span class="kr">in</span> *; <span class="nb">swap</span> <span class="mi">1</span> <span class="mi">2</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk7"><span class="kn">Lemma</span> <span class="nf">last_not_null</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
    l ++ [a] &lt;&gt; [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A), l ++ [a] â‰  []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A), l ++ [a] â‰  []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
Return the last element of the list if it's present and <span class="inlinecode"><span class="id" title="var">None</span></span> otherwise. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">last_error</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) : option A :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; None
  | a :: t =&gt; Some (List.<span class="nb">last</span> t a)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk9"><span class="kn">Lemma</span> <span class="nf">unfold_last_hd</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">random</span> <span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">l</span> : list A),
    List.<span class="nb">last</span> (a :: b :: l) random = List.<span class="nb">last</span> (b :: l) random.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">random</span> <span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">l</span> : list A),
  List.<span class="nb">last</span> (a :: b :: l) random =
  List.<span class="nb">last</span> (b :: l) random</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">random</span> <span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">l</span> : list A),
  List.<span class="nb">last</span> (a :: b :: l) random =
  List.<span class="nb">last</span> (b :: l) random</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb"><span class="kn">Lemma</span> <span class="nf">swap_head_last</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">random</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A) (<span class="nv">l</span> : list A),
    List.<span class="nb">last</span> (a :: b :: c :: l) random = List.<span class="nb">last</span> (b :: a :: c :: l) random.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">random</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A) (<span class="nv">l</span> : list A),
  List.<span class="nb">last</span> (a :: b :: c :: l) random =
  List.<span class="nb">last</span> (b :: a :: c :: l) random</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">random</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : A) (<span class="nv">l</span> : list A),
  List.<span class="nb">last</span> (a :: b :: c :: l) random =
  List.<span class="nb">last</span> (b :: a :: c :: l) random</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd"><span class="kn">Lemma</span> <span class="nf">remove_hd_last</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">hd1</span> <span class="nv">hd2</span> <span class="nv">d1</span> <span class="nv">d2</span> : A) (<span class="nv">tl</span> : list A),
    List.<span class="nb">last</span> (hd1 :: hd2 :: tl) d1 = List.<span class="nb">last</span> (hd2 :: tl) d2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">hd1</span> <span class="nv">hd2</span> <span class="nv">d1</span> <span class="nv">d2</span> : A) (<span class="nv">tl</span> : list A),
  List.<span class="nb">last</span> (hd1 :: hd2 :: tl) d1 =
  List.<span class="nb">last</span> (hd2 :: tl) d2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">hd1</span> <span class="nv">hd2</span> <span class="nv">d1</span> <span class="nv">d2</span> : A) (<span class="nv">tl</span> : list A),
  List.<span class="nb">last</span> (hd1 :: hd2 :: tl) d1 =
  List.<span class="nb">last</span> (hd2 :: tl) d2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf"><span class="nb">induction</span> tl; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>hd1, hd2, d1, d2, a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>tl</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHtl</var><span class="hyp-type"><b>: </b><span>List.<span class="nb">last</span> (hd1 :: hd2 :: tl) d1 =
List.<span class="nb">last</span> (hd2 :: tl) d2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> tl <span class="kr">with</span>
| [] =&gt; a
| _ :: _ =&gt; List.<span class="nb">last</span> tl d1
<span class="kr">end</span> =
<span class="kr">match</span> tl <span class="kr">with</span>
| [] =&gt; a
| _ :: _ =&gt; List.<span class="nb">last</span> tl d2
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> tl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk10"><span class="kn">Lemma</span> <span class="nf">unroll_last</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">random</span> <span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
    List.<span class="nb">last</span> (a :: l) random = List.<span class="nb">last</span> l a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">random</span> <span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  List.<span class="nb">last</span> (a :: l) random = List.<span class="nb">last</span> l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk11"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">random</span> <span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  List.<span class="nb">last</span> (a :: l) random = List.<span class="nb">last</span> l a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk12"><span class="nb">induction</span> l <span class="kr">as</span> [| h [| h&#39; t]]; [<span class="bp">done</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>random, a, h, h'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>List.<span class="nb">last</span> (a :: h&#39; :: t) random =
List.<span class="nb">last</span> (h&#39; :: t) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.<span class="nb">last</span> (a :: h :: h&#39; :: t) random =
List.<span class="nb">last</span> (h :: h&#39; :: t) a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> swap_head_last, unfold_last_hd, IHl, unfold_last_hd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk13"><span class="kn">Lemma</span> <span class="nf">last_app</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">def</span> : A),
    List.<span class="nb">last</span> (l1 ++ l2) def = List.<span class="nb">last</span> l2 (List.<span class="nb">last</span> l1 def).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">def</span> : A),
  List.<span class="nb">last</span> (l1 ++ l2) def =
  List.<span class="nb">last</span> l2 (List.<span class="nb">last</span> l1 def)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk14"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">def</span> : A),
  List.<span class="nb">last</span> (l1 ++ l2) def =
  List.<span class="nb">last</span> l2 (List.<span class="nb">last</span> l1 def)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk15"><span class="nb">induction</span> l1; <span class="nb">intros</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l2</span> : list A) (<span class="nv">def</span> : A),
  List.<span class="nb">last</span> (l1 ++ l2) def =
  List.<span class="nb">last</span> l2 (List.<span class="nb">last</span> l1 def)</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>def</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.<span class="nb">last</span> ((a :: l1) ++ l2) def =
List.<span class="nb">last</span> l2 (List.<span class="nb">last</span> (a :: l1) def)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- !app_comm_cons, !unroll_last.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk16"><span class="kn">Lemma</span> <span class="nf">last_map</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">t</span> : list A) (<span class="nv">h</span> : A) (<span class="nv">def</span> : B),
    List.<span class="nb">last</span> (map f (h :: t)) def = f (List.<span class="nb">last</span> t h).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ B) (<span class="nv">t</span> : list A) (<span class="nv">h</span> : A) (<span class="nv">def</span> : B),
  List.<span class="nb">last</span> (map f (h :: t)) def = f (List.<span class="nb">last</span> t h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ B) (<span class="nv">t</span> : list A) (<span class="nv">h</span> : A) (<span class="nv">def</span> : B),
  List.<span class="nb">last</span> (map f (h :: t)) def = f (List.<span class="nb">last</span> t h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk18"><span class="nb">induction</span> t; <span class="nb">intros</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">h</span> : A) (<span class="nv">def</span> : B), List.<span class="nb">last</span> (map f (h :: t)) def = f (List.<span class="nb">last</span> t h)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>def</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.<span class="nb">last</span> (map f (h :: a :: t)) def =
f (List.<span class="nb">last</span> (a :: t) h)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> map_cons, !unroll_last.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk19"><span class="kn">Lemma</span> <span class="nf">last_error_some</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">s</span> <span class="nv">random</span> : A) (<span class="nv">Herr</span> : last_error l = Some s),
    List.<span class="nb">last</span> l random = s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">s</span> <span class="nv">random</span> : A),
  last_error l = Some s â†’ List.<span class="nb">last</span> l random = s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">s</span> <span class="nv">random</span> : A),
  last_error l = Some s â†’ List.<span class="nb">last</span> l random = s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> l; [| <span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">apply</span> unroll_last].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b"><span class="kn">Lemma</span> <span class="nf">incl_singleton</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
    l âŠ† [a] -&gt; <span class="kr">forall</span> <span class="nv">b</span> : A, b âˆˆ l -&gt; b = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  l âŠ† [a] â†’ <span class="kr">âˆ€</span> <span class="nv">b</span> : A, b âˆˆ l â†’ b = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  l âŠ† [a] â†’ <span class="kr">âˆ€</span> <span class="nv">b</span> : A, b âˆˆ l â†’ b = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d"><span class="nb">intros</span> * Hsub * Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>l âŠ† [a]</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>b âˆˆ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> elem_of_list_singleton, Hsub.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e"><span class="kn">Lemma</span> <span class="nf">Exists_first</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, Decision (P a)) (<span class="nv">l</span> : list A),
    Exists P l -&gt;
    <span class="kr">exists</span> (<span class="nv">prefix</span> : list A) (<span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
      P <span class="kp">first</span> /\
      l = prefix ++ [<span class="kp">first</span>] ++ suffix /\
      ~ Exists P prefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a))
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A,
      Exists P l
      â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
          P <span class="kp">first</span>
          âˆ§ l = prefix ++ [<span class="kp">first</span>] ++ suffix
            âˆ§ Â¬ Exists P prefix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a))
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A,
      Exists P l
      â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
          P <span class="kp">first</span>
          âˆ§ l = prefix ++ [<span class="kp">first</span>] ++ suffix
            âˆ§ Â¬ Exists P prefix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk20"><span class="nb">induction</span> l <span class="kr">as</span> [| h t]; <span class="nb">intros</span> Hex; [<span class="bp">by</span> <span class="nb">inversion</span> Hex |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists P (h :: t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  P <span class="kp">first</span>
  âˆ§ h :: t = prefix ++ [<span class="kp">first</span>] ++ suffix
    âˆ§ Â¬ Exists P prefix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk21"><span class="nb">destruct</span> (decide (P h)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists P (h :: t)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  P <span class="kp">first</span>
  âˆ§ h :: t = prefix ++ [<span class="kp">first</span>] ++ suffix
    âˆ§ Â¬ Exists P prefix</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists P (h :: t)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P h</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk22"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  P <span class="kp">first</span>
  âˆ§ h :: t = prefix ++ [<span class="kp">first</span>] ++ suffix
    âˆ§ Â¬ Exists P prefix</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk23">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists P (h :: t)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  P <span class="kp">first</span>
  âˆ§ h :: t = prefix ++ [<span class="kp">first</span>] ++ suffix
    âˆ§ Â¬ Exists P prefix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk24"><span class="kr">exists</span> [], t, h.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists P (h :: t)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P h âˆ§ h :: t = [] ++ [h] ++ t âˆ§ Â¬ Exists P []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk25"><span class="nb">rewrite</span> Exists_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists P (h :: t)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P h âˆ§ h :: t = [] ++ [h] ++ t âˆ§ Â¬ <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk26">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists P (h :: t)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  P <span class="kp">first</span>
  âˆ§ h :: t = prefix ++ [<span class="kp">first</span>] ++ suffix
    âˆ§ Â¬ Exists P prefix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk27"><span class="nb">apply</span> Exists_cons <span class="kr">in</span> Hex <span class="kr">as</span> []; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P t
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
    P <span class="kp">first</span>
    âˆ§ t = prefix ++ [<span class="kp">first</span>] ++ suffix
      âˆ§ Â¬ Exists P prefix</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P t</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  P <span class="kp">first</span>
  âˆ§ h :: t = prefix ++ [<span class="kp">first</span>] ++ suffix
    âˆ§ Â¬ Exists P prefix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk28"><span class="nb">destruct</span> (IHt H) <span class="kr">as</span> (prefix &amp; suffix &amp; <span class="kp">first</span> &amp; p &amp; -&gt; &amp; Hnex).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>first</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P (prefix ++ [<span class="kp">first</span>] ++ suffix)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P (prefix ++ [<span class="kp">first</span>] ++ suffix)
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix0</span> <span class="nv">suffix0</span> : list A) (<span class="nv">first0</span> : A),
    P first0
    âˆ§ prefix ++ [<span class="kp">first</span>] ++ suffix =
      prefix0 ++ [first0] ++ suffix0
      âˆ§ Â¬ Exists P prefix0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P h</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P <span class="kp">first</span></span></span></span><br><span><var>Hnex</var><span class="hyp-type"><b>: </b><span>Â¬ Exists P prefix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> (<span class="nv">prefix0</span> <span class="nv">suffix0</span> : list A) (<span class="nv">first0</span> : A),
  P first0
  âˆ§ h :: prefix ++ [<span class="kp">first</span>] ++ suffix =
    prefix0 ++ [first0] ++ suffix0
    âˆ§ Â¬ Exists P prefix0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk29"><span class="kr">exists</span> (<span class="nv">h</span> :: prefix), suffix, <span class="kp">first</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>first</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P (prefix ++ [<span class="kp">first</span>] ++ suffix)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P (prefix ++ [<span class="kp">first</span>] ++ suffix)
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix0</span> <span class="nv">suffix0</span> : list A) (<span class="nv">first0</span> : A),
    P first0
    âˆ§ prefix ++ [<span class="kp">first</span>] ++ suffix =
      prefix0 ++ [first0] ++ suffix0
      âˆ§ Â¬ Exists P prefix0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P h</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P <span class="kp">first</span></span></span></span><br><span><var>Hnex</var><span class="hyp-type"><b>: </b><span>Â¬ Exists P prefix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="kp">first</span>
âˆ§ h :: prefix ++ [<span class="kp">first</span>] ++ suffix =
  (h :: prefix) ++ [<span class="kp">first</span>] ++ suffix
  âˆ§ Â¬ Exists P (h :: prefix)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk2a"><span class="nb">rewrite</span> Exists_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>first</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P (prefix ++ [<span class="kp">first</span>] ++ suffix)</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Exists P (prefix ++ [<span class="kp">first</span>] ++ suffix)
â†’ <span class="kr">âˆƒ</span> (<span class="nv">prefix0</span> <span class="nv">suffix0</span> : list A) (<span class="nv">first0</span> : A),
    P first0
    âˆ§ prefix ++ [<span class="kp">first</span>] ++ suffix =
      prefix0 ++ [first0] ++ suffix0
      âˆ§ Â¬ Exists P prefix0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P h</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P <span class="kp">first</span></span></span></span><br><span><var>Hnex</var><span class="hyp-type"><b>: </b><span>Â¬ Exists P prefix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="kp">first</span>
âˆ§ h :: prefix ++ [<span class="kp">first</span>] ++ suffix =
  (h :: prefix) ++ [<span class="kp">first</span>] ++ suffix
  âˆ§ Â¬ (P h âˆ¨ Exists P prefix)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk2b"><span class="kn">Lemma</span> <span class="nf">map_list_subseteq</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    l1 âŠ† l2 -&gt; map f l1 âŠ† map f l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ B) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  l1 âŠ† l2 â†’ map f l1 âŠ† map f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk2c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ B) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  l1 âŠ† l2 â†’ map f l1 âŠ† map f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk2d"><span class="nb">unfold</span> subseteq, list_subseteq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ B) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l1 â†’ x âˆˆ l2)
  â†’ <span class="kr">âˆ€</span> <span class="nv">x</span> : B, x âˆˆ map f l1 â†’ x âˆˆ map f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk2e"><span class="nb">intros</span> * Hsub b Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l1 â†’ x âˆˆ l2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>b âˆˆ map f l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b âˆˆ map f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk2f"><span class="nb">rewrite</span> elem_of_list_fmap <span class="kr">in</span> Hin |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l1 â†’ x âˆˆ l2</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">y</span> : A, b = f y âˆ§ y âˆˆ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">y</span> : A, b = f y âˆ§ y âˆˆ l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk30"><span class="nb">destruct</span> Hin <span class="kr">as</span> (x &amp; -&gt; &amp; Hin&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l1 â†’ x âˆˆ l2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin'</var><span class="hyp-type"><b>: </b><span>x âˆˆ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">y</span> : A, f x = f y âˆ§ y âˆˆ l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk31"><span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ B</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l1 â†’ x âˆˆ l2</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin'</var><span class="hyp-type"><b>: </b><span>x âˆˆ l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x = f x âˆ§ x âˆˆ l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [| <span class="nb">apply</span> Hsub].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk32"><span class="kn">Lemma</span> <span class="nf">app_cons</span> {<span class="nv">A</span>} :
  <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
    [a] ++ l = a :: l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A), [a] ++ l = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk33"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A), [a] ++ l = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk34"><span class="kn">Lemma</span> <span class="nf">last_error_is_last</span> {<span class="nv">A</span>} :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A),
    last_error (l ++ [x]) = Some x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A), last_error (l ++ [x]) = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk35"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">x</span> : A), last_error (l ++ [x]) = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk36"><span class="nb">intros</span> [] x; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (List.<span class="nb">last</span> (l ++ [x]) a) = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> last_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk37"><span class="kn">Lemma</span> <span class="nf">nth_error_last</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">Hlast</span> : S n = length l) (<span class="nv">_last</span> : A),
    nth_error l n = Some (List.<span class="nb">last</span> l _last).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  S n = length l
  â†’ <span class="kr">âˆ€</span> <span class="nv">_last</span> : A,
      nth_error l n = Some (List.<span class="nb">last</span> l _last)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  S n = length l
  â†’ <span class="kr">âˆ€</span> <span class="nv">_last</span> : A,
      nth_error l n = Some (List.<span class="nb">last</span> l _last)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk39"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span>S n = length l</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l n = Some (List.<span class="nb">last</span> l _last)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk3a">destruct_list_last l h t Heq; [<span class="bp">by</span> <span class="nb">destruct</span> n |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l, h</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span>S n = length (h ++ [t])</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>l = h ++ [t]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (h ++ [t]) n =
Some (List.<span class="nb">last</span> (h ++ [t]) _last)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk3b"><span class="nb">rewrite</span> app_length <span class="kr">in</span> Hlast; <span class="nb">cbn</span> <span class="kr">in</span> Hlast.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l, h</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span>S n = length h + <span class="mi">1</span></span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>l = h ++ [t]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (h ++ [t]) n =
Some (List.<span class="nb">last</span> (h ++ [t]) _last)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk3c"><span class="nb">rewrite</span> nth_error_app2, last_app <span class="bp">by</span> <span class="bp">lia</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l, h</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span>S n = length h + <span class="mi">1</span></span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>l = h ++ [t]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error [t] (n - length h) = Some t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">replace</span> (n - length h) <span class="kr">with</span> <span class="mi">0</span> <span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk3d"><span class="kn">Lemma</span> <span class="nf">take_prefix</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
    n1 &lt;= n2 -&gt; take n1 (take n2 l) = take n1 l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
  n1 â‰¤ n2 â†’ take n1 (take n2 l) = take n1 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk3e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
  n1 â‰¤ n2 â†’ take n1 (take n2 l) = take n1 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">rewrite</span> take_take, min_l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk3f"><span class="kn">Lemma</span> <span class="nf">prefix_of_take</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
    take n l `prefix_of` l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  take n l `prefix_of` l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk40"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  take n l `prefix_of` l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eexists</span>; <span class="nb">symmetry</span>; <span class="nb">apply</span> take_drop.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Compute the sublist of list <code>l</code> which starts at index <code>n1</code>
  and ends before index <code>n2</code>.
  For example, <code>list_segment [0; 1; 2; 3; 4; 5] 2 4 = [2; 3]</code>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">list_segment</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat) : list A :=
  drop n1 (take n2 l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk41"><span class="kn">Lemma</span> <span class="nf">take_segment_suffix</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
    n1 &lt;= n2 -&gt; take n1 l ++ list_segment l n1 n2 ++ drop n2 l = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
  n1 â‰¤ n2
  â†’ take n1 l ++ list_segment l n1 n2 ++ drop n2 l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
  n1 â‰¤ n2
  â†’ take n1 l ++ list_segment l n1 n2 ++ drop n2 l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk43"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n1 l ++ list_segment l n1 n2 ++ drop n2 l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk44"><span class="nb">unfold</span> list_segment.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n1 l ++ drop n1 (take n2 l) ++ drop n2 l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk45"><span class="nb">rewrite</span> &lt;- (take_drop n2 l) <span class="nb">at</span> <span class="mi">4</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n1 l ++ drop n1 (take n2 l) ++ drop n2 l =
take n2 l ++ drop n2 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk46"><span class="nb">rewrite</span> &lt;- (take_drop n1 (take n2 l)) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n1 l ++ drop n1 (take n2 l) ++ drop n2 l =
(take n1 (take n2 l) ++ drop n1 (take n2 l)) ++
drop n2 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- app_assoc, take_prefix.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Annotate each element of a list with the proof that it satisfies the
  given decidable predicate.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">list_annotate</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>} {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)} {<span class="nv">l</span> : list A}
   : Forall P l -&gt; list (dsig P) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; []
  | h :: t =&gt; <span class="kr">fun</span> <span class="nv">Hs</span> =&gt; dexist h (Forall_inv Hs) :: list_annotate (Forall_inv_tail Hs)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_list_annotate_props</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  {<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>}
  `{Pdec : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)}
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk47"><span class="kn">Lemma</span> <span class="nf">list_annotate_length</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
    length (list_annotate Hs) = length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  length (list_annotate Hs) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk48"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  length (list_annotate Hs) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span>; [| <span class="nb">rewrite</span> IHl].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk49"><span class="kn">Lemma</span> <span class="nf">list_annotate_pi</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l) (<span class="nv">Hs&#39;</span> : Forall P l),
    list_annotate Hs = list_annotate Hs&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> <span class="nv">Hs&#39;</span> : Forall P l),
  list_annotate Hs = list_annotate Hs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> <span class="nv">Hs&#39;</span> : Forall P l),
  list_annotate Hs = list_annotate Hs&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk4b"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">Hs</span> <span class="nv">Hs&#39;</span> : Forall P l,
  list_annotate Hs = list_annotate Hs&#39;</span></span></span><br><span><var>Hs, Hs'</var><span class="hyp-type"><b>: </b><span>Forall P (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dexist a (Forall_inv Hs)
:: list_annotate (Forall_inv_tail Hs) =
dexist a (Forall_inv Hs&#39;)
:: list_annotate (Forall_inv_tail Hs&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">f_equal</span>; [<span class="nb">apply</span> dsig_eq | <span class="nb">apply</span> IHl].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk4c"><span class="kn">Lemma</span> <span class="nf">list_annotate_eq</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">Hl1</span> : Forall P l1) (<span class="nv">Hl2</span> : Forall P l2),
    list_annotate Hl1 = list_annotate Hl2 &lt;-&gt; l1 = l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">Hl1</span> : Forall P l1) (<span class="nv">Hl2</span> : Forall P
                                                l2),
  list_annotate Hl1 = list_annotate Hl2 â†” l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk4d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">Hl1</span> : Forall P l1) (<span class="nv">Hl2</span> : Forall P
                                                l2),
  list_annotate Hl1 = list_annotate Hl2 â†” l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk4e"><span class="nb">split</span>; [| <span class="bp">by</span> <span class="nb">intros</span> -&gt;; <span class="nb">apply</span> list_annotate_pi].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>Forall P l1</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>Forall P l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_annotate Hl1 = list_annotate Hl2 â†’ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk4f"><span class="nb">revert</span> l2 Hl1 Hl2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l2</span> : list A) (<span class="nv">Hl1</span> : Forall P l1) (<span class="nv">Hl2</span> : Forall P l2),
  list_annotate Hl1 = list_annotate Hl2 â†’ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk50"><span class="nb">induction</span> l1 <span class="kr">as</span> [| h1 t1]; <span class="nb">intros</span> [| h2 t2] * Heq; [<span class="bp">done</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l2</span> : list A) (<span class="nv">Hl1</span> : Forall P t1) 
  (<span class="nv">Hl2</span> : Forall P l2),
  list_annotate Hl1 = list_annotate Hl2
  â†’ t1 = l2</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>Forall P (h1 :: t1)</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>Forall P (h2 :: t2)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>list_annotate Hl1 = list_annotate Hl2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h1 :: t1 = h2 :: t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk51"><span class="nb">inversion</span> Heq; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l2</span> : list A) (<span class="nv">Hl1</span> : Forall P t1) 
  (<span class="nv">Hl2</span> : Forall P l2),
  list_annotate Hl1 = list_annotate Hl2
  â†’ t1 = l2</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>Forall P (h2 :: t1)</span></span></span><br><span><var>Hl2</var><span class="hyp-type"><b>: </b><span>Forall P (h2 :: t2)</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>list_annotate Hl1 = list_annotate Hl2</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>list_annotate (Forall_inv_tail Hl1) =
list_annotate (Forall_inv_tail Hl2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h2 :: t1 = h2 :: t2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHt1 <span class="kr">in</span> H1 <span class="kr">as</span> -&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk52"><span class="kn">Lemma</span> <span class="nf">list_annotate_app</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">Hs</span> : Forall P (l1 ++ l2)),
    list_annotate Hs =
    list_annotate (proj1 (proj1 (@Forall_app _ P l1 l2) Hs)) ++
    list_annotate (proj2 (proj1 (@Forall_app _ P l1 l2) Hs)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">Hs</span> : Forall P (l1 ++ l2)),
  list_annotate Hs =
  list_annotate
    (proj1 (proj1 (Forall_app P l1 l2) Hs)) ++
  list_annotate
    (proj2 (proj1 (Forall_app P l1 l2) Hs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A) (<span class="nv">Hs</span> : Forall P (l1 ++ l2)),
  list_annotate Hs =
  list_annotate
    (proj1 (proj1 (Forall_app P l1 l2) Hs)) ++
  list_annotate
    (proj2 (proj1 (Forall_app P l1 l2) Hs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk54"><span class="nb">induction</span> l1; <span class="nb">cbn</span>; <span class="nb">intros</span>; [<span class="bp">by</span> <span class="nb">apply</span> list_annotate_pi |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l2</span> : list A) (<span class="nv">Hs</span> : Forall P (l1 ++ l2)),
  list_annotate Hs =
  list_annotate
    (proj1 (proj1 (Forall_app P l1 l2) Hs)) ++
  list_annotate
    (proj2 (proj1 (Forall_app P l1 l2) Hs))</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (a :: l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dexist a (Forall_inv Hs)
:: list_annotate (Forall_inv_tail Hs) =
dexist a
  (Forall_inv
     (proj1 (proj1 (Forall_app P (a :: l1) l2) Hs)))
:: list_annotate
     (Forall_inv_tail
        (proj1 (proj1 (Forall_app P (a :: l1) l2) Hs))) ++
   list_annotate
     (proj2 (proj1 (Forall_app P (a :: l1) l2) Hs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk55"><span class="nb">f_equal</span>; [<span class="bp">by</span> <span class="nb">apply</span> dsig_eq |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l2</span> : list A) (<span class="nv">Hs</span> : Forall P (l1 ++ l2)),
  list_annotate Hs =
  list_annotate
    (proj1 (proj1 (Forall_app P l1 l2) Hs)) ++
  list_annotate
    (proj2 (proj1 (Forall_app P l1 l2) Hs))</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (a :: l1 ++ l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_annotate (Forall_inv_tail Hs) =
list_annotate
  (Forall_inv_tail
     (proj1 (proj1 (Forall_app P (a :: l1) l2) Hs))) ++
list_annotate
  (proj2 (proj1 (Forall_app P (a :: l1) l2) Hs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHl1; <span class="nb">f_equal</span>; <span class="nb">apply</span> list_annotate_pi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk56"><span class="kn">Lemma</span> <span class="nf">nth_error_list_annotate</span> :
  <span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
    <span class="kr">exists</span> (<span class="nv">oa</span> : option (dsig P)),
      nth_error (list_annotate Hs) n = oa /\ option_map (@proj1_sig _ _) oa = nth_error l n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  <span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
    nth_error (list_annotate Hs) n = oa
    âˆ§ option_map proj1_sig oa = nth_error l n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  <span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
    nth_error (list_annotate Hs) n = oa
    âˆ§ option_map proj1_sig oa = nth_error l n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk58"><span class="nb">induction</span> n <span class="kr">as</span> [| n&#39;]; <span class="nb">intros</span> [| h t] Hs; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  None = oa âˆ§ option_map proj1_sig oa = None</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (h :: t)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk59"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  Some (dexist h (Forall_inv Hs)) = oa
  âˆ§ option_map proj1_sig oa = Some h</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  <span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
    nth_error (list_annotate Hs) n&#39; = oa
    âˆ§ option_map proj1_sig oa = nth_error l n&#39;</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P []</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk5a"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  None = oa âˆ§ option_map proj1_sig oa = None</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk5b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  <span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
    nth_error (list_annotate Hs) n&#39; = oa
    âˆ§ option_map proj1_sig oa = nth_error l n&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (h :: t)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk5b"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  nth_error (list_annotate (Forall_inv_tail Hs)) n&#39; =
  oa âˆ§ option_map proj1_sig oa = nth_error t n&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk5c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  None = oa âˆ§ option_map proj1_sig oa = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">None</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk5d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (h :: t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  Some (dexist h (Forall_inv Hs)) = oa
  âˆ§ option_map proj1_sig oa = Some h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk5e"><span class="nb">inversion</span> Hs; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (h :: t)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Forall P t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  Some (dexist h (Forall_inv Hs)) = oa
  âˆ§ option_map proj1_sig oa = Some h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Some</span> (dexist h (Forall_inv Hs))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk5f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  <span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
    nth_error (list_annotate Hs) n&#39; = oa
    âˆ§ option_map proj1_sig oa = nth_error l n&#39;</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  None = oa âˆ§ option_map proj1_sig oa = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">None</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk60">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  <span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
    nth_error (list_annotate Hs) n&#39; = oa
    âˆ§ option_map proj1_sig oa = nth_error l n&#39;</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (h :: t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">oa</span> : option (dsig P),
  nth_error (list_annotate (Forall_inv_tail Hs)) n&#39; =
  oa âˆ§ option_map proj1_sig oa = nth_error t n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk61"><span class="kn">Lemma</span> <span class="nf">elem_of_list_annotate</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l) (<span class="nv">a</span> : {x : A | bool_decide (P x)}),
    a âˆˆ list_annotate Hs &lt;-&gt; `a âˆˆ l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l) (<span class="nv">a</span> : {x : A
                                      | bool_decide
                                          (P x)}),
  a âˆˆ list_annotate Hs â†” `a âˆˆ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l) (<span class="nv">a</span> : {x : A
                                      | bool_decide
                                          (P x)}),
  a âˆˆ list_annotate Hs â†” `a âˆˆ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk63"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P []</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{x : A | bool_decide (P x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a âˆˆ [] â†” `a âˆˆ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">Hs</span> : Forall P l) (<span class="nv">a</span> : 
                     {x : A | 
                     bool_decide (P x)}),
  a âˆˆ list_annotate Hs â†” `a âˆˆ l</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (a :: l)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>{x : A | bool_decide (P x)}</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk64"><hr></label><div class="goal-conclusion">a0
âˆˆ dexist a (Forall_inv Hs)
  :: list_annotate (Forall_inv_tail Hs) â†” 
`a0 âˆˆ a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P []</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>{x : A | bool_decide (P x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a âˆˆ [] â†” `a âˆˆ []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !elem_of_nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">Hs</span> : Forall P l) (<span class="nv">a</span> : 
                     {x : A | 
                     bool_decide (P x)}),
  a âˆˆ list_annotate Hs â†” `a âˆˆ l</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (a :: l)</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>{x : A | bool_decide (P x)}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0
âˆˆ dexist a (Forall_inv Hs)
  :: list_annotate (Forall_inv_tail Hs) â†” `a0 âˆˆ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !elem_of_cons, IHl, (dsig_eq P a0); <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk67"><span class="kn">Lemma</span> <span class="nf">list_annotate_NoDup</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
    NoDup l -&gt; NoDup (list_annotate Hs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  NoDup l â†’ NoDup (list_annotate Hs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk68"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  NoDup l â†’ NoDup (list_annotate Hs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk69"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">cbn</span>; <span class="nb">constructor</span>; [| <span class="bp">by</span> <span class="nb">apply</span> IHNoDup].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Forall P (x :: l)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x âˆ‰ l</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>IHNoDup</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">Hs</span> : Forall P l, NoDup (list_annotate Hs)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dexist x (Forall_inv Hs)
âˆ‰ list_annotate (Forall_inv_tail Hs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> elem_of_list_annotate.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk6a"><span class="kn">Lemma</span> <span class="nf">list_annotate_forget</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
    map proj1_sig (list_annotate Hs) = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  map proj1_sig (list_annotate Hs) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk6b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hs</span> : Forall P l),
  map proj1_sig (list_annotate Hs) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span>; [| <span class="nb">rewrite</span> IHl].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_list_annotate_props</span>.</span></span></pre><div class="doc">
  Compute the index of the <code>n</code>-th element of the list that satisfies the
  predicate <code>P</code>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">nth_error_filter_index</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)}
  (l : list A) (n : nat) : option nat :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; None
  | h :: t =&gt;
    <span class="kr">if</span> decide (P h) <span class="kr">then</span>
      <span class="kr">match</span> n <span class="kr">with</span>
      | <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
      | S n&#39; =&gt; option_map S (nth_error_filter_index P t n&#39;)
      <span class="kr">end</span>
    <span class="kr">else</span>
      option_map S (nth_error_filter_index P t n)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk6c"><span class="kn">Lemma</span> <span class="nf">nth_error_filter_index_le</span> `{<span class="kr">forall</span> (<span class="nv">x</span> : A), Decision (P x)} :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat),
    n1 &lt;= n2 -&gt;
    nth_error_filter_index P l n1 = Some in1 -&gt;
    nth_error_filter_index P l n2 = Some in2 -&gt;
      in1 &lt;= in2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat),
  n1 â‰¤ n2
  â†’ nth_error_filter_index P l n1 = Some in1
    â†’ nth_error_filter_index P l n2 = Some in2
      â†’ in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat),
  n1 â‰¤ n2
  â†’ nth_error_filter_index P l n1 = Some in1
    â†’ nth_error_filter_index P l n2 = Some in2
      â†’ in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk6e"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span> * Hle Hin1 Hin2; [<span class="bp">by</span> <span class="nb">inversion</span> Hin1 |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (P a)
 <span class="kr">then</span>
  <span class="kr">match</span> n1 <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
  | S n&#39; =&gt;
      option_map S
        (nth_error_filter_index P l n&#39;)
  <span class="kr">end</span>
 <span class="kr">else</span>
  option_map S (nth_error_filter_index P l n1)) =
Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> decide (P a)
 <span class="kr">then</span>
  <span class="kr">match</span> n2 <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
  | S n&#39; =&gt;
      option_map S
        (nth_error_filter_index P l n&#39;)
  <span class="kr">end</span>
 <span class="kr">else</span>
  option_map S (nth_error_filter_index P l n2)) =
Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk6f"><span class="nb">destruct</span> (decide (P a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> n1 <span class="kr">with</span>
| <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
| S n&#39; =&gt;
    option_map S
      (nth_error_filter_index P l n&#39;)
<span class="kr">end</span> = Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> n2 <span class="kr">with</span>
| <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
| S n&#39; =&gt;
    option_map S
      (nth_error_filter_index P l n&#39;)
<span class="kr">end</span> = Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
  n1 â‰¤ n2
  â†’ nth_error_filter_index P l n1 = Some in1
    â†’ nth_error_filter_index P l n2 = Some in2
      â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n1) =
Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n2) =
Some in2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk70"><hr></label><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk71">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> n1 <span class="kr">with</span>
| <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
| S n&#39; =&gt;
    option_map S
      (nth_error_filter_index P l n&#39;)
<span class="kr">end</span> = Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> n2 <span class="kr">with</span>
| <span class="mi">0</span> =&gt; Some <span class="mi">0</span>
| S n&#39; =&gt;
    option_map S
      (nth_error_filter_index P l n&#39;)
<span class="kr">end</span> = Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk72"><span class="nb">destruct</span> n1, n2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> â‰¤ <span class="mi">0</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
  n1 â‰¤ n2
  â†’ nth_error_filter_index P l n1 = Some in1
    â†’ nth_error_filter_index P l n2 = Some in2
      â†’ in1 â‰¤ in2</span></span></span><br><span><var>n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> â‰¤ S n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n2) =
Some in2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk73"><hr></label><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
  n1 â‰¤ n2
  â†’ nth_error_filter_index P l n1 = Some in1
    â†’ nth_error_filter_index P l n2 = Some in2
      â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>S n1 â‰¤ <span class="mi">0</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n1) =
Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk74"><hr></label><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk75" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
  n1 â‰¤ n2
  â†’ nth_error_filter_index P l n1 = Some in1
    â†’ nth_error_filter_index P l n2 = Some in2
      â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>S n1 â‰¤ S n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n1) =
Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n2) =
Some in2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk75"><hr></label><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk76">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> â‰¤ <span class="mi">0</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk77">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> â‰¤ S n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n2) =
Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hin1; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk78">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>S n1 â‰¤ <span class="mi">0</span></span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n1) =
Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>Some <span class="mi">0</span> = Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk79">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>S n1 â‰¤ S n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n1) =
Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n2) =
Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk7a"><span class="nb">unfold</span> option_map <span class="kr">in</span> Hin1, Hin2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>S n1 â‰¤ S n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> nth_error_filter_index P l n1 <span class="kr">with</span>
| Some a =&gt; Some (S a)
| None =&gt; None
<span class="kr">end</span> = Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> nth_error_filter_index P l n2 <span class="kr">with</span>
| Some a =&gt; Some (S a)
| None =&gt; None
<span class="kr">end</span> = Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk7b"><span class="nb">destruct</span> (nth_error_filter_index P l n1) <span class="nb">eqn</span>: Hin1&#39;; <span class="nb">inversion</span> Hin1;
        <span class="nb">subst</span>; <span class="nb">clear</span> Hin1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>S n1 â‰¤ S n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hin1'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n1 = Some n</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> nth_error_filter_index P l n2 <span class="kr">with</span>
| Some a =&gt; Some (S a)
| None =&gt; None
<span class="kr">end</span> = Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk7c"><span class="nb">destruct</span> (nth_error_filter_index P l n2) <span class="nb">eqn</span>: Hin2&#39;; <span class="nb">inversion</span> Hin2;
        <span class="nb">subst</span>; <span class="nb">clear</span> Hin2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>S n1 â‰¤ S n2</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hin1'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n1 = Some n</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hin2'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n2 = Some n0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n â‰¤ S n0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> le_n_S, IHl; <span class="nb">cycle</span> <span class="mi">1</span>; [<span class="bp">done</span>.. | <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk7d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in1, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P a</span></span></span><br><span><var>Hin1</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n1) =
Some in1</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n2) =
Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">in1 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk7e"><span class="nb">destruct</span> (nth_error_filter_index P l n1) <span class="nb">eqn</span>: Hin1&#39;; <span class="nb">inversion</span> Hin1;
      <span class="nb">subst</span>; <span class="nb">clear</span> Hin1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2, in2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hin1'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n1 = Some n0</span></span></span><br><span><var>Hin2</var><span class="hyp-type"><b>: </b><span>option_map S (nth_error_filter_index P l n2) =
Some in2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n0 â‰¤ in2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk7f"><span class="nb">destruct</span> (nth_error_filter_index P l n2) <span class="nb">eqn</span>: Hin2&#39;; <span class="nb">inversion</span> Hin2;
      <span class="nb">subst</span>; <span class="nb">clear</span> Hin2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">in1</span> <span class="nv">in2</span> : nat,
n1 â‰¤ n2
â†’ nth_error_filter_index P l n1 = Some in1
â†’ nth_error_filter_index P l n2 = Some in2 â†’ in1 â‰¤ in2</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Â¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hin1'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n1 = Some n0</span></span></span><br><span><var>n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hin2'</var><span class="hyp-type"><b>: </b><span>nth_error_filter_index P l n2 = Some n3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n0 â‰¤ S n3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> le_n_S, IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk80"><span class="kn">Lemma</span> <span class="nf">Forall_filter</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, Decision (P a)} (<span class="nv">l</span> : list A),
    Forall P (filter P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">l</span> : list A), Forall P (filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk81"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">l</span> : list A), Forall P (filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk82"><span class="nb">induction</span> l <span class="kr">as</span> [| h t]; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">constructor</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>Forall P (filter P t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall P
  (<span class="kr">if</span> decide (P h)
   <span class="kr">then</span> h :: filter P t
   <span class="kr">else</span> filter P t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> case_decide; [<span class="nb">constructor</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Compute the sublist of a list that contains only elements that satisfy the
  given decidable predicate. Each element of the resulting list is paired with
  the proof that it satisfies the predicate.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">filter_annotate</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, Decision (P a)}
  (<span class="nv">l</span> : list A) : list (dsig P) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | h :: t =&gt;
    <span class="kr">match</span> decide (P h) <span class="kr">with</span>
    | <span class="nb">left</span> p =&gt; dexist h p :: filter_annotate P t
    | <span class="nb">right</span> _ =&gt; filter_annotate P t
    <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk83"><span class="kn">Lemma</span> <span class="nf">filter_annotate_length</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, Decision (P a)} (<span class="nv">l</span> : list A),
    length (filter_annotate P l) = length (filter P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">l</span> : list A),
  length (filter_annotate P l) = length (filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk84"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">l</span> : list A),
  length (filter_annotate P l) = length (filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk85"><span class="nb">induction</span> l <span class="kr">as</span> [| h t]; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>length (filter_annotate P t) =
length (filter P t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  <span class="kr">match</span> decide (P h) <span class="kr">with</span>
  | <span class="nb">left</span> p =&gt; dexist h p :: filter_annotate P t
  | <span class="nb">right</span> _ =&gt; filter_annotate P t
  <span class="kr">end</span> =
length
  (<span class="kr">if</span> decide (P h)
   <span class="kr">then</span> h :: filter P t
   <span class="kr">else</span> filter P t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk86">case_decide; <span class="nb">cbn</span>; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>length (filter_annotate P t) =
length (filter P t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length (filter_annotate P t)) =
S (length (filter P t))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk87"><span class="kn">Lemma</span> <span class="nf">filter_annotate_unroll</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, Decision (P a)} (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
    filter_annotate P (a :: l) =
    <span class="kr">let</span> <span class="nv">fa</span> := filter_annotate P l <span class="kr">in</span>
    <span class="kr">match</span> decide (P a) <span class="kr">with</span>
    | <span class="nb">left</span> pa =&gt; dexist _ pa :: fa
    | _ =&gt; fa
    <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  filter_annotate P (a :: l) =
  (<span class="kr">let</span> <span class="nv">fa</span> := filter_annotate P l <span class="kr">in</span>
   <span class="kr">match</span> decide (P a) <span class="kr">with</span>
   | <span class="nb">left</span> pa =&gt; dexist a pa :: fa
   | <span class="nb">right</span> _ =&gt; fa
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk88"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  filter_annotate P (a :: l) =
  (<span class="kr">let</span> <span class="nv">fa</span> := filter_annotate P l <span class="kr">in</span>
   <span class="kr">match</span> decide (P a) <span class="kr">with</span>
   | <span class="nb">left</span> pa =&gt; dexist a pa :: fa
   | <span class="nb">right</span> _ =&gt; fa
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk89"><span class="kn">Lemma</span> <span class="nf">filter_annotate_app</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span> : A, Decision (P a)} (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    filter_annotate P (l1 ++ l2) = filter_annotate P l1 ++ filter_annotate P l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  filter_annotate P (l1 ++ l2) =
  filter_annotate P l1 ++ filter_annotate P l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk8a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                      Decision (P a)) 
  (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  filter_annotate P (l1 ++ l2) =
  filter_annotate P l1 ++ filter_annotate P l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk8b"><span class="nb">induction</span> l1; <span class="nb">cbn</span>; <span class="nb">intros</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  filter_annotate P (l1 ++ l2) =
  filter_annotate P l1 ++ filter_annotate P l2</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> decide (P a) <span class="kr">with</span>
| <span class="nb">left</span> p =&gt; dexist a p :: filter_annotate P (l1 ++ l2)
| <span class="nb">right</span> _ =&gt; filter_annotate P (l1 ++ l2)
<span class="kr">end</span> =
<span class="kr">match</span> decide (P a) <span class="kr">with</span>
| <span class="nb">left</span> p =&gt; dexist a p :: filter_annotate P l1
| <span class="nb">right</span> _ =&gt; filter_annotate P l1
<span class="kr">end</span> ++ filter_annotate P l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk8c">case_decide; <span class="nb">cbn</span>; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  filter_annotate P (l1 ++ l2) =
  filter_annotate P l1 ++ filter_annotate P l2</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">dexist a H :: filter_annotate P (l1 ++ l2) =
dexist a H
:: filter_annotate P l1 ++ filter_annotate P l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHl1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Filters a list through a predicate, then transforms each element using a
  function which depends on the fact that the predicate holds.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">list_filter_map</span>
  {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)}
  (<span class="nv">f</span> : dsig P -&gt; B) (<span class="nv">l</span> : list A) : list B :=
    map f (filter_annotate P l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk8d"><span class="kn">Lemma</span> <span class="nf">list_filter_map_app</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)}
    (<span class="nv">f</span> : dsig P -&gt; B) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
      list_filter_map P f (l1 ++ l2) = list_filter_map P f l1 ++ list_filter_map P f l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                        Decision (P a)) 
  (<span class="nv">f</span> : dsig P â†’ B) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  list_filter_map P f (l1 ++ l2) =
  list_filter_map P f l1 ++ list_filter_map P f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk8e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                        Decision (P a)) 
  (<span class="nv">f</span> : dsig P â†’ B) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  list_filter_map P f (l1 ++ l2) =
  list_filter_map P f l1 ++ list_filter_map P f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">unfold</span> list_filter_map; <span class="nb">rewrite</span> filter_annotate_app, map_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk8f"><span class="kn">Lemma</span> <span class="nf">take_nth</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">i</span> <span class="nv">n</span> : nat) (<span class="nv">s</span> : list A),
    i &lt; n -&gt; nth_error (take n s) i = nth_error s i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">i</span> <span class="nv">n</span> : nat) (<span class="nv">s</span> : list A),
  i &lt; n â†’ nth_error (take n s) i = nth_error s i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk90"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">i</span> <span class="nv">n</span> : nat) (<span class="nv">s</span> : list A),
  i &lt; n â†’ nth_error (take n s) i = nth_error s i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk91"><span class="nb">induction</span> i; <span class="nb">intros</span> n [| h t] []; <span class="nb">cbn</span>; [<span class="bp">done</span>.. | |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">s</span> : list A), i &lt; n â†’ nth_error (take n s) i = nth_error s i</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (take (S i) t) i = nth_error t i</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">s</span> : list A), i &lt; n â†’ nth_error (take n s) i = nth_error s i</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S (S i) â‰¤ m</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk92"><hr></label><div class="goal-conclusion">nth_error (take m t) i = nth_error t i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk93">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">s</span> : list A), i &lt; n â†’ nth_error (take n s) i = nth_error s i</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (take (S i) t) i = nth_error t i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHi; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk94">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">s</span> : list A), i &lt; n â†’ nth_error (take n s) i = nth_error s i</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S (S i) â‰¤ m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (take m t) i = nth_error t i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHi; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk95"><span class="kn">Lemma</span> <span class="nf">nth_error_length</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
    nth_error l n = Some a -&gt; S n &lt;= length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  nth_error l n = Some a â†’ S n â‰¤ length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk96"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  nth_error l n = Some a â†’ S n â‰¤ length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk97"><span class="nb">induction</span> n <span class="kr">as</span> [| n&#39;]; <span class="nb">intros</span> [| h t] a; <span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A),
  nth_error l n&#39; = Some a â†’ S n&#39; â‰¤ length l</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>nth_error (h :: t) (S n&#39;) = Some a</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>nth_error t n&#39; = Some a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (S n&#39;) â‰¤ S (length t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> le_n_S, IHn&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk98"><span class="kn">Lemma</span> <span class="nf">take_nth_last</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">nth</span> : A) (<span class="nv">Hnth</span> : nth_error l n = Some nth) (<span class="nv">_last</span> : A),
    nth = List.<span class="nb">last</span> (take (S n) l) _last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">nth</span> : A),
  nth_error l n = Some nth
  â†’ <span class="kr">âˆ€</span> <span class="nv">_last</span> : A, nth = List.<span class="nb">last</span> (take (S n) l) _last</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">nth</span> : A),
  nth_error l n = Some nth
  â†’ <span class="kr">âˆ€</span> <span class="nv">_last</span> : A, nth = List.<span class="nb">last</span> (take (S n) l) _last</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk9a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some nth</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth = List.<span class="nb">last</span> (take (S n) l) _last</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk9b"><span class="nb">apply</span> Some_inj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some nth</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some nth = Some (List.<span class="nb">last</span> (take (S n) l) _last)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk9c"><span class="nb">erewrite</span> &lt;- Hnth, &lt;- nth_error_last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some nth</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l n = nth_error (take (S n) l) <span class="nl">?n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some nth</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk9d"><hr></label><div class="goal-conclusion">S <span class="nl">?n</span> = length (take (S n) l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk9e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some nth</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l n = nth_error (take (S n) l) <span class="nl">?n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> take_nth; [<span class="bp">done</span> | <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk9f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some nth</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n = length (take (S n) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka0"><span class="nb">rewrite</span> take_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>nth</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some nth</span></span></span><br><span><var>_last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S n = S n `min` length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> nth_error_length <span class="kr">in</span> Hnth; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka1"><span class="kn">Lemma</span> <span class="nf">drop_S_tail</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
    drop (S n) l = drop n (tail l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  drop (S n) l = drop n (tail l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  drop (S n) l = drop n (tail l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> A [] n; <span class="nb">cbn</span>; [<span class="nb">rewrite</span> drop_nil |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka3"><span class="kn">Lemma</span> <span class="nf">drop_tail_comm</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
    drop n (tail l) = tail (drop n l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  drop n (tail l) = tail (drop n l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  drop n (tail l) = tail (drop n l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka5"><span class="nb">intros</span> A l n; <span class="nb">revert</span> l; <span class="nb">induction</span> n; <span class="nb">intros</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop <span class="mi">0</span> (tail l) = tail (drop <span class="mi">0</span> l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chka6"><hr></label><div class="goal-conclusion">drop (S n) (tail l) = tail (drop (S n) l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop <span class="mi">0</span> (tail l) = tail (drop <span class="mi">0</span> l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !drop_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) (tail l) = tail (drop (S n) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !drop_S_tail, IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chka9"><span class="kn">Lemma</span> <span class="nf">drop_lookup</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">s</span> : list A) (<span class="nv">n</span> <span class="nv">i</span> : nat),
    n &lt;= i -&gt; drop n s !! (i - n) = s !! i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list A) (<span class="nv">n</span> <span class="nv">i</span> : nat),
  n â‰¤ i â†’ drop n s !! (i - n) = s !! i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkaa"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">s</span> : list A) (<span class="nv">n</span> <span class="nv">i</span> : nat),
  n â‰¤ i â†’ drop n s !! (i - n) = s !! i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkab"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n â‰¤ i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n s !! (i - n) = s !! i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkac"><span class="nb">rewrite</span> lookup_drop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n â‰¤ i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">s !! (n + (i - n)) = s !! i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">replace</span> (n + (i - n)) <span class="kr">with</span> i <span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkad"><span class="kn">Lemma</span> <span class="nf">drop_nth</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">i</span> <span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
    n &lt;= i -&gt; nth_error (drop n l) (i - n) = nth_error l i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">i</span> <span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  n â‰¤ i â†’ nth_error (drop n l) (i - n) = nth_error l i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">i</span> <span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  n â‰¤ i â†’ nth_error (drop n l) (i - n) = nth_error l i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkaf"><span class="nb">induction</span> i; <span class="nb">intros</span> [| n&#39;] [| h t] Hi; <span class="nb">cbn</span>; <span class="kp">try</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>S n&#39; â‰¤ <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> drop n&#39; t <span class="kr">with</span>
| [] =&gt; None
| x :: _ =&gt; Some x
<span class="kr">end</span> = Some h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
n â‰¤ i â†’ nth_error (drop n l) (i - n) = nth_error l i</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>S n&#39; â‰¤ S i</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chkb0"><hr></label><div class="goal-conclusion">nth_error [] (i - n&#39;) = None</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chkb1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
n â‰¤ i â†’ nth_error (drop n l) (i - n) = nth_error l i</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>S n&#39; â‰¤ S i</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chkb1"><hr></label><div class="goal-conclusion">nth_error (drop n&#39; t) (i - n&#39;) = nth_error t i</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>S n&#39; â‰¤ <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> drop n&#39; t <span class="kr">with</span>
| [] =&gt; None
| x :: _ =&gt; Some x
<span class="kr">end</span> = Some h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hi.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
n â‰¤ i â†’ nth_error (drop n l) (i - n) = nth_error l i</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>S n&#39; â‰¤ S i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error [] (i - n&#39;) = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> nth_error_None; <span class="nb">cbn</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
n â‰¤ i â†’ nth_error (drop n l) (i - n) = nth_error l i</span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>S n&#39; â‰¤ S i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (drop n&#39; t) (i - n&#39;) = nth_error t i</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHi; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb5"><span class="kn">Lemma</span> <span class="nf">drop_last</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">i</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">_default</span> : A),
    i &lt; length l -&gt; List.<span class="nb">last</span> (drop i l) _default  = List.<span class="nb">last</span> l _default.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">i</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">_default</span> : A),
  i &lt; length l
  â†’ List.<span class="nb">last</span> (drop i l) _default =
    List.<span class="nb">last</span> l _default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">i</span> : nat) (<span class="nv">l</span> : list A) (<span class="nv">_default</span> : A),
  i &lt; length l
  â†’ List.<span class="nb">last</span> (drop i l) _default =
    List.<span class="nb">last</span> l _default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb7"><span class="nb">induction</span> i; <span class="nb">intros</span> [| h t] * Hlt; <span class="nb">cbn</span> <span class="kr">in</span> *; [<span class="bp">done</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">_default</span> : A),
i &lt; length l â†’ List.<span class="nb">last</span> (drop i l) _default = List.<span class="nb">last</span> l _default</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>_default</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>S i &lt; S (length t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.<span class="nb">last</span> (drop i t) _default =
<span class="kr">match</span> t <span class="kr">with</span>
| [] =&gt; h
| _ :: _ =&gt; List.<span class="nb">last</span> t _default
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb8"><span class="nb">rewrite</span> IHi <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">_default</span> : A),
i &lt; length l â†’ List.<span class="nb">last</span> (drop i l) _default = List.<span class="nb">last</span> l _default</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>_default</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>S i &lt; S (length t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.<span class="nb">last</span> t _default =
<span class="kr">match</span> t <span class="kr">with</span>
| [] =&gt; h
| _ :: _ =&gt; List.<span class="nb">last</span> t _default
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkb9"><span class="nb">destruct</span> t; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">_default</span> : A),
i &lt; length l â†’ List.<span class="nb">last</span> (drop i l) _default = List.<span class="nb">last</span> l _default</span></span></span><br><span><var>h, _default</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>S i &lt; S (length [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">List.<span class="nb">last</span> [] _default = h</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hlt; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkba"><span class="kn">Lemma</span> <span class="nf">list_segment_nth</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">i</span> : nat),
    n1 &lt;= n2 -&gt; n1 &lt;= i -&gt; i &lt; n2 -&gt;
      nth_error (list_segment l n1 n2) (i - n1) = nth_error l i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">i</span> : nat),
  n1 â‰¤ n2
  â†’ n1 â‰¤ i
    â†’ i &lt; n2
      â†’ nth_error (list_segment l n1 n2) (i - n1) =
        nth_error l i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">i</span> : nat),
  n1 â‰¤ n2
  â†’ n1 â‰¤ i
    â†’ i &lt; n2
      â†’ nth_error (list_segment l n1 n2) (i - n1) =
        nth_error l i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkbc"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>i &lt; n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (list_segment l n1 n2) (i - n1) =
nth_error l i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkbd"><span class="nb">unfold</span> list_segment.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>i &lt; n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (drop n1 (take n2 l)) (i - n1) =
nth_error l i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkbe"><span class="nb">rewrite</span> drop_nth; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ i</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>i &lt; n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (take n2 l) i = nth_error l i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> take_nth.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkbf"><span class="kn">Lemma</span> <span class="nf">list_segment_app</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">n3</span> : nat),
    n1 &lt;= n2 -&gt; n2 &lt;= n3 -&gt;
      list_segment l n1 n2 ++ list_segment l n2 n3 = list_segment l n1 n3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">n3</span> : nat),
  n1 â‰¤ n2
  â†’ n2 â‰¤ n3
    â†’ list_segment l n1 n2 ++ list_segment l n2 n3 =
      list_segment l n1 n3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">n3</span> : nat),
  n1 â‰¤ n2
  â†’ n2 â‰¤ n3
    â†’ list_segment l n1 n2 ++ list_segment l n2 n3 =
      list_segment l n1 n3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_segment l n1 n2 ++ list_segment l n2 n3 =
list_segment l n1 n3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc2"><span class="nb">unfold</span> list_segment.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n1 (take n2 l) ++ drop n2 (take n3 l) =
drop n1 (take n3 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc3"><span class="nb">assert</span> (Hle : n1 &lt;= n3) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n1 (take n2 l) ++ drop n2 (take n3 l) =
drop n1 (take n3 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc4"><span class="nb">pose proof</span> (Hl1 := take_segment_suffix l n1 n3 Hle).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n3</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>take n1 l ++ list_segment l n1 n3 ++ drop n3 l = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n1 (take n2 l) ++ drop n2 (take n3 l) =
drop n1 (take n3 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc5"><span class="nb">rewrite</span> &lt;- (take_segment_suffix l n2 n3) <span class="kr">in</span> Hl1 <span class="nb">at</span> <span class="mi">4</span> <span class="bp">by</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n3</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>take n1 l ++ list_segment l n1 n3 ++ drop n3 l =
take n2 l ++ list_segment l n2 n3 ++ drop n3 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n1 (take n2 l) ++ drop n2 (take n3 l) =
drop n1 (take n3 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc6"><span class="nb">rewrite</span> !app_assoc <span class="kr">in</span> Hl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n3</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>(take n1 l ++ list_segment l n1 n3) ++ drop n3 l =
(take n2 l ++ list_segment l n2 n3) ++ drop n3 l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n1 (take n2 l) ++ drop n2 (take n3 l) =
drop n1 (take n3 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc7"><span class="nb">apply</span> app_inv_tail <span class="kr">in</span> Hl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n3</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>take n1 l ++ list_segment l n1 n3 = take n2 l ++ list_segment l n2 n3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n1 (take n2 l) ++ drop n2 (take n3 l) =
drop n1 (take n3 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc8"><span class="nb">rewrite</span> &lt;- (take_drop n1 (take n2 l)), &lt;- app_assoc, (take_prefix l n1 n2) <span class="kr">in</span> Hl1 <span class="bp">by</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2, n3</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n2 â‰¤ n3</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n3</span></span></span><br><span><var>Hl1</var><span class="hyp-type"><b>: </b><span>take n1 l ++ list_segment l n1 n3 =
take n1 l ++ drop n1 (take n2 l) ++ list_segment l n2 n3</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n1 (take n2 l) ++ drop n2 (take n3 l) =
drop n1 (take n3 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> app_inv_head <span class="kr">in</span> Hl1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkc9"><span class="kn">Lemma</span> <span class="nf">list_segment_singleton</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
    nth_error l n = Some a -&gt; list_segment l n (S n) = [a].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
  nth_error l n = Some a
  â†’ list_segment l n (S n) = [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A),
  nth_error l n = Some a
  â†’ list_segment l n (S n) = [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkcb"><span class="nb">intros</span> * Hnth.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span>nth_error l n = Some a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_segment l n (S n) = [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkcc"><span class="nb">apply</span> nth_error_split <span class="kr">in</span> Hnth <span class="kr">as</span> (l1 &amp; l2 &amp; -&gt; &amp; &lt;-).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_segment (l1 ++ a :: l2) (length l1)
  (S (length l1)) = [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkcd"><span class="nb">unfold</span> list_segment.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (length l1)
  (take (S (length l1)) (l1 ++ a :: l2)) = [a]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkce"><span class="nb">rewrite</span> &lt;- app_cons, app_assoc, take_app_length&#39;, drop_app_length; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (length l1) = length (l1 ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_length; <span class="nb">cbn</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkcf"><span class="kn">Lemma</span> <span class="nf">nth_error_map</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
    nth_error (List.map f l) n = option_map f (nth_error l n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ B) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  nth_error (map f l) n = option_map f (nth_error l n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ B) (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat),
  nth_error (map f l) n = option_map f (nth_error l n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> l; <span class="nb">intros</span> [| n]; <span class="nb">cbn</span>; [.. | <span class="nb">apply</span> IHl].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd1"><span class="kn">Lemma</span> <span class="nf">omap_app_rev</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; option B) (<span class="nv">l</span> : list A) (<span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B),
    omap f l = l1&#39; ++ l2&#39; -&gt;
      <span class="kr">exists</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 /\ omap f l1 = l1&#39; /\ omap f l2 = l2&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A) (<span class="nv">l1&#39;</span>
                                                <span class="nv">l2&#39;</span> : 
                                                list B),
  omap f l = l1&#39; ++ l2&#39;
  â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
      l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A) (<span class="nv">l1&#39;</span>
                                                <span class="nv">l2&#39;</span> : 
                                                list B),
  omap f l = l1&#39; ++ l2&#39;
  â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
      l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd3"><span class="nb">induction</span> l; <span class="nb">intros</span> * Happ_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>omap f [] = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  [] = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
  omap f l = l1&#39; ++ l2&#39;
  â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
      l = l1 ++ l2
      âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>omap f (a :: l) = l1&#39; ++ l2&#39;</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chkd4"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>omap f [] = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  [] = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd6"><span class="nb">symmetry in</span> Happ_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>l1&#39; ++ l2&#39; = omap f []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  [] = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd7"><span class="nb">apply</span> app_eq_nil <span class="kr">in</span> Happ_rev <span class="kr">as</span> [Hl1&#39; Hl2&#39;]; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  [] = l1 ++ l2 âˆ§ omap f l1 = [] âˆ§ omap f l2 = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> [], [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>omap f (a :: l) = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkd9"><span class="nb">cbn</span> <span class="kr">in</span> Happ_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> f a <span class="kr">with</span>
| Some y =&gt; y :: omap f l
| None =&gt; omap f l
<span class="kr">end</span> = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkda"><span class="nb">destruct</span> (f a) <span class="nb">eqn</span>: Hfa; <span class="nb">cycle</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = None</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>omap f l = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chkdb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
  omap f l = l1&#39; ++ l2&#39;
  â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
      l = l1 ++ l2
      âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = Some b</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>b :: omap f l = l1&#39; ++ l2&#39;</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chkdb"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkdc">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = None</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>omap f l = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkdd"><span class="nb">destruct</span> (IHl _ _ Happ_rev) <span class="kr">as</span> (_l1 &amp; l2 &amp; -&gt; &amp; &lt;- &amp; &lt;-).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>_l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f (_l1 ++ l2) = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l3</span> : list A,
_l1 ++ l2 = l1 ++ l3 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l3 = l2&#39;</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = None</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>omap f (_l1 ++ l2) =
omap f _l1 ++ omap f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l3</span> : list A,
  a :: _l1 ++ l2 = l1 ++ l3
  âˆ§ omap f l1 = omap f _l1 âˆ§ omap f l3 = omap f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">a</span> :: _l1), l2; <span class="nb">cbn</span>; <span class="nb">rewrite</span> Hfa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkde">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = Some b</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>b :: omap f l = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkdf"><span class="nb">destruct</span> l1&#39; <span class="kr">as</span> [| _b l1&#39;]; <span class="nb">cbn</span> <span class="kr">in</span> Happ_rev; <span class="nb">inversion</span> Happ_rev; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = Some b</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>b :: omap f l = b :: omap f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = [] âˆ§ omap f l2 = b :: omap f l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chke0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>_b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>_b :: omap f l = _b :: l1&#39; ++ l2&#39;</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = Some _b</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>omap f l = l1&#39; ++ l2&#39;</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chke0"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = _b :: l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke1">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = Some b</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>b :: omap f l = b :: omap f l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = [] âˆ§ omap f l2 = b :: omap f l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> [], (a :: l); <span class="nb">cbn</span>; <span class="nb">rewrite</span> Hfa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke2">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f l = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A, l = l1 ++ l2 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l2 = l2&#39;</span></span></span><br><span><var>_b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>l1', l2'</var><span class="hyp-type"><b>: </b><span>list B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>_b :: omap f l = _b :: l1&#39; ++ l2&#39;</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = Some _b</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>omap f l = l1&#39; ++ l2&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  a :: l = l1 ++ l2
  âˆ§ omap f l1 = _b :: l1&#39; âˆ§ omap f l2 = l2&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke3"><span class="nb">destruct</span> (IHl _ _ H1) <span class="kr">as</span> (_l1 &amp; l2 &amp; -&gt; &amp; &lt;- &amp; &lt;-).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>_l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1&#39;</span> <span class="nv">l2&#39;</span> : list B,
omap f (_l1 ++ l2) = l1&#39; ++ l2&#39;
â†’ <span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l3</span> : list A,
_l1 ++ l2 = l1 ++ l3 âˆ§ omap f l1 = l1&#39; âˆ§ omap f l3 = l2&#39;</span></span></span><br><span><var>_b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Happ_rev</var><span class="hyp-type"><b>: </b><span>_b :: omap f (_l1 ++ l2) =
_b :: omap f _l1 ++ omap f l2</span></span></span><br><span><var>Hfa</var><span class="hyp-type"><b>: </b><span>f a = Some _b</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>omap f (_l1 ++ l2) = omap f _l1 ++ omap f l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">l1</span> <span class="nv">l3</span> : list A,
  a :: _l1 ++ l2 = l1 ++ l3
  âˆ§ omap f l1 = _b :: omap f _l1
    âˆ§ omap f l3 = omap f l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">a</span> :: _l1), l2; <span class="nb">cbn</span>; <span class="nb">rewrite</span> Hfa.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke4"><span class="kn">Lemma</span> <span class="nf">omap_length</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; option B) (<span class="nv">l</span> : list A),
    Forall (<span class="kr">fun</span> <span class="nv">a</span> =&gt; f a &lt;&gt; None) l -&gt; length (omap f l) = length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l
  â†’ length (omap f l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l
  â†’ length (omap f l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke6"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x â‰  None</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l</span></span></span><br><span><var>IHForall</var><span class="hyp-type"><b>: </b><span>length (omap f l) = length l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length
  <span class="kr">match</span> f x <span class="kr">with</span>
  | Some y =&gt; y :: omap f l
  | None =&gt; omap f l
  <span class="kr">end</span> = S (length l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> case_match; <span class="nb">cbn</span>; <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke7"><span class="kn">Lemma</span> <span class="nf">omap_nth</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; option B) (<span class="nv">l</span> : list A) (<span class="nv">i</span> : nat) (<span class="nv">dummya</span> : A) (<span class="nv">dummyb</span> : B),
    Forall (<span class="kr">fun</span> <span class="nv">a</span> =&gt; f a &lt;&gt; None) l -&gt; i &lt; length l -&gt;
      Some (nth i (omap f l) dummyb) = f (nth i l dummya).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A) (<span class="nv">i</span> : nat) 
  (<span class="nv">dummya</span> : A) (<span class="nv">dummyb</span> : B),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l
  â†’ i &lt; length l
    â†’ Some (nth i (omap f l) dummyb) =
      f (nth i l dummya)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A) (<span class="nv">i</span> : nat) 
  (<span class="nv">dummya</span> : A) (<span class="nv">dummyb</span> : B),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l
  â†’ i &lt; length l
    â†’ Some (nth i (omap f l) dummyb) =
      f (nth i l dummya)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chke9"><span class="nb">intros</span> * Hall; <span class="nb">revert</span> i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>dummya</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>dummyb</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">i</span> : nat,
  i &lt; length l
  â†’ Some (nth i (omap f l) dummyb) =
    f (nth i l dummya)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkea"><span class="nb">induction</span> Hall; <span class="nb">cbn</span>; <span class="nb">intros</span>; [<span class="bp">by</span> <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>dummya</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>dummyb</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x â‰  None</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l</span></span></span><br><span><var>IHHall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : nat,
  i &lt; length l
  â†’ Some (nth i (omap f l) dummyb) =
    f (nth i l dummya)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>i &lt; S (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some
  (nth i
     <span class="kr">match</span> f x <span class="kr">with</span>
     | Some y =&gt; y :: omap f l
     | None =&gt; omap f l
     <span class="kr">end</span> dummyb) =
f <span class="kr">match</span> i <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; x
  | S m =&gt; nth m l dummya
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkeb"><span class="nb">destruct</span> i, (f x); <span class="nb">cbn</span>; [<span class="bp">done</span>.. | | <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>dummya</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>dummyb</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some b â‰  None</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a â‰  None) l</span></span></span><br><span><var>IHHall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : nat,
  i &lt; length l
  â†’ Some (nth i (omap f l) dummyb) =
    f (nth i l dummya)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>S i &lt; S (length l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (nth i (omap f l) dummyb) = f (nth i l dummya)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHHall; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">omap</span></span> can be expressed as a <span class="inlinecode"><span class="id" title="var">list_filter_map</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkec"><span class="kn">Lemma</span> <span class="nf">omap_as_filter</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; option B) (<span class="nv">l</span> : list A),
    omap f l = list_filter_map (is_Some âˆ˜ f) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; is_Some_proj (proj2_dsig x)) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  omap f l =
  list_filter_map (is_Some âˆ˜ f)
    (<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f),
       is_Some_proj (proj2_dsig x)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chked"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  omap f l =
  list_filter_map (is_Some âˆ˜ f)
    (<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f),
       is_Some_proj (proj2_dsig x)) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkee"><span class="nb">induction</span> l; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>omap f l =
list_filter_map (is_Some âˆ˜ f)
(<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f), is_Some_proj (proj2_dsig x)) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> f a <span class="kr">with</span>
| Some y =&gt; y :: omap f l
| None =&gt; omap f l
<span class="kr">end</span> =
map
  (<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f),
     is_Some_proj (proj2_dsig x))
  <span class="kr">match</span> decide (is_Some (f a)) <span class="kr">with</span>
  | <span class="nb">left</span> p =&gt;
      dexist a p :: filter_annotate (is_Some âˆ˜ f) l
  | <span class="nb">right</span> _ =&gt; filter_annotate (is_Some âˆ˜ f) l
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkef">case_decide; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>omap f l =
list_filter_map (is_Some âˆ˜ f)
(<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f), is_Some_proj (proj2_dsig x)) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_Some (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> f a <span class="kr">with</span>
| Some y =&gt; y :: omap f l
| None =&gt; omap f l
<span class="kr">end</span> =
is_Some_proj (proj2_dsig (dexist a H))
:: map
     (<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f),
        is_Some_proj (proj2_dsig x))
     (filter_annotate (is_Some âˆ˜ f) l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chkf0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>omap f l =
list_filter_map (is_Some âˆ˜ f)
(<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f), is_Some_proj (proj2_dsig x)) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Â¬ is_Some (f a)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chkf0"><hr></label><div class="goal-conclusion"><span class="kr">match</span> f a <span class="kr">with</span>
| Some y =&gt; y :: omap f l
| None =&gt; omap f l
<span class="kr">end</span> =
map
  (<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f),
     is_Some_proj (proj2_dsig x))
  (filter_annotate (is_Some âˆ˜ f) l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>omap f l =
list_filter_map (is_Some âˆ˜ f)
(<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f), is_Some_proj (proj2_dsig x)) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_Some (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> f a <span class="kr">with</span>
| Some y =&gt; y :: omap f l
| None =&gt; omap f l
<span class="kr">end</span> =
is_Some_proj (proj2_dsig (dexist a H))
:: map
     (<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f),
        is_Some_proj (proj2_dsig x))
     (filter_annotate (is_Some âˆ˜ f) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHl; <span class="nb">cbv</span>; <span class="nb">destruct</span> H <span class="kr">as</span> [? -&gt;].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>omap f l =
list_filter_map (is_Some âˆ˜ f)
(<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f), is_Some_proj (proj2_dsig x)) l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Â¬ is_Some (f a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> f a <span class="kr">with</span>
| Some y =&gt; y :: omap f l
| None =&gt; omap f l
<span class="kr">end</span> =
map
  (<span class="kr">Î»</span> <span class="nv">x</span> : dsig (is_Some âˆ˜ f),
     is_Some_proj (proj2_dsig x))
  (filter_annotate (is_Some âˆ˜ f) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (f a); [<span class="bp">contradict</span> H |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf3"><span class="kn">Lemma</span> <span class="nf">omap_Forall</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; option B) (<span class="nv">l</span> : list A),
    Forall (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ~ is_Some (f x)) l -&gt;
      omap f l = [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  Forall (<span class="kr">Î»</span> <span class="nv">x</span> : A, Â¬ is_Some (f x)) l â†’ omap f l = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  Forall (<span class="kr">Î»</span> <span class="nv">x</span> : A, Â¬ is_Some (f x)) l â†’ omap f l = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf5"><span class="nb">induction</span> <span class="mi">1</span> <span class="kr">as</span> [| ? ? H]; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Â¬ is_Some (f x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">x</span> : A, Â¬ is_Some (f x)) l</span></span></span><br><span><var>IHForall</var><span class="hyp-type"><b>: </b><span>omap f l = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> f x <span class="kr">with</span>
| Some y =&gt; y :: omap f l
| None =&gt; omap f l
<span class="kr">end</span> = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> case_match; [<span class="bp">contradict</span> H |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf6"><span class="kn">Lemma</span> <span class="nf">NoDup_omap</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; option B) (<span class="nv">l</span> : list A),
    (<span class="kr">forall</span> <span class="nv">a1</span> <span class="nv">a2</span> : A, is_Some (f a1) -&gt; is_Some (f a2) -&gt; f a1 = f a2 -&gt; a1 = a2) -&gt;
      NoDup l -&gt; NoDup (omap f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
     is_Some (f a1)
     â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2)
  â†’ NoDup l â†’ NoDup (omap f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A â†’ option B) (<span class="nv">l</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
     is_Some (f a1)
     â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2)
  â†’ NoDup l â†’ NoDup (omap f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf8"><span class="nb">intros</span> A B f l Hinj Hnd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hinj</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
  is_Some (f a1)
  â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (omap f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkf9"><span class="nb">induction</span> Hnd <span class="kr">as</span> [| h t Hnin Hnd IH]; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">constructor</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>Hinj</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
  is_Some (f a1)
  â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnin</var><span class="hyp-type"><b>: </b><span>h âˆ‰ t</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup t</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup (omap f t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  <span class="kr">match</span> f h <span class="kr">with</span>
  | Some y =&gt; y :: omap f t
  | None =&gt; omap f t
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkfa"><span class="nb">destruct</span> (f h) <span class="nb">eqn</span>: Heq; [| <span class="bp">by</span> <span class="nb">apply</span> IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>Hinj</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
  is_Some (f a1)
  â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnin</var><span class="hyp-type"><b>: </b><span>h âˆ‰ t</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup t</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup (omap f t)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f h = Some b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (b :: omap f t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkfb"><span class="nb">constructor</span>; [| <span class="bp">by</span> <span class="nb">apply</span> IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>Hinj</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
  is_Some (f a1)
  â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnin</var><span class="hyp-type"><b>: </b><span>h âˆ‰ t</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup t</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup (omap f t)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f h = Some b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b âˆ‰ omap f t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkfc"><span class="nb">intros</span> Hin; <span class="nb">apply</span> elem_of_list_omap <span class="kr">in</span> Hin <span class="kr">as</span> (x &amp; Hinx &amp; Hfx).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>Hinj</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
  is_Some (f a1)
  â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnin</var><span class="hyp-type"><b>: </b><span>h âˆ‰ t</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup t</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup (omap f t)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f h = Some b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hinx</var><span class="hyp-type"><b>: </b><span>x âˆˆ t</span></span></span><br><span><var>Hfx</var><span class="hyp-type"><b>: </b><span>f x = Some b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkfd"><span class="nb">assert</span> (x = h) <span class="bp">by</span> (<span class="nb">apply</span> Hinj; [<span class="bp">done</span>.. | <span class="bp">congruence</span>]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A â†’ option B</span></span></span><br><span><var>Hinj</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a1</span> <span class="nv">a2</span> : A,
  is_Some (f a1)
  â†’ is_Some (f a2) â†’ f a1 = f a2 â†’ a1 = a2</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnin</var><span class="hyp-type"><b>: </b><span>h âˆ‰ t</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup t</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup (omap f t)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f h = Some b</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hinx</var><span class="hyp-type"><b>: </b><span>x âˆˆ t</span></span></span><br><span><var>Hfx</var><span class="hyp-type"><b>: </b><span>f x = Some b</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
Unpack list of <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> into list of <span class="inlinecode"><span class="id" title="var">A</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">cat_option</span> {<span class="nv">A</span> : <span class="kt">Type</span>} : list (option A) -&gt; list A :=
  omap id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkfe"><span class="kn">Lemma</span> <span class="nf">cat_option_length</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list (option A)),
    Forall (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a &lt;&gt; None) l -&gt; length (cat_option l) = length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list (option A)),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : option A, a â‰  None) l
  â†’ length (cat_option l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chkff"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list (option A)),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : option A, a â‰  None) l
  â†’ length (cat_option l) = length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">apply</span> omap_length.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk100"><span class="kn">Lemma</span> <span class="nf">cat_option_length_le</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list (option A)),
    length (cat_option l) &lt;= length l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list (option A)),
  length (cat_option l) â‰¤ length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk101"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list (option A)),
  length (cat_option l) â‰¤ length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> l <span class="kr">as</span> [| []]; <span class="nb">cbn</span>; [| <span class="bp">lia</span>..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk102"><span class="kn">Lemma</span> <span class="nf">cat_option_app</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list (option A)),
    cat_option (l1 ++ l2) = cat_option l1 ++ cat_option l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list (option A)),
  cat_option (l1 ++ l2) =
  cat_option l1 ++ cat_option l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk103"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list (option A)),
  cat_option (l1 ++ l2) =
  cat_option l1 ++ cat_option l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> cat_option; <span class="nb">intros</span>; <span class="nb">rewrite</span> omap_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk104"><span class="kn">Lemma</span> <span class="nf">cat_option_nth</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list (option A)) (<span class="nv">i</span> : nat) (<span class="nv">dummya</span> : A),
    Forall (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a &lt;&gt; None) l -&gt; i &lt; length l -&gt;
      Some (nth i (cat_option l) dummya) = (nth i l (Some dummya)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list (option A)) (<span class="nv">i</span> : nat) (<span class="nv">dummya</span> : A),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : option A, a â‰  None) l
  â†’ i &lt; length l
    â†’ Some (nth i (cat_option l) dummya) =
      nth i l (Some dummya)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk105"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list (option A)) (<span class="nv">i</span> : nat) (<span class="nv">dummya</span> : A),
  Forall (<span class="kr">Î»</span> <span class="nv">a</span> : option A, a â‰  None) l
  â†’ i &lt; length l
    â†’ Some (nth i (cat_option l) dummya) =
      nth i l (Some dummya)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> cat_option; <span class="nb">intros</span>; <span class="nb">erewrite</span> omap_nth.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk106"><span class="kn">Lemma</span> <span class="nf">nth_error_eq</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    (<span class="kr">forall</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n) -&gt; l1 = l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk107"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk108"><span class="nb">induction</span> l1; <span class="nb">intros</span> [| a2 l2] Hnth; [<span class="bp">done</span> | ..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error [] n = nth_error (a2 :: l2) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = a2 :: l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk109" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n = nth_error [] n</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk109"><hr></label><div class="goal-conclusion">a :: l1 = []</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n =
  nth_error (a2 :: l2) n</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk10a"><hr></label><div class="goal-conclusion">a :: l1 = a2 :: l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk10b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error [] n = nth_error (a2 :: l2) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = a2 :: l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">specialize</span> (Hnth <span class="mi">0</span>); <span class="nb">inversion</span> Hnth.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk10c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n = nth_error [] n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l1 = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">specialize</span> (Hnth <span class="mi">0</span>); <span class="nb">inversion</span> Hnth.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk10d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n =
  nth_error (a2 :: l2) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l1 = a2 :: l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk10e"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n =
  nth_error (a2 :: l2) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = a2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk10f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n =
  nth_error (a2 :: l2) n</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk10f"><hr></label><div class="goal-conclusion">l1 = l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk110">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n =
  nth_error (a2 :: l2) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = a2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">specialize</span> (Hnth <span class="mi">0</span>); <span class="nb">cbn</span> <span class="kr">in</span> Hnth; <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk111">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n =
  nth_error (a2 :: l2) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 = l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk112"><span class="nb">apply</span> IHl1; <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> : list A,
  (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, nth_error l1 n = nth_error l2 n)
  â†’ l1 = l2</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnth</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  nth_error (a :: l1) n =
  nth_error (a2 :: l2) n</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l1 n = nth_error l2 n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">specialize</span> (Hnth (S n)); <span class="nb">cbn</span> <span class="kr">in</span> Hnth.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Compute the list of all decompositions of the given list <code>l</code> into
  triples <code>(l1, x, l2)</code> such that <code>l = l1 ++ x :: l2</code>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">one_element_decompositions</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) : list (list A * A * list A) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | a :: l&#39; =&gt;
    ([], a, l&#39;)
    :: map
      (<span class="kr">fun</span> <span class="nv">t</span> =&gt; <span class="kr">match</span> t <span class="kr">with</span> (l1, b, l2) =&gt; (a :: l1, b, l2) <span class="kr">end</span>)
      (one_element_decompositions l&#39;)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk113"><span class="kn">Lemma</span> <span class="nf">elem_of_one_element_decompositions</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> <span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
    (pre, x, suf) âˆˆ one_element_decompositions l
      &lt;-&gt;
    pre ++ [x] ++ suf = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
  (pre, x, suf) âˆˆ one_element_decompositions l
  â†” pre ++ [x] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk114"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
  (pre, x, suf) âˆˆ one_element_decompositions l
  â†” pre ++ [x] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk115"><span class="nb">induction</span> l; <span class="nb">split</span>; <span class="nb">cbn</span>; <span class="nb">intros</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(pre, x, suf) âˆˆ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre ++ x :: suf = []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk116" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>pre ++ x :: suf = []</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk116"><hr></label><div class="goal-conclusion">(pre, x, suf) âˆˆ []</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
(pre, x, suf) âˆˆ one_element_decompositions l â†” pre ++ [x] ++ suf = l</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(pre, x, suf)
âˆˆ ([], a, l)
:: map
(<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
<span class="kr">let</span> (<span class="nv">y</span>, l2) := t <span class="kr">in</span> <span class="kr">let</span> (<span class="nv">l1</span>, b) := y <span class="kr">in</span> (a :: l1, b, l2))
(one_element_decompositions l)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk117"><hr></label><div class="goal-conclusion">pre ++ x :: suf = a :: l</div></blockquote><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
(pre, x, suf) âˆˆ one_element_decompositions l â†” pre ++ [x] ++ suf = l</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>pre ++ x :: suf = a :: l</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk118"><hr></label><div class="goal-conclusion">(pre, x, suf)
âˆˆ ([], a, l)
  :: map
       (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
          <span class="kr">let</span> (<span class="nv">y</span>, l2) := t <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">l1</span>, b) := y <span class="kr">in</span> (a :: l1, b, l2))
       (one_element_decompositions l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk119">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(pre, x, suf) âˆˆ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre ++ x :: suf = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk11a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>pre ++ x :: suf = []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pre, x, suf) âˆˆ []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> pre; <span class="nb">inversion</span> Hin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk11b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
(pre, x, suf) âˆˆ one_element_decompositions l â†” pre ++ [x] ++ suf = l</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(pre, x, suf)
âˆˆ ([], a, l)
:: map
(<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
<span class="kr">let</span> (<span class="nv">y</span>, l2) := t <span class="kr">in</span> <span class="kr">let</span> (<span class="nv">l1</span>, b) := y <span class="kr">in</span> (a :: l1, b, l2))
(one_element_decompositions l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre ++ x :: suf = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk11c"><span class="nb">rewrite</span> elem_of_cons, elem_of_list_fmap <span class="kr">in</span> Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
(pre, x, suf) âˆˆ one_element_decompositions l â†” pre ++ [x] ++ suf = l</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(pre, x, suf) = ([], a, l)
âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">y</span> : list A * A * list A,
(pre, x, suf) =
(<span class="kr">let</span> (<span class="nv">y0</span>, l2) := y <span class="kr">in</span> <span class="kr">let</span> (<span class="nv">l1</span>, b) := y0 <span class="kr">in</span> (a :: l1, b, l2))
âˆ§ y âˆˆ one_element_decompositions l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre ++ x :: suf = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk11d"><span class="nb">destruct</span> Hin <span class="kr">as</span> [[= -&gt; -&gt; -&gt;] | (((pre&#39;, x&#39;), suf&#39;) &amp; [= -&gt; -&gt; -&gt;] &amp; Hin)]; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
(pre, x, suf) âˆˆ one_element_decompositions l â†” pre ++ [x] ++ suf = l</span></span></span><br><span><var>pre'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>suf'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(pre&#39;, x&#39;, suf&#39;) âˆˆ one_element_decompositions l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a :: pre&#39;) ++ x&#39; :: suf&#39; = a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> (IHl pre&#39; suf&#39; x&#39;) <span class="kr">in</span> Hin; <span class="nb">subst</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> : A),
(pre, x, suf) âˆˆ one_element_decompositions l â†” pre ++ [x] ++ suf = l</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>pre ++ x :: suf = a :: l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pre, x, suf)
âˆˆ ([], a, l)
  :: map
       (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
          <span class="kr">let</span> (<span class="nv">y</span>, l2) := t <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">l1</span>, b) := y <span class="kr">in</span> (a :: l1, b, l2))
       (one_element_decompositions l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk11f"><span class="nb">destruct</span> pre; <span class="nb">inversion</span> Hin; <span class="nb">subst</span>; <span class="nb">clear</span> Hin; [<span class="bp">by</span> <span class="nb">left</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre0</span> <span class="nv">suf0</span> : list A) (<span class="nv">x0</span> : A),
(pre0, x0, suf0) âˆˆ one_element_decompositions (pre ++ x :: suf)
â†” pre0 ++ [x0] ++ suf0 = pre ++ x :: suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a :: pre, x, suf)
âˆˆ ([], a, pre ++ x :: suf)
  :: map
       (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
          <span class="kr">let</span> (<span class="nv">y</span>, l2) := t <span class="kr">in</span>
          <span class="kr">let</span> (<span class="nv">l1</span>, b) := y <span class="kr">in</span> (a :: l1, b, l2))
       (one_element_decompositions (pre ++ x :: suf))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk120"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre0</span> <span class="nv">suf0</span> : list A) (<span class="nv">x0</span> : A),
(pre0, x0, suf0) âˆˆ one_element_decompositions (pre ++ x :: suf)
â†” pre0 ++ [x0] ++ suf0 = pre ++ x :: suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a :: pre, x, suf)
âˆˆ map
    (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
       <span class="kr">let</span> (<span class="nv">y</span>, l2) := t <span class="kr">in</span>
       <span class="kr">let</span> (<span class="nv">l1</span>, b) := y <span class="kr">in</span> (a :: l1, b, l2))
    (one_element_decompositions (pre ++ x :: suf))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk121"><span class="nb">apply</span> elem_of_list_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre0</span> <span class="nv">suf0</span> : list A) (<span class="nv">x0</span> : A),
(pre0, x0, suf0) âˆˆ one_element_decompositions (pre ++ x :: suf)
â†” pre0 ++ [x0] ++ suf0 = pre ++ x :: suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">y</span> : list A * A * list A,
  (a :: pre, x, suf) =
  (<span class="kr">let</span> (<span class="nv">y0</span>, l2) := y <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">l1</span>, b) := y0 <span class="kr">in</span> (a :: l1, b, l2))
  âˆ§ y âˆˆ one_element_decompositions (pre ++ x :: suf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk122"><span class="kr">exists</span> (<span class="nv">pre</span>, x, suf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">pre0</span> <span class="nv">suf0</span> : list A) (<span class="nv">x0</span> : A),
(pre0, x0, suf0) âˆˆ one_element_decompositions (pre ++ x :: suf)
â†” pre0 ++ [x0] ++ suf0 = pre ++ x :: suf</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a :: pre, x, suf) = (a :: pre, x, suf)
âˆ§ (pre, x, suf)
  âˆˆ one_element_decompositions (pre ++ x :: suf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Compute the list of all decompositions of the given list <code>l</code> into
  tuples <code>(l1, x, l2, y, l3)</code> such that <code>l = l1 ++ x :: l2 ++ y :: l3</code>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">two_element_decompositions</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) : list (list A * A * list A * A * list A) :=
  flat_map
    (<span class="kr">fun</span> <span class="nv">t</span> =&gt;
      <span class="kr">match</span> t <span class="kr">with</span>
        (l1, e1, l2) =&gt;
        map
          (<span class="kr">fun</span> <span class="nv">t</span> =&gt; <span class="kr">match</span> t <span class="kr">with</span> (l2&#39;, e2, l3) =&gt; (l1, e1, l2&#39;, e2, l3) <span class="kr">end</span>)
          (one_element_decompositions l2)
      <span class="kr">end</span>)
    (one_element_decompositions l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk123"><span class="kn">Lemma</span> <span class="nf">elem_of_two_element_decompositions</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> <span class="nv">pre</span> <span class="nv">mid</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> <span class="nv">y</span> : A),
    (pre, x, mid, y, suf) âˆˆ two_element_decompositions l
      &lt;-&gt;
    pre ++ [x] ++ mid ++ [y] ++ suf = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">pre</span> <span class="nv">mid</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> <span class="nv">y</span> : A),
  (pre, x, mid, y, suf) âˆˆ two_element_decompositions l
  â†” pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk124"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">pre</span> <span class="nv">mid</span> <span class="nv">suf</span> : list A) (<span class="nv">x</span> <span class="nv">y</span> : A),
  (pre, x, mid, y, suf) âˆˆ two_element_decompositions l
  â†” pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk125"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pre, x, mid, y, suf) âˆˆ two_element_decompositions l
â†” pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk126"><span class="nb">unfold</span> two_element_decompositions.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pre, x, mid, y, suf)
âˆˆ flat_map
    (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
       <span class="kr">let</span> (<span class="nv">y</span>, l2) := t <span class="kr">in</span>
       <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
       map
         (<span class="kr">Î»</span> <span class="nv">t0</span> : list A * A * list A,
            <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t0 <span class="kr">in</span>
            <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
            (l1, e1, l2&#39;, e2, l3))
         (one_element_decompositions l2))
    (one_element_decompositions l)
â†” pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk127"><span class="nb">rewrite</span> elem_of_list_In, in_flat_map; <span class="nb">setoid_rewrite</span> &lt;- elem_of_list_In.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆƒ</span> <span class="nv">x0</span> : list A * A * list A,
   x0 âˆˆ one_element_decompositions l
   âˆ§ (pre, x, mid, y, suf)
     âˆˆ (<span class="kr">let</span> (<span class="nv">y</span>, l2) := x0 <span class="kr">in</span>
        <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
        map
          (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
             <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
             (l1, e1, l2&#39;, e2, l3))
          (one_element_decompositions l2)))
â†” pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk128"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆƒ</span> <span class="nv">x0</span> : list A * A * list A,
   x0 âˆˆ one_element_decompositions l
   âˆ§ (pre, x, mid, y, suf)
     âˆˆ (<span class="kr">let</span> (<span class="nv">y</span>, l2) := x0 <span class="kr">in</span>
        <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
        map
          (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
             <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
             (l1, e1, l2&#39;, e2, l3))
          (one_element_decompositions l2)))
â†’ pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk129" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk129"><hr></label><div class="goal-conclusion">pre ++ [x] ++ mid ++ [y] ++ suf = l
â†’ <span class="kr">âˆƒ</span> <span class="nv">x0</span> : list A * A * list A,
    x0 âˆˆ one_element_decompositions l
    âˆ§ (pre, x, mid, y, suf)
      âˆˆ (<span class="kr">let</span> (<span class="nv">y</span>, l2) := x0 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
         map
           (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
              <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
              (l1, e1, l2&#39;, e2, l3))
           (one_element_decompositions l2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk12a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆƒ</span> <span class="nv">x0</span> : list A * A * list A,
   x0 âˆˆ one_element_decompositions l
   âˆ§ (pre, x, mid, y, suf)
     âˆˆ (<span class="kr">let</span> (<span class="nv">y</span>, l2) := x0 <span class="kr">in</span>
        <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
        map
          (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
             <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
             (l1, e1, l2&#39;, e2, l3))
          (one_element_decompositions l2)))
â†’ pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk12b"><span class="nb">intros</span> [((pre&#39;, x&#39;), sufx) [Hdecx Hin]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>sufx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hdecx</var><span class="hyp-type"><b>: </b><span>(pre&#39;, x&#39;, sufx)
âˆˆ one_element_decompositions l</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(pre, x, mid, y, suf)
âˆˆ map
    (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
       <span class="kr">let</span> (<span class="nv">y</span>, l3) := t <span class="kr">in</span>
       <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y <span class="kr">in</span>
       (pre&#39;, x&#39;, l2&#39;, e2, l3))
    (one_element_decompositions sufx)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre ++ [x] ++ mid ++ [y] ++ suf = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk12c"><span class="nb">apply</span> elem_of_list_fmap <span class="kr">in</span> Hin <span class="kr">as</span> [[[mid&#39; y&#39;] suf&#39;] [[= -&gt; -&gt; -&gt; -&gt; -&gt;] Hin]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>sufx</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hdecx</var><span class="hyp-type"><b>: </b><span>(pre&#39;, x&#39;, sufx)
âˆˆ one_element_decompositions l</span></span></span><br><span><var>mid'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>y'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>suf'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>(mid&#39;, y&#39;, suf&#39;)
âˆˆ one_element_decompositions sufx</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre&#39; ++ [x&#39;] ++ mid&#39; ++ [y&#39;] ++ suf&#39; = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> elem_of_one_element_decompositions <span class="kr">in</span> Hdecx <span class="kr">as</span> &lt;-, Hin <span class="kr">as</span> &lt;-.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk12d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre ++ [x] ++ mid ++ [y] ++ suf = l
â†’ <span class="kr">âˆƒ</span> <span class="nv">x0</span> : list A * A * list A,
    x0 âˆˆ one_element_decompositions l
    âˆ§ (pre, x, mid, y, suf)
      âˆˆ (<span class="kr">let</span> (<span class="nv">y</span>, l2) := x0 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
         map
           (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
              <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
              (l1, e1, l2&#39;, e2, l3))
           (one_element_decompositions l2))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk12e"><span class="nb">intros</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>pre ++ [x] ++ mid ++ [y] ++ suf = l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">x0</span> : list A * A * list A,
  x0 âˆˆ one_element_decompositions l
  âˆ§ (pre, x, mid, y, suf)
    âˆˆ (<span class="kr">let</span> (<span class="nv">y</span>, l2) := x0 <span class="kr">in</span>
       <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
       map
         (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
            <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t <span class="kr">in</span>
            <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
            (l1, e1, l2&#39;, e2, l3))
         (one_element_decompositions l2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk12f"><span class="nb">apply</span> elem_of_one_element_decompositions <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(pre, x, mid ++ [y] ++ suf)
âˆˆ one_element_decompositions l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">x0</span> : list A * A * list A,
  x0 âˆˆ one_element_decompositions l
  âˆ§ (pre, x, mid, y, suf)
    âˆˆ (<span class="kr">let</span> (<span class="nv">y</span>, l2) := x0 <span class="kr">in</span>
       <span class="kr">let</span> (<span class="nv">l1</span>, e1) := y <span class="kr">in</span>
       map
         (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
            <span class="kr">let</span> (<span class="nv">y0</span>, l3) := t <span class="kr">in</span>
            <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y0 <span class="kr">in</span>
            (l1, e1, l2&#39;, e2, l3))
         (one_element_decompositions l2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk130"><span class="kr">exists</span> (<span class="nv">pre</span>, x, mid ++ [y] ++ suf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(pre, x, mid ++ [y] ++ suf)
âˆˆ one_element_decompositions l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pre, x, mid ++ [y] ++ suf)
âˆˆ one_element_decompositions l
âˆ§ (pre, x, mid, y, suf)
  âˆˆ map
      (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
         <span class="kr">let</span> (<span class="nv">y</span>, l3) := t <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y <span class="kr">in</span> (pre, x, l2&#39;, e2, l3))
      (one_element_decompositions (mid ++ [y] ++ suf))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk131"><span class="nb">split</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(pre, x, mid ++ [y] ++ suf)
âˆˆ one_element_decompositions l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pre, x, mid, y, suf)
âˆˆ map
    (<span class="kr">Î»</span> <span class="nv">t</span> : list A * A * list A,
       <span class="kr">let</span> (<span class="nv">y</span>, l3) := t <span class="kr">in</span>
       <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y <span class="kr">in</span> (pre, x, l2&#39;, e2, l3))
    (one_element_decompositions (mid ++ [y] ++ suf))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk132"><span class="nb">apply</span> elem_of_list_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(pre, x, mid ++ [y] ++ suf)
âˆˆ one_element_decompositions l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">y0</span> : list A * A * list A,
  (pre, x, mid, y, suf) =
  (<span class="kr">let</span> (<span class="nv">y</span>, l3) := y0 <span class="kr">in</span>
   <span class="kr">let</span> (<span class="nv">l2&#39;</span>, e2) := y <span class="kr">in</span> (pre, x, l2&#39;, e2, l3))
  âˆ§ y0
    âˆˆ one_element_decompositions (mid ++ [y] ++ suf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk133"><span class="kr">exists</span> (<span class="nv">mid</span>, y, suf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, pre, mid, suf</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(pre, x, mid ++ [y] ++ suf)
âˆˆ one_element_decompositions l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(pre, x, mid, y, suf) = (pre, x, mid, y, suf)
âˆ§ (mid, y, suf)
  âˆˆ one_element_decompositions (mid ++ [y] ++ suf)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> elem_of_one_element_decompositions.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk134"><span class="kn">Lemma</span> <span class="nf">order_decompositions</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">pre1</span> <span class="nv">suf1</span> <span class="nv">pre2</span> <span class="nv">suf2</span> : list A),
    pre1 ++ suf1 = pre2 ++ suf2 -&gt;
    pre1 = pre2 \/ (<span class="kr">exists</span> <span class="nv">suf1&#39;</span>, pre1 = pre2 ++ suf1&#39;) \/ (<span class="kr">exists</span> <span class="nv">suf2&#39;</span>, pre2 = pre1 ++ suf2&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">pre1</span> <span class="nv">suf1</span> <span class="nv">pre2</span> <span class="nv">suf2</span> : list A),
  pre1 ++ suf1 = pre2 ++ suf2
  â†’ pre1 = pre2
    âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf1&#39;</span> : list A, pre1 = pre2 ++ suf1&#39;)
      âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf2&#39;</span> : list A, pre2 = pre1 ++ suf2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk135"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">pre1</span> <span class="nv">suf1</span> <span class="nv">pre2</span> <span class="nv">suf2</span> : list A),
  pre1 ++ suf1 = pre2 ++ suf2
  â†’ pre1 = pre2
    âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf1&#39;</span> : list A, pre1 = pre2 ++ suf1&#39;)
      âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf2&#39;</span> : list A, pre2 = pre1 ++ suf2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk136"><span class="nb">induction</span> pre1; <span class="nb">destruct</span> pre2; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">eauto</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">suf1</span> <span class="nv">pre2</span> <span class="nv">suf2</span> : list A,
  pre1 ++ suf1 = pre2 ++ suf2
  â†’ pre1 = pre2
    âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf1&#39;</span> : list A, pre1 = pre2 ++ suf1&#39;)
      âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf2&#39;</span> : list A,
           pre2 = pre1 ++ suf2&#39;)</span></span></span><br><span><var>suf1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">suf2</span> : list A,
  a :: pre1 ++ suf1 = a0 :: pre2 ++ suf2
  â†’ a :: pre1 = a0 :: pre2
    âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf1&#39;</span> : list A,
         a :: pre1 = a0 :: pre2 ++ suf1&#39;)
      âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf2&#39;</span> : list A,
           a0 :: pre2 = a :: pre1 ++ suf2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk137"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>pre1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">suf1</span> <span class="nv">pre2</span> <span class="nv">suf2</span> : list A,
  pre1 ++ suf1 = pre2 ++ suf2
  â†’ pre1 = pre2
    âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf1&#39;</span> : list A, pre1 = pre2 ++ suf1&#39;)
      âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf2&#39;</span> : list A,
           pre2 = pre1 ++ suf2&#39;)</span></span></span><br><span><var>suf1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>pre2, suf2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a0 :: pre1 ++ suf1 = a0 :: pre2 ++ suf2</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>pre1 ++ suf1 = pre2 ++ suf2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0 :: pre1 = a0 :: pre2
âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf1&#39;</span> : list A, a0 :: pre1 = a0 :: pre2 ++ suf1&#39;)
  âˆ¨ (<span class="kr">âˆƒ</span> <span class="nv">suf2&#39;</span> : list A,
       a0 :: pre2 = a0 :: pre1 ++ suf2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">edestruct</span> IHpre1 <span class="kr">as</span> [| [[] | []]]; [<span class="bp">done</span> | <span class="nb">subst</span>; <span class="nb">eauto</span>..].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk138"><span class="kn">Lemma</span> <span class="nf">list_max_exists</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list nat),
    l &lt;&gt; [] -&gt; list_max l âˆˆ l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list nat, l â‰  [] â†’ list_max l âˆˆ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk139"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list nat, l â‰  [] â†’ list_max l âˆˆ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk13a"><span class="nb">induction</span> l <span class="kr">as</span> [| h t]; <span class="nb">cbn</span>; <span class="nb">intros</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>t â‰  [] â†’ list_max t âˆˆ t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h :: t â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">h `max` foldr Init.Nat.max <span class="mi">0</span> t âˆˆ h :: t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk13b"><span class="nb">destruct</span> (PeanoNat.Nat.max_spec h (foldr Init.Nat.max <span class="mi">0</span> t))
    <span class="kr">as</span> [[Hlt -&gt;] | [Hle -&gt;]]; [| <span class="bp">by</span> <span class="nb">left</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>t â‰  [] â†’ list_max t âˆˆ t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h :: t â‰  []</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>h &lt; foldr Init.Nat.max <span class="mi">0</span> t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr Init.Nat.max <span class="mi">0</span> t âˆˆ h :: t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk13c"><span class="nb">right</span>; <span class="nb">apply</span> IHt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>h</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>t â‰  [] â†’ list_max t âˆˆ t</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h :: t â‰  []</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>h &lt; foldr Init.Nat.max <span class="mi">0</span> t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">t â‰  []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> t; [<span class="nb">cbn</span> <span class="kr">in</span> Hlt; <span class="bp">lia</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Returns all values which occur with maximum frequency in the given list.
  Note that these values are returned with their original multiplicity.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mode</span> `{EqDecision A} (l : list A) : list A :=
  <span class="kr">let</span> <span class="nv">mode_value</span> := list_max (List.map (count_occ decide_eq l) l) <span class="kr">in</span>
    filter (<span class="kr">fun</span> <span class="nv">a</span> =&gt; (count_occ decide_eq l a) = mode_value) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk13d"><span class="kn">Example</span> <span class="nf">mode1</span> : mode [<span class="mi">1</span>; <span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">3</span>] = [<span class="mi">1</span>; <span class="mi">1</span>; <span class="mi">3</span>; <span class="mi">3</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">mode [<span class="mi">1</span>; <span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">3</span>] = [<span class="mi">1</span>; <span class="mi">1</span>; <span class="mi">3</span>; <span class="mi">3</span>]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk13e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">mode [<span class="mi">1</span>; <span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">3</span>] = [<span class="mi">1</span>; <span class="mi">1</span>; <span class="mi">3</span>; <span class="mi">3</span>]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Computes the list <code>suff</code> which satisfies <code>pref ++ suff = l</code> or
  reports that no such list exists.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">complete_prefix</span> `{EqDecision A} (l pref : list A) : option (list A) :=
  <span class="kr">match</span> l, pref <span class="kr">with</span>
  | l , [] =&gt; Some l
  | [], b :: pref&#39; =&gt; None
  | a :: l&#39;, b :: pref&#39; =&gt; <span class="kr">if</span> decide (a = b) <span class="kr">then</span> complete_prefix l&#39; pref&#39; <span class="kr">else</span> None
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk13f"><span class="kn">Example</span> <span class="nf">complete_prefix_some</span> : complete_prefix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">1</span>; <span class="mi">2</span>] = Some [<span class="mi">3</span>; <span class="mi">4</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_prefix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">1</span>; <span class="mi">2</span>] = Some [<span class="mi">3</span>; <span class="mi">4</span>]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk140"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_prefix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">1</span>; <span class="mi">2</span>] = Some [<span class="mi">3</span>; <span class="mi">4</span>]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk141"><span class="kn">Example</span> <span class="nf">complete_prefix_none</span> : complete_prefix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">1</span>; <span class="mi">3</span>] = None.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_prefix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">1</span>; <span class="mi">3</span>] = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk142"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_prefix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">1</span>; <span class="mi">3</span>] = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk143"><span class="kn">Lemma</span> <span class="nf">complete_prefix_empty</span> `{EqDecision A} :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A),
    complete_prefix l [] = Some l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, complete_prefix l [] = Some l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk144"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, complete_prefix l [] = Some l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk145"><span class="kn">Lemma</span> <span class="nf">complete_prefix_correct</span> `{EqDecision A} :
  <span class="kr">forall</span> (<span class="nv">l</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A),
    l = pref ++ <span class="nb">suff</span> &lt;-&gt; complete_prefix l pref = Some <span class="nb">suff</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A,
  l = pref ++ <span class="nb">suff</span>
  â†” complete_prefix l pref = Some <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk146"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A,
  l = pref ++ <span class="nb">suff</span>
  â†” complete_prefix l pref = Some <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk147"><span class="nb">induction</span> l; <span class="nb">intros</span> [] <span class="nb">suff</span>; <span class="nb">cbn</span>; [<span class="bp">by</span> itauto <span class="bp">congruence</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A,
  l = pref ++ <span class="nb">suff</span>
  â†” complete_prefix l pref = Some <span class="nb">suff</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l0, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a0 :: l0 ++ <span class="nb">suff</span>
â†” (<span class="kr">if</span> decide (a = a0)
   <span class="kr">then</span> complete_prefix l l0
   <span class="kr">else</span> None) = Some <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk148">case_decide; [| <span class="bp">by</span> itauto <span class="bp">congruence</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A,
  l = pref ++ <span class="nb">suff</span>
  â†” complete_prefix l pref = Some <span class="nb">suff</span></span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l0, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a = a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = a0 :: l0 ++ <span class="nb">suff</span>
â†” complete_prefix l l0 = Some <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> &lt;- IHl; itauto <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Computes the list <code>pref</code> which satisfies <code>pref ++ suff = l</code> or
  reports that no such list exists.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">complete_suffix</span> `{EqDecision A} (l <span class="nb">suff</span> : list A) : option (list A) :=
  <span class="kr">match</span> complete_prefix (rev l) (rev <span class="nb">suff</span>) <span class="kr">with</span>
  | None =&gt; None
  | Some ls =&gt; Some (rev ls)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk149"><span class="kn">Example</span> <span class="nf">complete_suffix_some</span> : complete_suffix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">3</span>; <span class="mi">4</span>] = Some [<span class="mi">1</span>; <span class="mi">2</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_suffix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">3</span>; <span class="mi">4</span>] = Some [<span class="mi">1</span>; <span class="mi">2</span>]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk14a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_suffix [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>; <span class="mi">4</span>] [<span class="mi">3</span>; <span class="mi">4</span>] = Some [<span class="mi">1</span>; <span class="mi">2</span>]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> itauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk14b"><span class="kn">Lemma</span> <span class="nf">complete_suffix_correct</span> `{EqDecision A} :
  <span class="kr">forall</span> (<span class="nv">l</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A),
    l = pref ++ <span class="nb">suff</span> &lt;-&gt; complete_suffix l <span class="nb">suff</span> = Some pref.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A,
  l = pref ++ <span class="nb">suff</span>
  â†” complete_suffix l <span class="nb">suff</span> = Some pref</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk14c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">pref</span> <span class="nv">suff</span> : list A,
  l = pref ++ <span class="nb">suff</span>
  â†” complete_suffix l <span class="nb">suff</span> = Some pref</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk14d"><span class="nb">split</span>; <span class="nb">unfold</span> complete_suffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = pref ++ <span class="nb">suff</span>
â†’ <span class="kr">match</span> complete_prefix (rev l) (rev <span class="nb">suff</span>) <span class="kr">with</span>
  | Some ls =&gt; Some (rev ls)
  | None =&gt; None
  <span class="kr">end</span> = Some pref</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk14e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk14e"><hr></label><div class="goal-conclusion"><span class="kr">match</span> complete_prefix (rev l) (rev <span class="nb">suff</span>) <span class="kr">with</span>
| Some ls =&gt; Some (rev ls)
| None =&gt; None
<span class="kr">end</span> = Some pref â†’ l = pref ++ <span class="nb">suff</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk14f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = pref ++ <span class="nb">suff</span>
â†’ <span class="kr">match</span> complete_prefix (rev l) (rev <span class="nb">suff</span>) <span class="kr">with</span>
  | Some ls =&gt; Some (rev ls)
  | None =&gt; None
  <span class="kr">end</span> = Some pref</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk150"><span class="nb">intros</span> -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  complete_prefix (rev (pref ++ <span class="nb">suff</span>)) (rev <span class="nb">suff</span>)
<span class="kr">with</span>
| Some ls =&gt; Some (rev ls)
| None =&gt; None
<span class="kr">end</span> = Some pref</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk151"><span class="nb">replace</span> (complete_prefix _ _) <span class="kr">with</span> (Some (rev pref)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (rev (rev pref)) = Some pref</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk152" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk152"><hr></label><div class="goal-conclusion">Some (rev pref) =
complete_prefix (rev (pref ++ <span class="nb">suff</span>)) (rev <span class="nb">suff</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk153">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (rev (rev pref)) = Some pref</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> rev_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk154">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (rev pref) =
complete_prefix (rev (pref ++ <span class="nb">suff</span>)) (rev <span class="nb">suff</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk155"><span class="nb">symmetry</span>; <span class="nb">apply</span> complete_prefix_correct.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (pref ++ <span class="nb">suff</span>) = rev <span class="nb">suff</span> ++ rev pref</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> rev_app_distr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk156">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, pref, suff</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> complete_prefix (rev l) (rev <span class="nb">suff</span>) <span class="kr">with</span>
| Some ls =&gt; Some (rev ls)
| None =&gt; None
<span class="kr">end</span> = Some pref â†’ l = pref ++ <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk157"><span class="nb">destruct</span> (complete_prefix (rev l) (rev <span class="nb">suff</span>)) <span class="nb">eqn</span>: Heq; <span class="nb">intros</span> [= &lt;-].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, suff, l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>complete_prefix (rev l) (rev <span class="nb">suff</span>) = Some l0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = rev l0 ++ <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk158"><span class="nb">apply</span> complete_prefix_correct <span class="kr">in</span> Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, suff, l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>rev l = rev <span class="nb">suff</span> ++ l0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = rev l0 ++ <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk159"><span class="nb">apply</span> rev_eq_app <span class="kr">in</span> Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, suff, l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>l = rev l0 ++ rev (rev <span class="nb">suff</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l = rev l0 ++ <span class="nb">suff</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> rev_involutive <span class="kr">in</span> Heq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk15a"><span class="kn">Lemma</span> <span class="nf">complete_suffix_empty</span> `{EqDecision A} :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A),
    complete_suffix l [] = Some l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, complete_suffix l [] = Some l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk15b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, complete_suffix l [] = Some l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk15c"><span class="nb">unfold</span> complete_suffix; <span class="nb">cbn</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> complete_prefix (rev l) [] <span class="kr">with</span>
| Some ls =&gt; Some (rev ls)
| None =&gt; None
<span class="kr">end</span> = Some l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> complete_prefix_empty, rev_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
Keep elements which are <span class="inlinecode"><span class="id" title="var">inl</span></span> but throw away those that are <span class="inlinecode"><span class="id" title="var">inr</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">list_sum_project_left</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : list (A + B)) : list A :=
  omap sum_project_left x.</span></span></pre><div class="doc">
Keep elements which are <span class="inlinecode"><span class="id" title="var">inr</span></span> but throw away those that are <span class="inlinecode"><span class="id" title="var">inl</span></span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">list_sum_project_right</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : list (A + B)) : list B :=
  omap sum_project_right x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk15d"><span class="kn">Lemma</span> <span class="nf">fold_right_andb_false</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list bool),
    fold_right andb false l = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list bool, foldr andb false l = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk15e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list bool, foldr andb false l = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk15f"><span class="nb">induction</span> l; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list bool</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>foldr andb false l = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a &amp;&amp; foldr andb false l = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHl, andb_false_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk160"><span class="kn">Lemma</span> <span class="nf">sumbool_forall</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">P</span> <span class="nv">Q</span> : A -&gt; <span class="kt">Prop</span>},
    (<span class="kr">forall</span> <span class="nv">x</span> : A, {P x} + {Q x}) -&gt;
    <span class="kr">forall</span> <span class="nv">l</span> : list A, {Forall P l} + {Exists Q l}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">x</span> : A, {P x} + {Q x})
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, {Forall P l} + {Exists Q l}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk161"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">x</span> : A, {P x} + {Q x})
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, {Forall P l} + {Exists Q l}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk162"><span class="nb">intros</span> A P Q Hdec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, {P x} + {Q x}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, {Forall P l} + {Exists Q l}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk163"><span class="nb">induction</span> l; [<span class="bp">by</span> <span class="nb">left</span>; <span class="nb">constructor</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, {P x} + {Q x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>{Forall P l} + {Exists Q l}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Forall P (a :: l)} + {Exists Q (a :: l)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk164"><span class="nb">destruct</span> (Hdec a); [| <span class="bp">by</span> <span class="nb">right</span>; <span class="nb">constructor</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, {P x} + {Q x}</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>{Forall P l} + {Exists Q l}</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{Forall P (a :: l)} + {Exists Q (a :: l)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> IHl; [<span class="nb">left</span> | <span class="nb">right</span>]; <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk165"><span class="kn">Lemma</span> <span class="nf">list_sum_map</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; nat) (<span class="nv">l</span> : list A),
    (<span class="kr">forall</span> <span class="nv">x</span> : A, x âˆˆ l -&gt; f x &lt;= g x) -&gt;
      list_sum (map f l) &lt;= list_sum (map g l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : A â†’ nat) (<span class="nv">l</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l â†’ f x â‰¤ g x)
  â†’ list_sum (map f l) â‰¤ list_sum (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk166"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : A â†’ nat) (<span class="nv">l</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l â†’ f x â‰¤ g x)
  â†’ list_sum (map f l) â‰¤ list_sum (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk167"><span class="nb">induction</span> l <span class="kr">as</span> [| h t]; <span class="nb">cbn</span>; <span class="nb">intros</span> Hle; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ t â†’ f x â‰¤ g x) â†’ list_sum (map f t) â‰¤ list_sum (map g t)</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ h :: t â†’ f x â‰¤ g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f h + foldr Init.Nat.add <span class="mi">0</span> (map f t)
â‰¤ g h + foldr Init.Nat.add <span class="mi">0</span> (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk168"><span class="nb">apply</span> PeanoNat.Nat.add_le_mono.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ t â†’ f x â‰¤ g x) â†’ list_sum (map f t) â‰¤ list_sum (map g t)</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ h :: t â†’ f x â‰¤ g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f h â‰¤ g h</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk169" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ t â†’ f x â‰¤ g x) â†’ list_sum (map f t) â‰¤ list_sum (map g t)</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ h :: t â†’ f x â‰¤ g x</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk169"><hr></label><div class="goal-conclusion">foldr Init.Nat.add <span class="mi">0</span> (map f t)
â‰¤ foldr Init.Nat.add <span class="mi">0</span> (map g t)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk16a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ t â†’ f x â‰¤ g x) â†’ list_sum (map f t) â‰¤ list_sum (map g t)</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ h :: t â†’ f x â‰¤ g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f h â‰¤ g h</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hle; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk16b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ t â†’ f x â‰¤ g x) â†’ list_sum (map f t) â‰¤ list_sum (map g t)</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ h :: t â†’ f x â‰¤ g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr Init.Nat.add <span class="mi">0</span> (map f t)
â‰¤ foldr Init.Nat.add <span class="mi">0</span> (map g t)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk16c"><span class="nb">apply</span> IHt; <span class="nb">intros</span> x Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ t â†’ f x â‰¤ g x) â†’ list_sum (map f t) â‰¤ list_sum (map g t)</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ h :: t â†’ f x â‰¤ g x</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>x âˆˆ t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x â‰¤ g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hle; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk16d"><span class="kn">Lemma</span> <span class="nf">list_sum_decrease</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">f</span> <span class="nv">g</span> : A -&gt; nat) (<span class="nv">l</span> : list A),
    (<span class="kr">forall</span> <span class="nv">a</span>, a âˆˆ l -&gt; f a &lt;= g a) -&gt;
    Exists (<span class="kr">fun</span> <span class="nv">a</span> =&gt; f a &lt; g a) l -&gt;
      list_sum (map f l) &lt; list_sum (map g l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : A â†’ nat) (<span class="nv">l</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a)
  â†’ Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l
    â†’ list_sum (map f l) &lt; list_sum (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk16e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : A â†’ nat) (<span class="nv">l</span> : list A),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a)
  â†’ Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l
    â†’ list_sum (map f l) &lt; list_sum (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk16f"><span class="nb">intros</span> A f g l Hall Hex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">list_sum (map f l) &lt; list_sum (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk170"><span class="nb">induction</span> Hex; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x &lt; g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x + foldr Init.Nat.add <span class="mi">0</span> (map f l) &lt;
g x + foldr Init.Nat.add <span class="mi">0</span> (map g l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk171" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l</span></span></span><br><span><var>IHHex</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a)
â†’ list_sum (map f l) &lt; list_sum (map g l)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk171"><hr></label><div class="goal-conclusion">f x + foldr Init.Nat.add <span class="mi">0</span> (map f l) &lt;
g x + foldr Init.Nat.add <span class="mi">0</span> (map g l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk172">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x &lt; g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x + foldr Init.Nat.add <span class="mi">0</span> (map f l) &lt;
g x + foldr Init.Nat.add <span class="mi">0</span> (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk173"><span class="nb">apply</span> PeanoNat.Nat.add_lt_le_mono; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x &lt; g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr Init.Nat.add <span class="mi">0</span> (map f l)
â‰¤ foldr Init.Nat.add <span class="mi">0</span> (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk174"><span class="nb">apply</span> list_sum_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x &lt; g x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">x</span> : A, x âˆˆ l â†’ f x â‰¤ g x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk175"><span class="nb">intros</span> a&#39; Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f x &lt; g x</span></span></span><br><span><var>a'</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>a&#39; âˆˆ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a&#39; â‰¤ g a&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hall; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk176">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l</span></span></span><br><span><var>IHHex</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a)
â†’ list_sum (map f l) &lt; list_sum (map g l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f x + foldr Init.Nat.add <span class="mi">0</span> (map f l) &lt;
g x + foldr Init.Nat.add <span class="mi">0</span> (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk177"><span class="nb">apply</span> PeanoNat.Nat.add_le_lt_mono; [<span class="bp">by</span> <span class="nb">apply</span> Hall; <span class="nb">left</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l</span></span></span><br><span><var>IHHex</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a)
â†’ list_sum (map f l) &lt; list_sum (map g l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr Init.Nat.add <span class="mi">0</span> (map f l) &lt;
foldr Init.Nat.add <span class="mi">0</span> (map g l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk178"><span class="nb">apply</span> IHHex.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l</span></span></span><br><span><var>IHHex</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a)
â†’ list_sum (map f l) &lt; list_sum (map g l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk179"><span class="nb">intros</span> a Hin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>A â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ x :: l â†’ f a â‰¤ g a</span></span></span><br><span><var>Hex</var><span class="hyp-type"><b>: </b><span>Exists (<span class="kr">Î»</span> <span class="nv">a</span> : A, f a &lt; g a) l</span></span></span><br><span><var>IHHex</var><span class="hyp-type"><b>: </b><span>(<span class="kr">âˆ€</span> <span class="nv">a</span> : A, a âˆˆ l â†’ f a â‰¤ g a)
â†’ list_sum (map f l) &lt; list_sum (map g l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hin</var><span class="hyp-type"><b>: </b><span>a âˆˆ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a â‰¤ g a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hall; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Nearly the natural induction principle for <span class="inlinecode"><span class="id" title="var">fold_left</span></span>.
  Useful if you can think of <span class="inlinecode"><span class="id" title="var">fold_left</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> as transforming
  a list into a <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">â†’</span> <span class="inlinecode"><span class="id" title="var">B</span></span> function, and can describe the
  effect with a <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">list</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">â†’</span> <span class="inlinecode"><span class="id" title="var">relation</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>.
  The assumption <span class="inlinecode"><span class="id" title="var">Hstep</span></span> could be weakened by replacing <span class="inlinecode"><span class="id" title="var">r</span></span>
  with <span class="inlinecode"><span class="id" title="var">fold_left</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">l</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span>, but that isn't useful in
  natural examples.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk17a"><span class="kn">Lemma</span> <span class="nf">fold_left_ind</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A -&gt; B) (<span class="nv">P</span> : list A -&gt; B -&gt; B -&gt; <span class="kt">Prop</span>)
    (<span class="nv">Hstart</span> : <span class="kr">forall</span> <span class="nv">x</span>, P nil x x)
    (<span class="nv">Hstep</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">a</span> <span class="nv">l</span> <span class="nv">r</span>, P l (f x a) r -&gt; P (a :: l) x r),
  <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">x</span>, P l x (fold_left f l x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : B â†’ A â†’ B) (<span class="nv">P</span> : list A
                                    â†’ B â†’ B â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x x)
  â†’ (<span class="kr">âˆ€</span> (<span class="nv">x</span> : B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">r</span> : B),
       P l (f x a) r â†’ P (a :: l) x r)
    â†’ <span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">x</span> : B), P l x (fold_left f l x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk17b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : B â†’ A â†’ B) (<span class="nv">P</span> : list A
                                    â†’ B â†’ B â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x x)
  â†’ (<span class="kr">âˆ€</span> (<span class="nv">x</span> : B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">r</span> : B),
       P l (f x a) r â†’ P (a :: l) x r)
    â†’ <span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">x</span> : B), P l x (fold_left f l x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk17c"><span class="nb">induction</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x x</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x</span> : B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">r</span> : B),
  P l (f x a) r â†’ P (a :: l) x r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x (fold_left f [] x)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk17d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x x</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x</span> : B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">r</span> : B),
  P l (f x a) r â†’ P (a :: l) x r</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P l x (fold_left f l x)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk17d"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P (a :: l) x (fold_left f (a :: l) x)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk17e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x x</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x</span> : B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">r</span> : B),
  P l (f x a) r â†’ P (a :: l) x r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x (fold_left f [] x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hstart.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk17f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P [] x x</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">x</span> : B) (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A) (<span class="nv">r</span> : B),
  P l (f x a) r â†’ P (a :: l) x r</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P l x (fold_left f l x)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">x</span> : B, P (a :: l) x (fold_left f (a :: l) x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> x; <span class="nb">apply</span> Hstep, IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  An induction principle for <span class="inlinecode"><span class="id" title="var">fold_left</span></span> which
  decomposes the list from the right.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk180"><span class="kn">Lemma</span> <span class="nf">fold_left_ind_rev</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A -&gt; B) (<span class="nv">x0</span> : B) (<span class="nv">P</span> : list A -&gt; B -&gt; <span class="kt">Prop</span>)
    (<span class="nv">Hstart</span> : P nil x0)
    (<span class="nv">Hstep</span> : <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">a</span> <span class="nv">x</span>, P l x -&gt; P (l ++ [a]) (f x a)),
  <span class="kr">forall</span> <span class="nv">l</span>, P l (fold_left f l x0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : B â†’ A â†’ B) (<span class="nv">x0</span> : B) (<span class="nv">P</span> : list A
                                             â†’ B
                                               â†’ <span class="kt">Prop</span>),
  P [] x0
  â†’ (<span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A) (<span class="nv">x</span> : B),
       P l x â†’ P (l ++ [a]) (f x a))
    â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, P l (fold_left f l x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk181"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : B â†’ A â†’ B) (<span class="nv">x0</span> : B) (<span class="nv">P</span> : list A
                                             â†’ B
                                               â†’ <span class="kt">Prop</span>),
  P [] x0
  â†’ (<span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A) (<span class="nv">x</span> : B),
       P l x â†’ P (l ++ [a]) (f x a))
    â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, P l (fold_left f l x0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk182"><span class="nb">induction</span> l <span class="nb">using</span> rev_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span>P [] x0</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A) (<span class="nv">x</span> : B),
  P l x â†’ P (l ++ [a]) (f x a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P [] (fold_left f [] x0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk183" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span>P [] x0</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A) (<span class="nv">x</span> : B),
  P l x â†’ P (l ++ [a]) (f x a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>P l (fold_left f l x0)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk183"><hr></label><div class="goal-conclusion">P (l ++ [x]) (fold_left f (l ++ [x]) x0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk184">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span>P [] x0</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A) (<span class="nv">x</span> : B),
  P l x â†’ P (l ++ [a]) (f x a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P [] (fold_left f [] x0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hstart.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk185">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>B â†’ A â†’ B</span></span></span><br><span><var>x0</var><span class="hyp-type"><b>: </b><span>B</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ B â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Hstart</var><span class="hyp-type"><b>: </b><span>P [] x0</span></span></span><br><span><var>Hstep</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">a</span> : A) (<span class="nv">x</span> : B),
  P l x â†’ P (l ++ [a]) (f x a)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>P l (fold_left f l x0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (l ++ [x]) (fold_left f (l ++ [x]) x0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> fold_left_app; <span class="nb">apply</span> Hstep.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_suffix_quantifiers</span>.</span></span></pre><div class="doc">
<a id="lab2"></a><h2 class="section">Quantifiers for all suffixes</h2>
<div class="paragraph"> </div>

  In this section we define inductive quantifiers for lists that are concerned
  with predicates over the sublists of the list instead of the elements. They
  are analogous to <span class="inlinecode"><span class="id" title="var">Streams.ForAll</span></span> and <span class="inlinecode"><span class="id" title="var">Streams.Exists</span></span>. We prove several
  properties about them.

<div class="paragraph"> </div>

  Among the definitions, the more useful are <span class="inlinecode"><span class="id" title="var">ForAllSuffix2</span></span> and <span class="inlinecode"><span class="id" title="var">ExistsSuffix2</span></span>
  as they allow us to quantify over relations between consecutive elements.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  [A : <span class="kt">Type</span>]
  (P : list A -&gt; <span class="kt">Prop</span>)
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ExistsSuffix</span> : list A -&gt; <span class="kt">Prop</span> :=
| SHere : <span class="kr">forall</span> <span class="nv">l</span>, P l -&gt; ExistsSuffix l
| SFurther : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">l</span>, ExistsSuffix l -&gt; ExistsSuffix (a :: l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">ForAllSuffix</span> : list A -&gt; <span class="kt">Prop</span> :=
| SNil : P [] -&gt; ForAllSuffix []
| SHereAndFurther : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">l</span>, P (a :: l) -&gt; ForAllSuffix l -&gt; ForAllSuffix (a :: l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk186"><span class="kn">Lemma</span> <span class="nf">fsHere</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A),
    ForAllSuffix l -&gt; P l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, ForAllSuffix l â†’ P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk187"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, ForAllSuffix l â†’ P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk188"><span class="kn">Lemma</span> <span class="nf">fsFurther</span> :
  <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
    ForAllSuffix (a :: l) -&gt; ForAllSuffix l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  ForAllSuffix (a :: l) â†’ ForAllSuffix l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk189"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  ForAllSuffix (a :: l) â†’ ForAllSuffix l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk18a"><span class="kn">Lemma</span> <span class="nf">ForAll_drop</span> :
  <span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A),
    ForAllSuffix l -&gt; ForAllSuffix (drop m l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A),
  ForAllSuffix l â†’ ForAllSuffix (drop m l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk18b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">m</span> : nat) (<span class="nv">l</span> : list A),
  ForAllSuffix l â†’ ForAllSuffix (drop m l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk18c"><span class="nb">induction</span> m; <span class="nb">intros</span> [] Hall; <span class="nb">cbn</span>; [<span class="bp">done</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHm</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, ForAllSuffix l â†’ ForAllSuffix (drop m l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span>ForAllSuffix (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix (drop m l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> fsFurther <span class="kr">in</span> Hall; <span class="nb">apply</span> IHm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk18d"><span class="kn">Lemma</span> <span class="nf">ForAllSuffix_induction</span> :
  <span class="kr">forall</span> (<span class="nv">Inv</span> : list A -&gt; <span class="kt">Prop</span>)
    (<span class="nv">InvThenP</span> : <span class="kr">forall</span> <span class="nv">l</span>, Inv l -&gt; P l)
    (<span class="nv">InvIsStable</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">l</span>, Inv (a :: l) -&gt; Inv l),
  <span class="kr">forall</span> <span class="nv">l</span>, Inv l -&gt; ForAllSuffix l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Inv</span> : list A â†’ <span class="kt">Prop</span>,
  (<span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l)
  â†’ (<span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A), Inv (a :: l) â†’ Inv l)
    â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ ForAllSuffix l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk18e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">Inv</span> : list A â†’ <span class="kt">Prop</span>,
  (<span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l)
  â†’ (<span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A), Inv (a :: l) â†’ Inv l)
    â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ ForAllSuffix l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk18f"><span class="nb">induction</span> l; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk190" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Inv l â†’ ForAllSuffix l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv (a :: l)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk190"><hr></label><div class="goal-conclusion">ForAllSuffix (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk191">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">constructor</span>; <span class="nb">apply</span> InvThenP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk192" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk192">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Inv l â†’ ForAllSuffix l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk193"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Inv l â†’ ForAllSuffix l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (a :: l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk194" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Inv l â†’ ForAllSuffix l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv (a :: l)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk194"><hr></label><div class="goal-conclusion">ForAllSuffix l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk195">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Inv l â†’ ForAllSuffix l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> InvThenP.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk196">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Inv</var><span class="hyp-type"><b>: </b><span>list A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>InvThenP</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Inv l â†’ P l</span></span></span><br><span><var>InvIsStable</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
  Inv (a :: l) â†’ Inv l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Inv l â†’ ForAllSuffix l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Inv (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> IHl, InvIsStable.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_suffix_quantifiers</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk197"><span class="kn">Lemma</span> <span class="nf">ForAllSuffix_subsumption</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> <span class="nv">Q</span> : list A -&gt; <span class="kt">Prop</span>) (<span class="nv">HPQ</span> : <span class="kr">forall</span> <span class="nv">l</span>, P l -&gt; Q l),
    <span class="kr">forall</span> (<span class="nv">l</span> : list A), ForAllSuffix P l -&gt; ForAllSuffix Q l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : list A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">l</span> : list A, P l â†’ Q l)
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, ForAllSuffix P l â†’ ForAllSuffix Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk198"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> <span class="nv">Q</span> : list A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">l</span> : list A, P l â†’ Q l)
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, ForAllSuffix P l â†’ ForAllSuffix Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> <span class="mi">2</span>; <span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ForAllSuffix2</span> [A : <span class="kt">Type</span>] (R : A -&gt; A -&gt; <span class="kt">Prop</span>) : list A -&gt; <span class="kt">Prop</span> :=
  ForAllSuffix (<span class="kr">fun</span> <span class="nv">l</span> =&gt; <span class="kr">match</span> l <span class="kr">with</span> | a :: b :: _ =&gt; R a b | _ =&gt; <span class="kt">True</span> <span class="kr">end</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk199"><span class="kn">Lemma</span> <span class="nf">fsFurther2_transitive</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) {<span class="nv">HT</span> : Transitive R} (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">l</span> : list A),
    ForAllSuffix2 R (a :: b :: l) -&gt; ForAllSuffix2 R (a :: l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A â†’ A â†’ <span class="kt">Prop</span>),
  Transitive R
  â†’ <span class="kr">âˆ€</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">l</span> : list A),
      ForAllSuffix2 R (a :: b :: l)
      â†’ ForAllSuffix2 R (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk19a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk19a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A â†’ A â†’ <span class="kt">Prop</span>),
  Transitive R
  â†’ <span class="kr">âˆ€</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">l</span> : list A),
      ForAllSuffix2 R (a :: b :: l)
      â†’ ForAllSuffix2 R (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk19b"><span class="nb">inversion</span> <span class="mi">2</span>; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: b :: l)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">Î»</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) (b :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk19c"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R [a; b]</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">Î»</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) [b]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R [a]</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk19d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>a, b, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: b :: a0 :: l)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">Î»</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) (b :: a0 :: l)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk19d"><hr></label><div class="goal-conclusion">ForAllSuffix2 R (a :: a0 :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk19e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R [a; b]</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">Î»</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) [b]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R [a]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kp">repeat</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk19f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>a, b, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: b :: a0 :: l)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">Î»</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) (b :: a0 :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R (a :: a0 :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a0"><span class="nb">inversion</span> H3; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>a, b, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: b :: a0 :: l)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>R a b</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">Î»</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) (b :: a0 :: l)</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>R b a0</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>ForAllSuffix
  (<span class="kr">Î»</span> <span class="nv">l</span> : list A,
     <span class="kr">match</span> l <span class="kr">with</span>
     | [] =&gt; <span class="kt">True</span>
     | [a] =&gt; <span class="kt">True</span>
     | a :: b :: _ =&gt; R a b
     <span class="kr">end</span>) (a0 :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R (a :: a0 :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">constructor</span>; [<span class="nb">transitivity</span> b |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a1"><span class="kn">Lemma</span> <span class="nf">ForAllSuffix2_filter</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) {<span class="nv">HT</span> : Transitive R}
    (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>) {<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)},
  <span class="kr">forall</span> <span class="nv">l</span>, ForAllSuffix2 R l -&gt; ForAllSuffix2 R (filter P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A â†’ A â†’ <span class="kt">Prop</span>),
  Transitive R
  â†’ <span class="kr">âˆ€</span> (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)) 
      (<span class="nv">l</span> : list A),
      ForAllSuffix2 R l â†’ ForAllSuffix2 R (filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A â†’ A â†’ <span class="kt">Prop</span>),
  Transitive R
  â†’ <span class="kr">âˆ€</span> (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">Pdec</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)) 
      (<span class="nv">l</span> : list A),
      ForAllSuffix2 R l â†’ ForAllSuffix2 R (filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a3"><span class="nb">induction</span> l; <span class="nb">intros</span> Hl; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R l â†’ ForAllSuffix2 R (filter P l)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R (filter P (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a4"><span class="nb">unfold</span> filter; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R l â†’ ForAllSuffix2 R (filter P l)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R
  (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span> a :: filter P l
   <span class="kr">else</span> filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a5">spec IHl; [<span class="bp">by</span> <span class="nb">apply</span> fsFurther <span class="kr">in</span> Hl |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (filter P l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R
  (<span class="kr">if</span> decide (P a)
   <span class="kr">then</span> a :: filter P l
   <span class="kr">else</span> filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a6">case_decide; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (filter P l)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ForAllSuffix2 R (a :: filter P l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a7"><span class="nb">constructor</span>; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (filter P l)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> filter P l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a8"><span class="nb">clear</span> IHl H; <span class="nb">induction</span> l; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: a0 :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)
â†’ <span class="kr">match</span> filter P l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b :: _ =&gt; R a b
  <span class="kr">end</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  (<span class="kr">if</span> decide (P a0)
   <span class="kr">then</span> a0 :: filter P l
   <span class="kr">else</span> filter P l)
<span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1a9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1a9">case_decide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: a0 :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)
â†’ <span class="kr">match</span> filter P l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b :: _ =&gt; R a b
  <span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk1aa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: a0 :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)
â†’ <span class="kr">match</span> filter P l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b :: _ =&gt; R a b
  <span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Â¬ P a0</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk1aa"><hr></label><div class="goal-conclusion"><span class="kr">match</span> filter P l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ab">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: a0 :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)
â†’ <span class="kr">match</span> filter P l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b :: _ =&gt; R a b
  <span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>P a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">R a a0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> Hl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ac">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A â†’ A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>HT</var><span class="hyp-type"><b>: </b><span>Transitive R</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: a0 :: l)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>ForAllSuffix2 R (a :: l)
â†’ <span class="kr">match</span> filter P l <span class="kr">with</span>
  | [] =&gt; <span class="kt">True</span>
  | b :: _ =&gt; R a b
  <span class="kr">end</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Â¬ P a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> filter P l <span class="kr">with</span>
| [] =&gt; <span class="kt">True</span>
| b :: _ =&gt; R a b
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHl; <span class="nb">eapply</span> fsFurther2_transitive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ad"><span class="kn">Lemma</span> <span class="nf">list_subseteq_tran</span> :
  <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span> : list A),
    l âŠ† m -&gt; m âŠ† n -&gt; l âŠ† n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span> : list A), l âŠ† m â†’ m âŠ† n â†’ l âŠ† n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ae"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span> : list A), l âŠ† m â†’ m âŠ† n â†’ l âŠ† n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1af"><span class="nb">intros</span> A l m n Hlm Hmn x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, m, n</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlm</var><span class="hyp-type"><b>: </b><span>l âŠ† m</span></span></span><br><span><var>Hmn</var><span class="hyp-type"><b>: </b><span>m âŠ† n</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>x âˆˆ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x âˆˆ n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hmn, Hlm.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b0">#[export] <span class="kn">Instance</span> <span class="nf">list_subseteq_dec</span> `{EqDecision A} : RelDecision (@subseteq (list A) _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RelDecision subseteq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RelDecision subseteq</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b2"><span class="nb">intros</span> x; <span class="nb">induction</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision ([] âŠ† y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk1b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk1b3"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (a :: x âŠ† y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision ([] âŠ† y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span> list_subseteq_nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (a :: x âŠ† y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b6"><span class="nb">intros</span> y; <span class="nb">destruct</span> (IHx y) <span class="kr">as</span> [Hsub | Hnsub].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>x âŠ† y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk1b7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnsub</var><span class="hyp-type"><b>: </b><span>x âŠˆ y</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk1b7"><hr></label><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b8">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>x âŠ† y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1b9"><span class="nb">destruct</span> (decide (a âˆˆ y)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>x âŠ† y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a âˆˆ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk1ba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>x âŠ† y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a âˆ‰ y</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk1ba"><hr></label><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1bb">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>x âŠ† y</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>a âˆˆ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>; [| <span class="nb">apply</span> Hsub].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1bc">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>x âŠ† y</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>a âˆ‰ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">intros</span> Hsub&#39;; <span class="bp">contradict</span> n; <span class="nb">apply</span> Hsub&#39;; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1bd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hnsub</var><span class="hyp-type"><b>: </b><span>x âŠˆ y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (a :: x âŠ† y)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1be"><span class="nb">right</span>; <span class="nb">intros</span> Hsub; <span class="bp">contradict</span> Hnsub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHx</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : list A, Decision (x âŠ† y)</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsub</var><span class="hyp-type"><b>: </b><span>a :: x âŠ† y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x âŠ† y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> b Hb; <span class="nb">apply</span> Hsub; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1bf"><span class="kn">Lemma</span> <span class="nf">nodup_append_left</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    NoDup (l1 ++ l2) -&gt; NoDup l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  NoDup (l1 ++ l2) â†’ NoDup l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  NoDup (l1 ++ l2) â†’ NoDup l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> * [? _]%NoDup_app.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c1"><span class="kn">Lemma</span> <span class="nf">NoDup_subseteq_length</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">l1</span> <span class="nv">l2</span> : list A},
    NoDup l1 -&gt; l1 âŠ† l2 -&gt; length l1 &lt;= length l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  NoDup l1 â†’ l1 âŠ† l2 â†’ length l1 â‰¤ length l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  NoDup l1 â†’ l1 âŠ† l2 â†’ length l1 â‰¤ length l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">apply</span> submseteq_length, NoDup_submseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c3"><span class="kn">Lemma</span> <span class="nf">submseteq_tail_l</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">x</span> : A) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    x :: l1 âŠ†+ l2 -&gt; l1 âŠ†+ l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  x :: l1 âŠ†+ l2 â†’ l1 âŠ†+ l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  x :: l1 âŠ†+ l2 â†’ l1 âŠ†+ l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> A x l1 l2; <span class="nb">apply</span> submseteq_trans, submseteq_cons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c5"><span class="kn">Lemma</span> <span class="nf">submseteq_list_subseteq</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    l1 âŠ†+ l2 -&gt; l1 âŠ† l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A), l1 âŠ†+ l2 â†’ l1 âŠ† l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A), l1 âŠ†+ l2 â†’ l1 âŠ† l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> A l1 l2 H ? Hx; <span class="nb">eapply</span> elem_of_submseteq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c7"><span class="kn">Lemma</span> <span class="nf">take_app_inv</span> :
  <span class="kr">forall</span> [A : <span class="kt">Type</span>] (n : nat) (l l&#39; : list A) (x : A),
    take n l = l&#39; ++ [x] -&gt; <span class="kr">exists</span> <span class="nv">n&#39;</span> : nat, n = S n&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">x</span> : A),
  take n l = l&#39; ++ [x] â†’ <span class="kr">âˆƒ</span> <span class="nv">n&#39;</span> : nat, n = S n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">x</span> : A),
  take n l = l&#39; ++ [x] â†’ <span class="kr">âˆƒ</span> <span class="nv">n&#39;</span> : nat, n = S n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1c9"><span class="nb">induction</span> n <span class="kr">as</span> [| n&#39;]; <span class="nb">intros</span> l l&#39; x H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>take <span class="mi">0</span> l = l&#39; ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">n&#39;</span> : nat, <span class="mi">0</span> = S n&#39;</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk1ca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">x</span> : A),
  take n&#39; l = l&#39; ++ [x]
  â†’ <span class="kr">âˆƒ</span> <span class="nv">n&#39;0</span> : nat, n&#39; = S n&#39;0</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>take (S n&#39;) l = l&#39; ++ [x]</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk1ca"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">n&#39;0</span> : nat, S n&#39; = S n&#39;0</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1cb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1cb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>take <span class="mi">0</span> l = l&#39; ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">n&#39;</span> : nat, <span class="mi">0</span> = S n&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> take_0 <span class="kr">in</span> H; <span class="nb">apply</span> app_cons_not_nil <span class="kr">in</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1cc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n'</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn'</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) (<span class="nv">x</span> : A),
  take n&#39; l = l&#39; ++ [x]
  â†’ <span class="kr">âˆƒ</span> <span class="nv">n&#39;0</span> : nat, n&#39; = S n&#39;0</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>take (S n&#39;) l = l&#39; ++ [x]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">n&#39;0</span> : nat, S n&#39; = S n&#39;0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">n&#39;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1cd"><span class="kn">Lemma</span> <span class="nf">elem_of_list_prod</span> :
  <span class="kr">forall</span> [A B : <span class="kt">Type</span>] (x : A) (y : B) (la : list A) (lb : list B),
    (x, y) âˆˆ list_prod la lb &lt;-&gt; x âˆˆ la /\ y âˆˆ lb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">la</span> : list A) (<span class="nv">lb</span> : 
                                              list B),
  (x, y) âˆˆ list_prod la lb â†” x âˆˆ la âˆ§ y âˆˆ lb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ce"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">la</span> : list A) (<span class="nv">lb</span> : 
                                              list B),
  (x, y) âˆˆ list_prod la lb â†” x âˆˆ la âˆ§ y âˆˆ lb</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">rewrite</span> elem_of_list_In, in_prod_iff, &lt;- !elem_of_list_In.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<a id="lab3"></a><h2 class="section">The function <span class="inlinecode"><span class="id" title="var">lastn</span></span> and its properties</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">lastn</span></span> returns a suffix of length <code>n</code> from the list <code>l</code>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lastn</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A) : list A :=
  rev (take n (rev l)).</span></span></pre><div class="doc">
If the list is <span class="inlinecode">[]</span>, then the result of <span class="inlinecode"><span class="id" title="var">lastn</span></span> is also <span class="inlinecode">[]</span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1cf"><span class="kn">Lemma</span> <span class="nf">lastn_nil</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat),
    lastn n (@nil A) = [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat), lastn n [] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat), lastn n [] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> A n; <span class="nb">unfold</span> lastn; <span class="nb">cbn</span>; <span class="nb">rewrite</span> take_nil.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
If <code>n</code> is zero, then the result of <span class="inlinecode"><span class="id" title="var">lastn</span></span> is <span class="inlinecode">[]</span>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d1"><span class="kn">Lemma</span> <span class="nf">lastn_0</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A),
    lastn <span class="mi">0</span> l = [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A), lastn <span class="mi">0</span> l = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A), lastn <span class="mi">0</span> l = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> A l; <span class="nb">unfold</span> lastn; <span class="nb">rewrite</span> take_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
If <code>n</code> is greater than the length of the list, <span class="inlinecode"><span class="id" title="var">lastn</span></span> returns the whole list. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d3"><span class="kn">Lemma</span> <span class="nf">lastn_ge</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
    length l &lt;= n -&gt; lastn n l = l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  length l â‰¤ n â†’ lastn n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  length l â‰¤ n â†’ lastn n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d5"><span class="nb">intros</span> A n l Hge.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hge</var><span class="hyp-type"><b>: </b><span>length l â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn n l = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d6"><span class="nb">unfold</span> lastn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hge</var><span class="hyp-type"><b>: </b><span>length l â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (take n (rev l)) = l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d7"><span class="nb">rewrite</span> take_ge.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hge</var><span class="hyp-type"><b>: </b><span>length l â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (rev l) = l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk1d8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hge</var><span class="hyp-type"><b>: </b><span>length l â‰¤ n</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk1d8"><hr></label><div class="goal-conclusion">length (rev l) â‰¤ n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1d9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1d9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hge</var><span class="hyp-type"><b>: </b><span>length l â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (rev l) = l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> rev_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1da" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hge</var><span class="hyp-type"><b>: </b><span>length l â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (rev l) â‰¤ n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> rev_length.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">lastn</span></span> skips the prefix of the list as long as the suffix is long enough. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1db"><span class="kn">Lemma</span> <span class="nf">lastn_app_le</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    n &lt;= length l2 -&gt; lastn n (l1 ++ l2) = lastn n l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  n â‰¤ length l2 â†’ lastn n (l1 ++ l2) = lastn n l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1dc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  n â‰¤ length l2 â†’ lastn n (l1 ++ l2) = lastn n l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1dd"><span class="nb">intros</span> A n l1 l2 Hlt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>n â‰¤ length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn n (l1 ++ l2) = lastn n l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1de"><span class="nb">unfold</span> lastn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>n â‰¤ length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (take n (rev (l1 ++ l2))) = rev (take n (rev l2))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1df"><span class="nb">rewrite</span> rev_app_distr, take_app_le; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlt</var><span class="hyp-type"><b>: </b><span>n â‰¤ length l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n â‰¤ length (rev l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> rev_length; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<span class="inlinecode"><span class="id" title="var">lastn</span></span> either skips the head of the list or not, depending on how big a suffix we want. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e0"><span class="kn">Lemma</span> <span class="nf">lastn_cons</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">h</span> : A) (<span class="nv">t</span> : list A),
    lastn n (h :: t) = <span class="kr">if</span> decide (S (length t) &lt;= n) <span class="kr">then</span> h :: t <span class="kr">else</span> lastn n t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">h</span> : A) (<span class="nv">t</span> : list A),
  lastn n (h :: t) =
  (<span class="kr">if</span> decide (S (length t) â‰¤ n)
   <span class="kr">then</span> h :: t
   <span class="kr">else</span> lastn n t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">h</span> : A) (<span class="nv">t</span> : list A),
  lastn n (h :: t) =
  (<span class="kr">if</span> decide (S (length t) â‰¤ n)
   <span class="kr">then</span> h :: t
   <span class="kr">else</span> lastn n t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e2"><span class="nb">intros</span> A n h t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn n (h :: t) =
(<span class="kr">if</span> decide (S (length t) â‰¤ n)
 <span class="kr">then</span> h :: t
 <span class="kr">else</span> lastn n t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e3">case_decide; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S (length t) â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn n (h :: t) = h :: t</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk1e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Â¬ S (length t) â‰¤ n</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk1e4"><hr></label><div class="goal-conclusion">lastn n (h :: t) = lastn n t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>S (length t) â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn n (h :: t) = h :: t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> lastn_ge; <span class="nb">cbn</span>; [| <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Â¬ S (length t) â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn n (h :: t) = lastn n t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> (lastn_app_le _ [h] t); [| <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
If <code>l1</code> is a prefix of <code>l2</code>, then the reverse of <code>l1</code> is a suffix of <code>l2</code>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e7"><span class="kn">Lemma</span> <span class="nf">suffix_rev</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    prefix l1 l2 -&gt; suffix (rev l1) (rev l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  l1 `prefix_of` l2 â†’ rev l1 `suffix_of` rev l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
  l1 `prefix_of` l2 â†’ rev l1 `suffix_of` rev l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1e9"><span class="nb">intros</span> A l1 l2 [l -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev l1 `suffix_of` rev (l1 ++ l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ea"><span class="nb">rewrite</span> rev_app_distr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l1, l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev l1 `suffix_of` rev l ++ rev l1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">rev</span> <span class="nv">l</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  If <code>n1</code> is less than (or equal to) <code>n2</code>, then <code>lastn n1 l</code> is shorter than
  <code>lastn n2 l</code> and therefore is its suffix.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1eb"><span class="kn">Lemma</span> <span class="nf">suffix_lastn</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
    n1 &lt;= n2 -&gt; suffix (lastn n1 l) (lastn n2 l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
  n1 â‰¤ n2 â†’ lastn n1 l `suffix_of` lastn n2 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ec"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">l</span> : list A) (<span class="nv">n1</span> <span class="nv">n2</span> : nat),
  n1 â‰¤ n2 â†’ lastn n1 l `suffix_of` lastn n2 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ed"><span class="nb">intros</span> A l n1 n2 Hle.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lastn n1 l `suffix_of` lastn n2 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ee"><span class="nb">unfold</span> lastn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (take n1 (rev l))
`suffix_of` rev (take n2 (rev l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ef"><span class="nb">apply</span> suffix_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n1 (rev l) `prefix_of` take n2 (rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f0"><span class="kr">exists</span> (<span class="nv">take</span> (n2 - n1) (drop n1 (rev l))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n2 (rev l) =
take n1 (rev l) ++ take (n2 - n1) (drop n1 (rev l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f1"><span class="nb">rewrite</span> take_take_drop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hle</var><span class="hyp-type"><b>: </b><span>n1 â‰¤ n2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">take n2 (rev l) = take (n1 + (n2 - n1)) (rev l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">f_equal</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
The length of <code>lastn n l</code> is the smaller of <code>n</code> and the length of <code>l</code>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f2"><span class="kn">Lemma</span> <span class="nf">length_lastn</span> :
  <span class="kr">forall</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
    length (lastn n l) = min n (length l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  length (lastn n l) = n `min` length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list A),
  length (lastn n l) = n `min` length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f4"><span class="nb">intros</span> A n l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (lastn n l) = n `min` length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f5"><span class="nb">unfold</span> lastn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (rev (take n (rev l))) = n `min` length l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> rev_length, take_length, rev_length.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">not_null_element</span>
  `{EqDecision A} [l : list A] (Hl : l &lt;&gt; []) : dsig (<span class="kr">fun</span> <span class="nv">i</span> =&gt; i âˆˆ l) :=
    dexist (is_Some_proj (proj2 (head_is_Some l) Hl)) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f6"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">A</span> : <span class="kt">Type</span>,
  EqDecision A
  â†’ <span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hl</span> : l â‰  []),
      (<span class="kr">Î»</span> <span class="nv">i</span> : A, i âˆˆ l)
        (is_Some_proj (proj2 (head_is_Some l) Hl))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">A</span> : <span class="kt">Type</span>,
  EqDecision A
  â†’ <span class="kr">âˆ€</span> (<span class="nv">l</span> : list A) (<span class="nv">Hl</span> : l â‰  []),
      (<span class="kr">Î»</span> <span class="nv">i</span> : A, i âˆˆ l)
        (is_Some_proj (proj2 (head_is_Some l) Hl))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> A ? [| h t] ?; [| <span class="nb">left</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">element_of_subseteq</span>
  `{EqDecision A} [l1 l2 : list A] (Hsub : l1 âŠ† l2)
  (di : dsig (<span class="kr">fun</span> <span class="nv">i</span> =&gt; i âˆˆ l1)) : dsig (<span class="kr">fun</span> <span class="nv">i</span> =&gt; i âˆˆ l2) :=
    dexist (` di) _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f8"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">EqDecision0</span> : EqDecision A) (<span class="nv">l1</span>
                                           <span class="nv">l2</span> : list A),
  l1 âŠ† l2
  â†’ <span class="kr">âˆ€</span> <span class="nv">di</span> : dsig (<span class="kr">Î»</span> <span class="nv">i</span> : A, i âˆˆ l1),
      (<span class="kr">Î»</span> <span class="nv">i</span> : A, i âˆˆ l2) (`di)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1f9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">EqDecision0</span> : EqDecision A) (<span class="nv">l1</span>
                                           <span class="nv">l2</span> : list A),
  l1 âŠ† l2
  â†’ <span class="kr">âˆ€</span> <span class="nv">di</span> : dsig (<span class="kr">Î»</span> <span class="nv">i</span> : A, i âˆˆ l1),
      (<span class="kr">Î»</span> <span class="nv">i</span> : A, i âˆˆ l2) (`di)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">cbn</span>; destruct_dec_sig di i Hi Heq; <span class="nb">subst</span>; <span class="nb">apply</span> Hsub.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">element_of_filter</span>
  `{EqDecision A} [P : A -&gt; <span class="kt">Prop</span>] `{<span class="kr">forall</span> <span class="nv">x</span>, Decision (P x)} [l : list A]
  : dsig (<span class="kr">fun</span> <span class="nv">i</span> =&gt; i âˆˆ filter P l) -&gt; dsig (<span class="kr">fun</span> <span class="nv">i</span> =&gt; i âˆˆ l) :=
  element_of_subseteq (list_filter_subseteq P l).</span></span></pre><div class="doc">
<a id="lab4"></a><h2 class="section">Computing longest common prefixes and suffixes</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
<a id="lab5"></a><h3 class="section">Longest common prefix</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_max_prefix</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  `{EqDecision A}
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1fa"><span class="kn">Lemma</span> <span class="nf">max_prefix_nil_l</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A),
    max_prefix [] l = ([], l, []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_prefix [] l = ([], l, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1fb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_prefix [] l = ([], l, [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1fc"><span class="kn">Lemma</span> <span class="nf">max_prefix_nil_r</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A),
    max_prefix l [] = (l, [], []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_prefix l [] = (l, [], [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1fd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_prefix l [] = (l, [], [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1fe"><span class="kn">Lemma</span> <span class="nf">max_prefix_diag</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A),
    max_prefix l l = ([], [], l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_prefix l l = ([], [], l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk1ff"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_prefix l l = ([], [], l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk200"><span class="nb">induction</span> l <span class="kr">as</span> [| h t]; <span class="nb">cbn</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>max_prefix t t = ([], [], t)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h h
 <span class="kr">then</span> prod_map id (cons h) (max_prefix t t)
 <span class="kr">else</span> (h :: t, h :: t, [])) = ([], [], h :: t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk201">case_decide; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span>max_prefix t t = ([], [], t)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_map id (cons h) (max_prefix t t) =
([], [], h :: t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> IHt; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk202"><span class="kn">Lemma</span> <span class="nf">max_prefix_head</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    head l1 &lt;&gt; head l2 -&gt; max_prefix l1 l2 = (l1, l2, []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  head l1 â‰  head l2 â†’ max_prefix l1 l2 = (l1, l2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk203"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  head l1 â‰  head l2 â†’ max_prefix l1 l2 = (l1, l2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk204"><span class="nb">intros</span> [] [] Hneq; <span class="nb">cbn</span> <span class="kr">in</span> *; [<span class="bp">done</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hneq</var><span class="hyp-type"><b>: </b><span>Some a â‰  Some a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq a a0
 <span class="kr">then</span> prod_map id (cons a) (max_prefix l l0)
 <span class="kr">else</span> (a :: l, a0 :: l0, [])) = (a :: l, a0 :: l0, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> case_decide; [<span class="bp">congruence</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk205" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk205"><span class="kn">Lemma</span> <span class="nf">max_prefix_app</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_prefix l1 l2 = (r1, r2, p) -&gt;
      max_prefix (l ++ l1) (l ++ l2) = (r1, r2, l ++ p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix (l ++ l1) (l ++ l2) = (r1, r2, l ++ p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk206" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk206"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix (l ++ l1) (l ++ l2) = (r1, r2, l ++ p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk207"><span class="nb">induction</span> l <span class="kr">as</span> [| h t]; <span class="nb">cbn</span>; <span class="nb">intros</span> * Heq; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix (t ++ l1) (t ++ l2) =
    (r1, r2, t ++ p)</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h h
 <span class="kr">then</span>
  prod_map id (cons h)
    (max_prefix (t ++ l1) (t ++ l2))
 <span class="kr">else</span> (h :: t ++ l1, h :: t ++ l2, [])) =
(r1, r2, h :: t ++ p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk208">case_decide; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix (t ++ l1) (t ++ l2) =
    (r1, r2, t ++ p)</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h = h</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_map id (cons h) (max_prefix (t ++ l1) (t ++ l2)) =
(r1, r2, h :: t ++ p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHt <span class="kr">in</span> Heq <span class="kr">as</span> -&gt;; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk209"><span class="kn">Lemma</span> <span class="nf">max_prefix_app_let</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A),
    max_prefix (l ++ l1) (l ++ l2) =
      <span class="kr">let</span> &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span> (r1, r2, l ++ p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_prefix (l ++ l1) (l ++ l2) =
  (<span class="kr">let</span>
   &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span>
    (r1, r2, l ++ p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk20a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_prefix (l ++ l1) (l ++ l2) =
  (<span class="kr">let</span>
   &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span>
    (r1, r2, l ++ p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk20b"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix (l ++ l1) (l ++ l2) =
(<span class="kr">let</span>
 &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span> (r1, r2, l ++ p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk20c"><span class="nb">destruct</span> (max_prefix l1 l2) <span class="kr">as</span> [[]] <span class="nb">eqn</span>: Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2, l0, l3, l4</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (l0, l3, l4)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix (l ++ l1) (l ++ l2) = (l0, l3, l ++ l4)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> max_prefix_app <span class="kr">in</span> Heq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk20d"><span class="kn">Lemma</span> <span class="nf">max_prefix_head_inv</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_prefix l1 l2 = (r1, r2, p) -&gt;
      r1 = [] /\ r2 = [] \/ head r1 &lt;&gt; head r2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk20e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk20f"><span class="nb">intros</span> l1 l2 p [] [] Heq; <span class="nb">cbn</span>; [<span class="bp">by</span> <span class="nb">left</span> | <span class="bp">by</span> <span class="nb">right</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (a :: l, a0 :: l0, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = [] âˆ§ a0 :: l0 = [] âˆ¨ Some a â‰  Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk210" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk210"><span class="nb">apply</span> max_prefix_max_snoc <span class="kr">in</span> Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>a â‰  a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: l = [] âˆ§ a0 :: l0 = [] âˆ¨ Some a â‰  Some a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk211"><span class="kn">Lemma</span> <span class="nf">max_prefix_spec</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_prefix l1 l2 = (r1, r2, p)
      &lt;-&gt;
    l1 = p ++ r1 /\ l2 = p ++ r2 /\ (r1 = [] /\ r2 = [] \/ head r1 &lt;&gt; head r2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†” l1 = p ++ r1
    âˆ§ l2 = p ++ r2
      âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk212"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†” l1 = p ++ r1
    âˆ§ l2 = p ++ r2
      âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk213"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix l1 l2 = (r1, r2, p)
â†’ l1 = p ++ r1
  âˆ§ l2 = p ++ r2
    âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk214" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk214"><hr></label><div class="goal-conclusion">l1 = p ++ r1
âˆ§ l2 = p ++ r2
  âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2)
â†’ max_prefix l1 l2 = (r1, r2, p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk215">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix l1 l2 = (r1, r2, p)
â†’ l1 = p ++ r1
  âˆ§ l2 = p ++ r2
    âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk216"><span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">eapply</span> max_prefix_fst_alt |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l2 = p ++ r2 âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk217"><span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">eapply</span> max_prefix_snd_alt |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> max_prefix_head_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk218">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 = p ++ r1
âˆ§ l2 = p ++ r2
  âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ head r1 â‰  head r2)
â†’ max_prefix l1 l2 = (r1, r2, p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk219"><span class="nb">intros</span> (-&gt; &amp; -&gt; &amp; [[-&gt; -&gt;] |]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix (p ++ []) (p ++ []) = ([], [], p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk21a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>head r1 â‰  head r2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk21a"><hr></label><div class="goal-conclusion">max_prefix (p ++ r1) (p ++ r2) = (r1, r2, p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk21b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix (p ++ []) (p ++ []) = ([], [], p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_nil_r, max_prefix_diag.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk21c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>head r1 â‰  head r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix (p ++ r1) (p ++ r2) = (r1, r2, p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> max_prefix_app_let, max_prefix_head, app_nil_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk21d"><span class="kn">Lemma</span> <span class="nf">max_prefix_comm</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_prefix l1 l2 = (r1, r2, p) -&gt;
    max_prefix l2 l1 = (r2, r1, p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix l2 l1 = (r2, r1, p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk21e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix l2 l1 = (r2, r1, p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk21f"><span class="nb">induction</span> l1 <span class="kr">as</span> [| h1 t1]; <span class="nb">destruct</span> l2 <span class="kr">as</span> [| h2 t2]; <span class="nb">cbn</span>; [<span class="bp">by</span> itauto <span class="bp">congruence</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix l2 t1 = (r2, r1, p)</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  (<span class="kr">if</span> decide_rel eq h1 h2
   <span class="kr">then</span> prod_map id (cons h1) (max_prefix t1 t2)
   <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) = (r1, r2, p)
  â†’ (<span class="kr">if</span> decide_rel eq h2 h1
     <span class="kr">then</span> prod_map id (cons h2) (max_prefix t2 t1)
     <span class="kr">else</span> (h2 :: t2, h1 :: t1, [])) = (r2, r1, p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk220"><span class="nb">intros</span> p r1 r2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix l2 t1 = (r2, r1, p)</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h1 h2
 <span class="kr">then</span> prod_map id (cons h1) (max_prefix t1 t2)
 <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) = (r1, r2, p)
â†’ (<span class="kr">if</span> decide_rel eq h2 h1
   <span class="kr">then</span> prod_map id (cons h2) (max_prefix t2 t1)
   <span class="kr">else</span> (h2 :: t2, h1 :: t1, [])) = (r2, r1, p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk221"><span class="nb">destruct</span> (max_prefix t1 t2) <span class="kr">as</span> [[]] <span class="nb">eqn</span>: Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix l2 t1 = (r2, r1, p)</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, p, r1, r2, l, l0, l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix t1 t2 = (l, l0, l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h1 h2
 <span class="kr">then</span> prod_map id (cons h1) (l, l0, l1)
 <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) = (r1, r2, p)
â†’ (<span class="kr">if</span> decide_rel eq h2 h1
   <span class="kr">then</span> prod_map id (cons h2) (max_prefix t2 t1)
   <span class="kr">else</span> (h2 :: t2, h1 :: t1, [])) = (r2, r1, p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk222">case_decide; <span class="nb">subst</span>; <span class="nb">intros</span> [= &lt;- &lt;- &lt;-]; <span class="nb">cbn</span>; case_decide; [| <span class="bp">done</span>..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix l2 t1 = (r2, r1, p)</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, l, l0, l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix t1 t2 = (l, l0, l1)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h2 = h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_map id (cons h2) (max_prefix t2 t1) =
(l0, l, h2 :: l1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">erewrite</span> IHt1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk223"><span class="kn">Lemma</span> <span class="nf">max_prefix_comm_let</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    max_prefix l2 l1 =
      <span class="kr">let</span> &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span> (r2, r1, p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_prefix l2 l1 =
  (<span class="kr">let</span> &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk224"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_prefix l2 l1 =
  (<span class="kr">let</span> &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk225"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix l2 l1 =
(<span class="kr">let</span> &#39;(r1, r2, p) := max_prefix l1 l2 <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk226"><span class="nb">destruct</span> (max_prefix l1 l2) <span class="kr">as</span> [[]] <span class="nb">eqn</span>: Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, l, l0, l3</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (l, l0, l3)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix l2 l1 = (l0, l, l3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> max_prefix_comm <span class="kr">in</span> Heq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk227"><span class="kn">Lemma</span> <span class="nf">max_prefix_idem</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_prefix l1 l2 = (r1, r2, p) -&gt;
    max_prefix r1 r2 = (r1, r2, []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk228"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk229"><span class="nb">induction</span> l1 <span class="kr">as</span> [| h1 t1]; <span class="nb">destruct</span> l2 <span class="kr">as</span> [| h2 t2]; <span class="nb">cbn</span>;
    <span class="kp">only</span> <span class="mi">1</span>-<span class="mi">3</span>: <span class="nb">intros</span> * [= &lt;- &lt;- &lt;-]; <span class="nb">cbn</span>; [<span class="bp">done</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  (<span class="kr">if</span> decide_rel eq h1 h2
   <span class="kr">then</span> prod_map id (cons h1) (max_prefix t1 t2)
   <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk22a"><span class="nb">intros</span> p r1 r2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h1 h2
 <span class="kr">then</span> prod_map id (cons h1) (max_prefix t1 t2)
 <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) = (r1, r2, p)
â†’ max_prefix r1 r2 = (r1, r2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk22b"><span class="nb">destruct</span> (max_prefix t1 t2) <span class="kr">as</span> [[]] <span class="nb">eqn</span>: Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, p, r1, r2, l, l0, l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix t1 t2 = (l, l0, l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h1 h2
 <span class="kr">then</span> prod_map id (cons h1) (l, l0, l1)
 <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) = (r1, r2, p)
â†’ max_prefix r1 r2 = (r1, r2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk22c">case_decide; <span class="nb">subst</span>; <span class="nb">intros</span> [= &lt;- &lt;- &lt;-]; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, l, l0, l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix t1 t2 = (l, l0, l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix l l0 = (l, l0, [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk22d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, l, l0, l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix t1 t2 = (l, l0, l1)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h1 â‰  h2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk22d"><hr></label><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h1 h2
 <span class="kr">then</span> prod_map id (cons h1) (max_prefix t1 t2)
 <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) =
(h1 :: t1, h2 :: t2, [])</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk22e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, l, l0, l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix t1 t2 = (l, l0, l1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_prefix l l0 = (l, l0, [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> IHt1 <span class="kr">in</span> Heq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk22f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHt1</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix t1 l2 = (r1, r2, p)
  â†’ max_prefix r1 r2 = (r1, r2, [])</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>t2, l, l0, l1</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix t1 t2 = (l, l0, l1)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>h1 â‰  h2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide_rel eq h1 h2
 <span class="kr">then</span> prod_map id (cons h1) (max_prefix t1 t2)
 <span class="kr">else</span> (h1 :: t1, h2 :: t2, [])) =
(h1 :: t1, h2 :: t2, [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> case_decide.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk230"><span class="kn">Lemma</span> <span class="nf">max_prefix_is_longest</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">p&#39;</span> : list A),
   max_prefix l1 l2 = (r1, r2, p) -&gt;
   prefix p&#39; l1 -&gt; prefix p&#39; l2 -&gt;
   length p&#39; &lt;= length p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">p&#39;</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ p&#39; `prefix_of` l1
    â†’ p&#39; `prefix_of` l2 â†’ length p&#39; â‰¤ length p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk231"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">p&#39;</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ p&#39; `prefix_of` l1
    â†’ p&#39; `prefix_of` l2 â†’ length p&#39; â‰¤ length p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk232"><span class="nb">intros</span> l1 l2 p r1 r2 p&#39; Hlc Hp1 Hp2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2, p'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlc</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>p&#39; `prefix_of` l1</span></span></span><br><span><var>Hp2</var><span class="hyp-type"><b>: </b><span>p&#39; `prefix_of` l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length p&#39; â‰¤ length p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk233"><span class="nb">inversion</span> Hlc; <span class="nb">subst</span>; <span class="nb">apply</span> prefix_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2, p'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlc</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>p&#39; `prefix_of` l1</span></span></span><br><span><var>Hp2</var><span class="hyp-type"><b>: </b><span>p&#39; `prefix_of` l2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p&#39; `prefix_of` p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> max_prefix_max_alt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk234"><span class="kn">Lemma</span> <span class="nf">max_prefix_residual_suffix</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_prefix l1 l2 = (r1, r2, p) -&gt;
      suffix r1 l1 /\ suffix r2 l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ r1 `suffix_of` l1 âˆ§ r2 `suffix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk235"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_prefix l1 l2 = (r1, r2, p)
  â†’ r1 `suffix_of` l1 âˆ§ r2 `suffix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk236"><span class="nb">intros</span> * Hprefix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hprefix</var><span class="hyp-type"><b>: </b><span>max_prefix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 `suffix_of` l1 âˆ§ r2 `suffix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk237"><span class="nb">apply</span> max_prefix_spec <span class="kr">in</span> Hprefix <span class="kr">as</span> (-&gt; &amp; -&gt; &amp; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 `suffix_of` p ++ r1 âˆ§ r2 `suffix_of` p ++ r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span> suffix_app_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_max_prefix</span>.</span></span></pre><div class="doc">
<a id="lab6"></a><h3 class="section">Longest common suffix</h3>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_max_suffix</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  `{EqDecision A}
  .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk238"><span class="kn">Lemma</span> <span class="nf">max_suffix_diag</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> : list A),
    max_suffix l l = ([], [], l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_suffix l l = ([], [], l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk239"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> : list A, max_suffix l l = ([], [], l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk23a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk23a"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix l l = ([], [], l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk23b"><span class="nb">unfold</span> max_suffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, k3) := max_prefix (reverse l) (reverse l) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
 (reverse k1, reverse k2, reverse k3)) = ([], [], l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> max_prefix_diag, reverse_involutive; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk23c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk23c"><span class="kn">Lemma</span> <span class="nf">max_suffix_app_let</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A),
    max_suffix (l1 ++ l) (l2 ++ l) =
      <span class="kr">let</span> &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span> (r1, r2, p ++ l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_suffix (l1 ++ l) (l2 ++ l) =
  (<span class="kr">let</span>
   &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span>
    (r1, r2, p ++ l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk23d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_suffix (l1 ++ l) (l2 ++ l) =
  (<span class="kr">let</span>
   &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span>
    (r1, r2, p ++ l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk23e"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix (l1 ++ l) (l2 ++ l) =
(<span class="kr">let</span>
 &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span> (r1, r2, p ++ l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk23f"><span class="nb">unfold</span> max_suffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, k3) :=
   max_prefix (reverse (l1 ++ l)) (reverse (l2 ++ l)) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
 (reverse k1, reverse k2, reverse k3)) =
(<span class="kr">let</span>
 &#39;(r1, r2, p) :=
  <span class="kr">let</span> (<span class="nv">p</span>, k3) :=
    max_prefix (reverse l1) (reverse l2) <span class="kr">in</span>
  <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
  (reverse k1, reverse k2, reverse k3) <span class="kr">in</span>
  (r1, r2, p ++ l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk240"><span class="nb">rewrite</span> !reverse_app, max_prefix_app_let.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, k3) :=
   <span class="kr">let</span>
   &#39;(r1, r2, p) :=
    max_prefix (reverse l1) (reverse l2) <span class="kr">in</span>
    (r1, r2, reverse l ++ p) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
 (reverse k1, reverse k2, reverse k3)) =
(<span class="kr">let</span>
 &#39;(r1, r2, p) :=
  <span class="kr">let</span> (<span class="nv">p</span>, k3) :=
    max_prefix (reverse l1) (reverse l2) <span class="kr">in</span>
  <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
  (reverse k1, reverse k2, reverse k3) <span class="kr">in</span>
  (r1, r2, p ++ l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk241"><span class="nb">destruct</span> (max_prefix (reverse l1) (reverse l2)) <span class="kr">as</span> [[]] <span class="nb">eqn</span>: Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2, l0, l3, l4</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_prefix (reverse l1) (reverse l2) =
(l0, l3, l4)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(reverse l0, reverse l3, reverse (reverse l ++ l4)) =
(reverse l0, reverse l3, reverse l4 ++ l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> reverse_app, reverse_involutive.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk242"><span class="kn">Lemma</span> <span class="nf">max_suffix_last</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    <span class="nb">last</span> l1 &lt;&gt; <span class="nb">last</span> l2 -&gt; max_suffix l1 l2 = (l1, l2, []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  <span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2 â†’ max_suffix l1 l2 = (l1, l2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk243"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  <span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2 â†’ max_suffix l1 l2 = (l1, l2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk244"><span class="nb">intros</span> * Hlast.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix l1 l2 = (l1, l2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk245"><span class="nb">unfold</span> max_suffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, k3) :=
   max_prefix (reverse l1) (reverse l2) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
 (reverse k1, reverse k2, reverse k3)) = (l1, l2, [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk246"><span class="nb">rewrite</span> max_prefix_head.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(reverse (reverse l1), reverse (reverse l2),
 reverse []) = (l1, l2, [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk247" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk247"><hr></label><div class="goal-conclusion">head (reverse l1) â‰  head (reverse l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk248">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(reverse (reverse l1), reverse (reverse l2),
 reverse []) = (l1, l2, [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !reverse_involutive; <span class="nb">cbn</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk249">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlast</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> l1 â‰  <span class="nb">last</span> l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">head (reverse l1) â‰  head (reverse l2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> !head_reverse.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk24a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk24a"><span class="kn">Lemma</span> <span class="nf">max_suffix_last_inv</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_suffix l1 l2 = (r1, r2, p) -&gt;
      r1 = [] /\ r2 = [] \/ <span class="nb">last</span> r1 &lt;&gt; <span class="nb">last</span> r2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk24b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk24c"><span class="nb">intros</span> * Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk24d">destruct_list_last r1 r1&#39; h1 Heq1; destruct_list_last r2 r2&#39; h2 Heq2; <span class="nb">cbn</span>;
    <span class="nb">rewrite</span> <span class="nl">?last_snoc</span>; [<span class="bp">by</span> <span class="nb">left</span> | <span class="bp">by</span> <span class="nb">right</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2, r1'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>r2'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1&#39; ++ [h1], r2&#39; ++ [h2], p)</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>r1 = r1&#39; ++ [h1]</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>r2 = r2&#39; ++ [h2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1&#39; ++ [h1] = [] âˆ§ r2&#39; ++ [h2] = []
âˆ¨ Some h1 â‰  Some h2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk24e"><span class="nb">right</span>; <span class="nb">intros</span> [= -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2, r1', r2'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>h2</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Heq1</var><span class="hyp-type"><b>: </b><span>r1 = r1&#39; ++ [h2]</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1&#39; ++ [h2], r2&#39; ++ [h2], p)</span></span></span><br><span><var>Heq2</var><span class="hyp-type"><b>: </b><span>r2 = r2&#39; ++ [h2]</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> max_suffix_max_snoc <span class="kr">in</span> Heq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk24f"><span class="kn">Lemma</span> <span class="nf">max_suffix_spec</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_suffix l1 l2 = (r1, r2, p)
      &lt;-&gt;
    l1 = r1 ++ p /\ l2 = r2 ++ p /\ (r1 = [] /\ r2 = [] \/ <span class="nb">last</span> r1 &lt;&gt; <span class="nb">last</span> r2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†” l1 = r1 ++ p
    âˆ§ l2 = r2 ++ p
      âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk250"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†” l1 = r1 ++ p
    âˆ§ l2 = r2 ++ p
      âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk251"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix l1 l2 = (r1, r2, p)
â†’ l1 = r1 ++ p
  âˆ§ l2 = r2 ++ p
    âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk252" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk252"><hr></label><div class="goal-conclusion">l1 = r1 ++ p
âˆ§ l2 = r2 ++ p
  âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2)
â†’ max_suffix l1 l2 = (r1, r2, p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk253">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix l1 l2 = (r1, r2, p)
â†’ l1 = r1 ++ p
  âˆ§ l2 = r2 ++ p
    âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk254"><span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">eapply</span> max_suffix_fst_alt |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l2 = r2 ++ p âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk255"><span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">eapply</span> max_suffix_snd_alt |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> max_suffix_last_inv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk256">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l1 = r1 ++ p
âˆ§ l2 = r2 ++ p
  âˆ§ (r1 = [] âˆ§ r2 = [] âˆ¨ <span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2)
â†’ max_suffix l1 l2 = (r1, r2, p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk257"><span class="nb">intros</span> (-&gt; &amp; -&gt; &amp; [[-&gt; -&gt;] |]); <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix p p = ([], [], p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="ListExtras-v-chk258" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2</span></span></span><br></div><label class="goal-separator" for="ListExtras-v-chk258"><hr></label><div class="goal-conclusion">max_suffix (r1 ++ p) (r2 ++ p) = (r1, r2, p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk259">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix p p = ([], [], p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> max_suffix_diag.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk25a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="nb">last</span> r1 â‰  <span class="nb">last</span> r2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix (r1 ++ p) (r2 ++ p) = (r1, r2, p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> max_suffix_app_let, max_suffix_last.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk25b"><span class="kn">Lemma</span> <span class="nf">max_suffix_comm_let</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> : list A),
    max_suffix l2 l1 =
      <span class="kr">let</span> &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span> (r2, r1, p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_suffix l2 l1 =
  (<span class="kr">let</span> &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk25c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  max_suffix l2 l1 =
  (<span class="kr">let</span> &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk25d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">max_suffix l2 l1 =
(<span class="kr">let</span> &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk25e"><span class="nb">unfold</span> max_suffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, k3) :=
   max_prefix (reverse l2) (reverse l1) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
 (reverse k1, reverse k2, reverse k3)) =
(<span class="kr">let</span>
 &#39;(r1, r2, p) :=
  <span class="kr">let</span> (<span class="nv">p</span>, k3) :=
    max_prefix (reverse l1) (reverse l2) <span class="kr">in</span>
  <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
  (reverse k1, reverse k2, reverse k3) <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk25f"><span class="nb">rewrite</span> max_prefix_comm_let.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, k3) :=
   <span class="kr">let</span>
   &#39;(r1, r2, p) :=
    max_prefix (reverse l1) (reverse l2) <span class="kr">in</span>
    (r2, r1, p) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
 (reverse k1, reverse k2, reverse k3)) =
(<span class="kr">let</span>
 &#39;(r1, r2, p) :=
  <span class="kr">let</span> (<span class="nv">p</span>, k3) :=
    max_prefix (reverse l1) (reverse l2) <span class="kr">in</span>
  <span class="kr">let</span> (<span class="nv">k1</span>, k2) := p <span class="kr">in</span>
  (reverse k1, reverse k2, reverse k3) <span class="kr">in</span> (r2, r1, p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (max_prefix (reverse l1) (reverse l2)) <span class="kr">as</span> [[]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk260"><span class="kn">Lemma</span> <span class="nf">max_suffix_is_suffix</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_suffix l1 l2 = (r1, r2, p) -&gt;
      suffix p l1 /\ suffix p l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ p `suffix_of` l1 âˆ§ p `suffix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk261"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ p `suffix_of` l1 âˆ§ p `suffix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk262"><span class="nb">intros</span> * Hsuffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsuffix</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p `suffix_of` l1 âˆ§ p `suffix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk263"><span class="nb">apply</span> max_suffix_spec <span class="kr">in</span> Hsuffix <span class="kr">as</span> (-&gt; &amp; -&gt; &amp; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p `suffix_of` r1 ++ p âˆ§ p `suffix_of` r2 ++ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span> suffix_app_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk264"><span class="kn">Lemma</span> <span class="nf">suffix_max_suffix</span> :
  <span class="kr">forall</span> (<span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A),
    suffix l l1 -&gt; suffix l l2 -&gt;
      <span class="kr">let</span> &#39;(r1, r2, p) := max_suffix l1 l2 <span class="kr">in</span> suffix l p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  l `suffix_of` l1
  â†’ l `suffix_of` l2
    â†’ <span class="kr">let</span>
      &#39;(_, _, p) := max_suffix l1 l2 <span class="kr">in</span>
       l `suffix_of` p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk265"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l</span> <span class="nv">l1</span> <span class="nv">l2</span> : list A,
  l `suffix_of` l1
  â†’ l `suffix_of` l2
    â†’ <span class="kr">let</span>
      &#39;(_, _, p) := max_suffix l1 l2 <span class="kr">in</span>
       l `suffix_of` p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk266"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l `suffix_of` l1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l `suffix_of` l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">let</span> &#39;(_, _, p) := max_suffix l1 l2 <span class="kr">in</span> l `suffix_of` p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk267"><span class="nb">destruct</span> (max_suffix l1 l2) <span class="kr">as</span> [[]] <span class="nb">eqn</span>: Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l, l1, l2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l `suffix_of` l1</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l `suffix_of` l2</span></span></span><br><span><var>l0, l3, l4</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (l0, l3, l4)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">l `suffix_of` l4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> max_suffix_max_alt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk268"><span class="kn">Lemma</span> <span class="nf">max_suffix_is_longest</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">p&#39;</span> : list A),
   max_suffix l1 l2 = (r1, r2, p) -&gt;
   suffix p&#39; l1 -&gt; suffix p&#39; l2 -&gt;
   length p&#39; &lt;= length p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">p&#39;</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ p&#39; `suffix_of` l1
    â†’ p&#39; `suffix_of` l2 â†’ length p&#39; â‰¤ length p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk269"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">p&#39;</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ p&#39; `suffix_of` l1
    â†’ p&#39; `suffix_of` l2 â†’ length p&#39; â‰¤ length p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk26a" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk26a"><span class="nb">intros</span> l1 l2 p r1 r2 p&#39; Hlc Hp1 Hp2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2, p'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlc</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>p&#39; `suffix_of` l1</span></span></span><br><span><var>Hp2</var><span class="hyp-type"><b>: </b><span>p&#39; `suffix_of` l2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length p&#39; â‰¤ length p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk26b"><span class="nb">inversion</span> Hlc; <span class="nb">subst</span>; <span class="nb">apply</span> suffix_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2, p'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hlc</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>p&#39; `suffix_of` l1</span></span></span><br><span><var>Hp2</var><span class="hyp-type"><b>: </b><span>p&#39; `suffix_of` l2</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p&#39; `suffix_of` p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> max_suffix_max_alt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk26c"><span class="kn">Lemma</span> <span class="nf">max_suffix_residual_prefix</span> :
  <span class="kr">forall</span> (<span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A),
    max_suffix l1 l2 = (r1, r2, p) -&gt;
      prefix r1 l1 /\ prefix r2 l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ r1 `prefix_of` l1 âˆ§ r2 `prefix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk26d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">l1</span> <span class="nv">l2</span> <span class="nv">p</span> <span class="nv">r1</span> <span class="nv">r2</span> : list A,
  max_suffix l1 l2 = (r1, r2, p)
  â†’ r1 `prefix_of` l1 âˆ§ r2 `prefix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk26e"><span class="nb">intros</span> * Hsuffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>l1, l2, p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>Hsuffix</var><span class="hyp-type"><b>: </b><span>max_suffix l1 l2 = (r1, r2, p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 `prefix_of` l1 âˆ§ r2 `prefix_of` l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk26f"><span class="nb">apply</span> max_suffix_spec <span class="kr">in</span> Hsuffix <span class="kr">as</span> (-&gt; &amp; -&gt; &amp; _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision A</span></span></span><br><span><var>p, r1, r2</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 `prefix_of` r1 ++ p âˆ§ r2 `prefix_of` r2 ++ p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; <span class="nb">apply</span> prefix_app_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_max_suffix</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">Exists_choose_first</span>
  `{P : A -&gt; <span class="kt">Prop</span>} `{<span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)} {l : list A} (Hl : Exists P l) {<span class="kr">struct</span> l} : A :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; _
  | a :: l =&gt; <span class="kr">if</span> decide (P a) <span class="kr">then</span> a <span class="kr">else</span> @Exists_choose_first A P _ l _
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk270"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a))
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Exists P l â†’ [] = l â†’ A</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk271"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a))
  â†’ <span class="kr">âˆ€</span> <span class="nv">l</span> : list A, Exists P l â†’ [] = l â†’ A</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">exfalso</span>; <span class="nb">subst</span>; <span class="nb">inversion</span> Hl.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk272" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk272"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a))
  â†’ <span class="kr">âˆ€</span> <span class="nv">l0</span> : list A,
      Exists P l0
      â†’ <span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
          a :: l = l0 â†’ Â¬ P a â†’ Exists P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk273"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>),
  (<span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a))
  â†’ <span class="kr">âˆ€</span> <span class="nv">l0</span> : list A,
      Exists P l0
      â†’ <span class="kr">âˆ€</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
          a :: l = l0 â†’ Â¬ P a â†’ Exists P l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">subst</span>; <span class="nb">apply</span> Exists_cons <span class="kr">in</span> Hl <span class="kr">as</span> [].</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk274"><span class="kn">Lemma</span> <span class="nf">Exists_choose_first_good</span> :
  <span class="kr">forall</span> `(P : A -&gt; <span class="kt">Prop</span>) `{<span class="kr">forall</span> <span class="nv">a</span>, Decision (P a)} (l : list A) (Hl : Exists P l),
    P (Exists_choose_first Hl).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">H</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                   Decision (P a)) 
  (<span class="nv">l</span> : list A) (<span class="nv">Hl</span> : Exists P l),
  P (Exists_choose_first Hl)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk275"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">P</span> : A â†’ <span class="kt">Prop</span>) (<span class="nv">H</span> : <span class="kr">âˆ€</span> <span class="nv">a</span> : A,
                                   Decision (P a)) 
  (<span class="nv">l</span> : list A) (<span class="nv">Hl</span> : Exists P l),
  P (Exists_choose_first Hl)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="ListExtras-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="ListExtras-v-chk276"><span class="nb">induction</span> l; <span class="nb">cbn</span>; <span class="nb">intros</span>; [<span class="bp">by</span> <span class="nb">inversion</span> Hl |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">Hl</span> : Exists P l, P (Exists_choose_first Hl)</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>Exists P (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P
  <span class="kr">match</span> decide (P a) <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt; a
  | <span class="nb">right</span> x =&gt;
      Exists_choose_first
        (Exists_choose_first_obligation_2 A P (a :: l)
           Hl a l eq_refl x)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> case_decide; [| <span class="nb">apply</span> IHl].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>