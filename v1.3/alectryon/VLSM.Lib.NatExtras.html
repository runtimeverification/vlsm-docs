<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>NatExtras.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.18.0+0.18.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+â†‘</kbd> <kbd>Ctrl+â†“</kbd> to navigate, <kbd>Ctrl+ğŸ–±ï¸</kbd> to focus. On Mac, use <kbd>âŒ˜</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk0"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ZArith.Znumtheory.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk1"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> prelude finite.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk2"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> EquationsExtras.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file extraction_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file equations_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk3"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> Preamble FinSuppFn StdppExtras ListExtras.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file coq-itauto.plugin ... <span class="bp">done</span>]</blockquote></div></div></small></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Utility: Natural Number Definitions and Results</h1>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><div class="doc">
Compute the list of all naturals less than <code>n</code>. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">up_to_n_listing</span> (<span class="nv">n</span> : nat) : list nat :=
  <span class="kr">match</span> n <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; []
  | S n&#39; =&gt; n&#39; :: up_to_n_listing n&#39;
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk4"><span class="kn">Lemma</span> <span class="nf">up_to_n_listing_length</span> :
  <span class="kr">forall</span> (<span class="nv">n</span> : nat),
    length (up_to_n_listing n) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, length (up_to_n_listing n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, length (up_to_n_listing n) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">induction</span> n; <span class="nb">simpl</span>; <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk6"><span class="kn">Lemma</span> <span class="nf">up_to_n_full</span> :
  <span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">i</span> : nat),
    i &lt; n &lt;-&gt; i âˆˆ up_to_n_listing n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> <span class="nv">i</span> : nat, i &lt; n â†” i âˆˆ up_to_n_listing n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> <span class="nv">i</span> : nat, i &lt; n â†” i âˆˆ up_to_n_listing n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk8"><span class="nb">induction</span> n; <span class="nb">split</span>; <span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span>; <span class="nb">cbn</span>; [<span class="nb">left</span> | | <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : nat, i &lt; n â†” i âˆˆ up_to_n_listing n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; S n</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>S i â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i âˆˆ n :: up_to_n_listing n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : nat, i &lt; n â†” i âˆˆ up_to_n_listing n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i âˆˆ up_to_n_listing (S n)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>i âˆˆ up_to_n_listing n</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk9"><hr></label><div class="goal-conclusion">i &lt; S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : nat, i &lt; n â†” i âˆˆ up_to_n_listing n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i &lt; S n</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>S i â‰¤ n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i âˆˆ n :: up_to_n_listing n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>; <span class="nb">apply</span> IHn.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : nat, i &lt; n â†” i âˆˆ up_to_n_listing n</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i âˆˆ up_to_n_listing (S n)</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>i âˆˆ up_to_n_listing n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i &lt; S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">transitivity</span> n; [<span class="nb">apply</span> IHn | <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Given a decidable property on naturals and a bound, finds the
  largest natural (not larger the than bound) for which the property holds.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">find_largest_nat_with_property_bounded</span>
  (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>) `{<span class="kr">forall</span> <span class="nv">n</span>, Decision (P n)}
  (bound : nat)
  : option nat :=
| P, <span class="mi">0</span> =&gt; None
| P, S n =&gt; <span class="kr">if</span> decide (P n) <span class="kr">then</span> Some n <span class="kr">else</span> find_largest_nat_with_property_bounded P n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc"><span class="kn">Lemma</span> <span class="nf">find_largest_nat_with_property_bounded_Some</span>
  (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>) `{<span class="kr">forall</span> <span class="nv">n</span>, Decision (P n)}
  (bound : nat)
  : <span class="kr">forall</span> <span class="nv">n</span>,
      find_largest_nat_with_property_bounded P bound = Some n
        &lt;-&gt;
      maximal_among lt (<span class="kr">fun</span> <span class="nv">n</span> =&gt; n &lt; bound /\ P n) n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P bound =
  Some n
  â†” maximal_among lt (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P bound =
  Some n
  â†” maximal_among lt (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke"><span class="nb">induction</span> bound; simp find_largest_nat_with_property_bounded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  None = Some n
  â†” maximal_among lt (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; <span class="mi">0</span> âˆ§ P n0) n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkf"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  (<span class="kr">if</span> decide (P bound)
   <span class="kr">then</span> Some bound
   <span class="kr">else</span> find_largest_nat_with_property_bounded P bound) =
  Some n
  â†” maximal_among lt (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; S bound âˆ§ P n0)
      n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk10">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  None = Some n
  â†” maximal_among lt (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; <span class="mi">0</span> âˆ§ P n0) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [| <span class="nb">intros</span> []; <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk11">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  (<span class="kr">if</span> decide (P bound)
   <span class="kr">then</span> Some bound
   <span class="kr">else</span> find_largest_nat_with_property_bounded P bound) =
  Some n
  â†” maximal_among lt (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; S bound âˆ§ P n0)
      n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk12">case_decide <span class="kr">as</span> HP; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some bound = Some n
â†’ maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk13"><hr></label><div class="goal-conclusion">maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n
â†’ Some bound = Some n</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk14"><hr></label><div class="goal-conclusion">find_largest_nat_with_property_bounded P bound =
Some n
â†’ maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk15" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk15"><hr></label><div class="goal-conclusion">maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n
â†’ find_largest_nat_with_property_bounded P bound =
  Some n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk16">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some bound = Some n
â†’ maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> [= -&gt;]; <span class="kp">repeat</span> <span class="nb">split</span>; <span class="nb">cbn</span>; [<span class="bp">lia</span> | | <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk17">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n
â†’ Some bound = Some n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk18"><span class="nb">intros</span> [[Hn HPn] Hmax]; <span class="nb">f_equal</span>; <span class="nb">cbn</span> <span class="kr">in</span> Hmax.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>HPn</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39; â†’ n &lt; m&#39; â†’ m&#39; &lt; n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bound = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk19"><span class="nb">destruct</span> (decide (n &lt; bound)); [| <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>HPn</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39; â†’ n &lt; m&#39; â†’ m&#39; &lt; n</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bound = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk1a"><span class="nb">cut</span> (bound &lt; n); [<span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>HPn</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39; â†’ n &lt; m&#39; â†’ m&#39; &lt; n</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>n &lt; bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bound &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Hmax; [<span class="nb">split</span>; [<span class="bp">lia</span> |] |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk1b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_largest_nat_with_property_bounded P bound =
Some n
â†’ maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk1c"><span class="nb">rewrite</span> IHbound.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; bound âˆ§ P n) n
â†’ maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk1d"><span class="nb">intros</span> [[] Hmax]; <span class="nb">split</span>; [<span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">lia</span> |] |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n &lt; bound</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; bound âˆ§ P m&#39;
  â†’ flip lt m&#39; n â†’ flip lt n m&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39; â†’ flip lt m&#39; n â†’ flip lt n m&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk1e"><span class="nb">intros</span> m [] ?.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n &lt; bound</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; bound âˆ§ P m&#39;
  â†’ flip lt m&#39; n â†’ flip lt n m&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; S bound</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>flip lt m n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flip lt n m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk1f"><span class="nb">apply</span> Hmax; [<span class="nb">split</span>; [| <span class="bp">done</span>] | <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n &lt; bound</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; bound âˆ§ P m&#39;
  â†’ flip lt m&#39; n â†’ flip lt n m&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; S bound</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>flip lt m n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt; bound</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (decide (m = bound)); [<span class="nb">subst</span> | <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">maximal_among lt (<span class="kr">Î»</span> <span class="nv">n</span> : nat, n &lt; S bound âˆ§ P n) n
â†’ find_largest_nat_with_property_bounded P bound =
  Some n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk21"><span class="nb">intros</span> [[] Hmax]; <span class="nb">apply</span> IHbound; <span class="kp">repeat</span> <span class="nb">split</span>; [| <span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39;
  â†’ flip lt m&#39; n â†’ flip lt n m&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; bound</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39;
  â†’ flip lt m&#39; n â†’ flip lt n m&#39;</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk22"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; bound âˆ§ P m&#39; â†’ flip lt m&#39; n â†’ flip lt n m&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk23">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39;
  â†’ flip lt m&#39; n â†’ flip lt n m&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt; bound</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> (decide (n = bound)); [<span class="nb">subst</span> | <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk24">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat,
  find_largest_nat_with_property_bounded P
    bound = Some n
  â†” maximal_among lt
      (<span class="kr">Î»</span> <span class="nv">n0</span> : nat, n0 &lt; bound âˆ§ P n0) n</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P n</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; S bound âˆ§ P m&#39;
  â†’ flip lt m&#39; n â†’ flip lt n m&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">m&#39;</span> : nat,
  m&#39; &lt; bound âˆ§ P m&#39; â†’ flip lt m&#39; n â†’ flip lt n m&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> m [] ?; <span class="nb">apply</span> Hmax; [<span class="nb">split</span>; [<span class="bp">lia</span> |] |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk25"><span class="kn">Lemma</span> <span class="nf">find_largest_nat_with_property_bounded_None</span>
  (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>) `{<span class="kr">forall</span> <span class="nv">n</span>, Decision (P n)}
  (bound : nat)
  : find_largest_nat_with_property_bounded P bound = None
      &lt;-&gt;
    <span class="kr">forall</span> <span class="nv">n</span>, n &lt; bound -&gt; ~ P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_largest_nat_with_property_bounded P bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_largest_nat_with_property_bounded P bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk27"><span class="nb">induction</span> bound; simp find_largest_nat_with_property_bounded; [<span class="bp">by</span> <span class="nb">split</span>; [<span class="bp">lia</span> |] |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (P bound)
 <span class="kr">then</span> Some bound
 <span class="kr">else</span> find_largest_nat_with_property_bounded P bound) =
None â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk28">case_decide <span class="kr">as</span> HP; <span class="nb">split</span>; [<span class="bp">done</span> | | |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n) â†’ Some bound = None</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk29"><hr></label><div class="goal-conclusion">find_largest_nat_with_property_bounded P bound = None
â†’ <span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk2a"><hr></label><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n)
â†’ find_largest_nat_with_property_bounded P bound =
  None</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>P bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n) â†’ Some bound = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intro</span> Hmax; <span class="bp">contradict</span> HP; <span class="nb">apply</span> Hmax; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_largest_nat_with_property_bounded P bound = None
â†’ <span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk2d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P bound =
None</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Â¬ P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk2e"><span class="nb">destruct</span> (decide (n &lt; bound)); [<span class="bp">by</span> <span class="nb">eapply</span> IHbound |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P bound =
None</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>n &lt; S bound</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>Â¬ n &lt; bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Â¬ P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">replace</span> n <span class="kr">with</span> bound; [| <span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n)
â†’ find_largest_nat_with_property_bounded P bound =
  None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk30"><span class="nb">intros</span> Hmax; <span class="nb">apply</span> IHbound.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, Decision (P n)</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHbound</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded P
  bound = None
â†” (<span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n)</span></span></span><br><span><var>HP</var><span class="hyp-type"><b>: </b><span>Â¬ P bound</span></span></span><br><span><var>Hmax</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; S bound â†’ Â¬ P n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : nat, n &lt; bound â†’ Â¬ P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">apply</span> Hmax; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
  Given a predicate on indices and naturals, a bound for each index, and a
  list of indices, finds first index in the list and largest natural (less than
  bound) corresponding to it for which the predicate holds.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">find_first_indexed_largest_nat_with_propery_bounded</span> {<span class="nv">index</span>}
  (<span class="nv">P</span> : index -&gt; nat -&gt; <span class="kt">Prop</span>) `{!RelDecision P}
  (bound : index -&gt; nat)
  (indices : list index)
  : option (index * nat) :=
| _, _, [] =&gt; None
| P, bound, i :: indices&#39; <span class="kr">with</span> inspect (find_largest_nat_with_property_bounded (P i) (bound i)) =&gt;
  | None eq: Hdec =&gt; find_first_indexed_largest_nat_with_propery_bounded P bound indices&#39;;
  | (Some n) eq: Hdec =&gt; Some (i, n).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk31"><span class="kn">Lemma</span> <span class="nf">find_first_indexed_largest_nat_with_propery_bounded_Some</span> {<span class="nv">index</span>}
  (<span class="nv">P</span> : index -&gt; nat -&gt; <span class="kt">Prop</span>) `{!RelDecision P}
  (bound : index -&gt; nat)
  (indices : list index) (Hindices : NoDup indices)
  : <span class="kr">forall</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
      find_first_indexed_largest_nat_with_propery_bounded P bound indices = Some (i, n)
        &lt;-&gt;
      i âˆˆ indices /\
      find_largest_nat_with_property_bounded (P i) (bound i) = Some n /\
      <span class="kr">forall</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list index),
        indices = prefix ++ [i] ++ suffix -&gt;
        <span class="kr">forall</span> (<span class="nv">j</span> : index), j âˆˆ prefix -&gt;
        find_largest_nat_with_property_bounded (P j) (bound j) = None.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
  find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = Some (i, n)
  â†” i âˆˆ indices
    âˆ§ find_largest_nat_with_property_bounded (P i)
        (bound i) = Some n
      âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
           indices = prefix ++ [i] ++ suffix
           â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
               j âˆˆ prefix
               â†’ find_largest_nat_with_property_bounded
                   (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
  find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = Some (i, n)
  â†” i âˆˆ indices
    âˆ§ find_largest_nat_with_property_bounded (P i)
        (bound i) = Some n
      âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
           indices = prefix ++ [i] ++ suffix
           â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
               j âˆˆ prefix
               â†’ find_largest_nat_with_property_bounded
                   (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk33"><span class="nb">induction</span> indices; simp find_first_indexed_largest_nat_with_propery_bounded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
  None = Some (i, n)
  â†” i âˆˆ []
    âˆ§ find_largest_nat_with_property_bounded (P i)
        (bound i) = Some n
      âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
           [] = prefix ++ [i] ++ suffix
           â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
               j âˆˆ prefix
               â†’ find_largest_nat_with_property_bounded
                   (P j) (bound j) = None)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (a :: indices)</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk34"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
  find_first_indexed_largest_nat_with_propery_bounded_clause_2
    (@find_first_indexed_largest_nat_with_propery_bounded)
    index P RelDecision0 bound a
    (inspect
       (find_largest_nat_with_property_bounded 
          (P a) (bound a))) indices = 
  Some (i, n)
  â†” i âˆˆ a :: indices
    âˆ§ find_largest_nat_with_property_bounded 
        (P i) (bound i) = 
      Some n
      âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
           a :: indices = prefix ++ [i] ++ suffix
           â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
               j âˆˆ prefix
               â†’ find_largest_nat_with_property_bounded
                   (P j) 
                   (bound j) = None)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk35">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
  None = Some (i, n)
  â†” i âˆˆ []
    âˆ§ find_largest_nat_with_property_bounded (P i)
        (bound i) = Some n
      âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
           [] = prefix ++ [i] ++ suffix
           â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
               j âˆˆ prefix
               â†’ find_largest_nat_with_property_bounded
                   (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">inversion</span> <span class="mi">1</span> | <span class="nb">intros</span> [Hcontra]; <span class="nb">inversion</span> Hcontra].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk36">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (a :: indices)</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
  find_first_indexed_largest_nat_with_propery_bounded_clause_2
    (@find_first_indexed_largest_nat_with_propery_bounded)
    index P RelDecision0 bound a
    (inspect
       (find_largest_nat_with_property_bounded (P a)
          (bound a))) indices = Some (i, n)
  â†” i âˆˆ a :: indices
    âˆ§ find_largest_nat_with_property_bounded (P i)
        (bound i) = Some n
      âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
           a :: indices = prefix ++ [i] ++ suffix
           â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
               j âˆˆ prefix
               â†’ find_largest_nat_with_property_bounded
                   (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk37"><span class="nb">apply</span> NoDup_cons <span class="kr">in</span> Hindices <span class="kr">as</span> [Ha Hindices].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
  find_first_indexed_largest_nat_with_propery_bounded_clause_2
    (@find_first_indexed_largest_nat_with_propery_bounded)
    index P RelDecision0 bound a
    (inspect
       (find_largest_nat_with_property_bounded (P a)
          (bound a))) indices = Some (i, n)
  â†” i âˆˆ a :: indices
    âˆ§ find_largest_nat_with_property_bounded (P i)
        (bound i) = Some n
      âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
           a :: indices = prefix ++ [i] ++ suffix
           â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
               j âˆˆ prefix
               â†’ find_largest_nat_with_property_bounded
                   (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk38"><span class="nb">cbn</span>; <span class="nb">split</span>;
      <span class="nb">destruct</span> (find_largest_nat_with_property_bounded  (P a) (bound a)) <span class="kr">as</span> [_n |] <span class="nb">eqn</span>: Hpos.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n, _n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some _n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (a, _n) = Some (i, n)
â†’ i âˆˆ a :: indices
  âˆ§ find_largest_nat_with_property_bounded (P i)
      (bound i) = Some n
    âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
         a :: indices = prefix ++ i :: suffix
         â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
             j âˆˆ prefix
             â†’ find_largest_nat_with_property_bounded
                 (P j) (bound j) = None)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk39"><hr></label><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = Some (i, n)
â†’ i âˆˆ a :: indices
  âˆ§ find_largest_nat_with_property_bounded 
      (P i) (bound i) = 
    Some n
    âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
         a :: indices = prefix ++ i :: suffix
         â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
             j âˆˆ prefix
             â†’ find_largest_nat_with_property_bounded
                 (P j) (bound j) = None)</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n, _n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some _n</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk3a"><hr></label><div class="goal-conclusion">i âˆˆ a :: indices
âˆ§ find_largest_nat_with_property_bounded 
    (P i) (bound i) = Some n
  âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
       a :: indices = prefix ++ i :: suffix
       â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
           j âˆˆ prefix
           â†’ find_largest_nat_with_property_bounded
               (P j) (bound j) = None)
â†’ Some (a, _n) = Some (i, n)</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk3b"><hr></label><div class="goal-conclusion">i âˆˆ a :: indices
âˆ§ find_largest_nat_with_property_bounded 
    (P i) (bound i) = Some n
  âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
       a :: indices = prefix ++ i :: suffix
       â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
           j âˆˆ prefix
           â†’ find_largest_nat_with_property_bounded
               (P j) (bound j) = None)
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = Some (i, n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk3c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n, _n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some _n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (a, _n) = Some (i, n)
â†’ i âˆˆ a :: indices
  âˆ§ find_largest_nat_with_property_bounded (P i)
      (bound i) = Some n
    âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
         a :: indices = prefix ++ i :: suffix
         â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
             j âˆˆ prefix
             â†’ find_largest_nat_with_property_bounded
                 (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk3d"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">subst</span> a _n; split_and!; [<span class="bp">by</span> <span class="nb">left</span> | <span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>i âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some (i, n) = Some (i, n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  i :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded (P j)
          (bound j) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk3e"><span class="nb">intros</span> [| _i prefix] ? Heq; [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>i âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Some (i, n) = Some (i, n)</span></span></span><br><span><var>_i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>i :: indices = (_i :: prefix) ++ i :: suffix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">j</span> : index,
  j âˆˆ _i :: prefix
  â†’ find_largest_nat_with_property_bounded (P j)
      (bound j) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk3f"><span class="bp">contradict</span> Ha; simplify_list_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>_i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ _i :: suffix)</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ _i :: suffix)
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound (prefix ++ _i :: suffix) =
    Some (i, n)
    â†” i âˆˆ prefix ++ _i :: suffix
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix0</span> <span class="nv">suffix0</span> : list index,
             prefix ++ _i :: suffix =
             prefix0 ++ i :: suffix0
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix0
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P _i) (bound _i) = Some n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">_i âˆˆ prefix ++ _i :: suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> elem_of_app; <span class="nb">right</span>; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk40">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = Some (i, n)
â†’ i âˆˆ a :: indices
  âˆ§ find_largest_nat_with_property_bounded (P i)
      (bound i) = Some n
    âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
         a :: indices = prefix ++ i :: suffix
         â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
             j âˆˆ prefix
             â†’ find_largest_nat_with_property_bounded
                 (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk41"><span class="nb">rewrite</span> IHindices <span class="bp">by</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i âˆˆ indices
âˆ§ find_largest_nat_with_property_bounded (P i)
    (bound i) = Some n
  âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
       indices = prefix ++ [i] ++ suffix
       â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
           j âˆˆ prefix
           â†’ find_largest_nat_with_property_bounded
               (P j) (bound j) = None)
â†’ i âˆˆ a :: indices
  âˆ§ find_largest_nat_with_property_bounded (P i)
      (bound i) = Some n
    âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
         a :: indices = prefix ++ i :: suffix
         â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
             j âˆˆ prefix
             â†’ find_largest_nat_with_property_bounded
                 (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk42"><span class="nb">intros</span> (Hi &amp; Hposition &amp; Hfirst).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ indices</span></span></span><br><span><var>Hposition</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  indices = prefix ++ [i] ++ suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i âˆˆ a :: indices
âˆ§ find_largest_nat_with_property_bounded (P i)
    (bound i) = Some n
  âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
       a :: indices = prefix ++ i :: suffix
       â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
           j âˆˆ prefix
           â†’ find_largest_nat_with_property_bounded
               (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk43">split_and!; [<span class="bp">by</span> <span class="nb">right</span> | <span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ indices</span></span></span><br><span><var>Hposition</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  indices = prefix ++ [i] ++ suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  a :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded (P j)
          (bound j) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk44"><span class="nb">intros</span> [| _a prefix] ? Heq; [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ indices</span></span></span><br><span><var>Hposition</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  indices = prefix ++ [i] ++ suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br><span><var>_a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>a :: indices = (_a :: prefix) ++ i :: suffix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">j</span> : index,
  j âˆˆ _a :: prefix
  â†’ find_largest_nat_with_property_bounded (P j)
      (bound j) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk45">simplify_list_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ i :: suffix)
â†’ <span class="kr">âˆ€</span> (<span class="nv">i0</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound (prefix ++ i :: suffix) =
    Some (i0, n)
    â†” i0 âˆˆ prefix ++ i :: suffix
      âˆ§ find_largest_nat_with_property_bounded
          (P i0) (bound i0) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix0</span> <span class="nv">suffix0</span> : list index,
             prefix ++ i :: suffix =
             prefix0 ++ i0 :: suffix0
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix0
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ i :: suffix)</span></span></span><br><span><var>_a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>_a âˆ‰ prefix ++ i :: suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P _a) (bound _a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ prefix ++ i :: suffix</span></span></span><br><span><var>Hposition</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix0</span> <span class="nv">suffix0</span> : list index,
  prefix ++ i :: suffix =
  prefix0 ++ i :: suffix0
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix0
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">j</span> : index,
  j âˆˆ _a :: prefix
  â†’ find_largest_nat_with_property_bounded (P j)
      (bound j) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span>; [| <span class="nb">eapply</span> Hfirst].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk46">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n, _n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some _n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i âˆˆ a :: indices
âˆ§ find_largest_nat_with_property_bounded (P i)
    (bound i) = Some n
  âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
       a :: indices = prefix ++ i :: suffix
       â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
           j âˆˆ prefix
           â†’ find_largest_nat_with_property_bounded
               (P j) (bound j) = None)
â†’ Some (a, _n) = Some (i, n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk47"><span class="nb">intros</span> (Hi &amp; Hposi &amp; Hfirst).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n, _n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some _n</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ a :: indices</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  a :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (a, _n) = Some (i, n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk48"><span class="nb">apply</span> elem_of_cons <span class="kr">in</span> Hi <span class="kr">as</span> [&lt;- | Hi]; [<span class="bp">by</span> <span class="bp">congruence</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n, _n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some _n</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ indices</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  a :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (a, _n) = Some (i, n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk49"><span class="nb">apply</span> elem_of_list_split <span class="kr">in</span> Hi <span class="kr">as</span> (prefix&#39; &amp; suffix &amp; -&gt;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a, i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>prefix', suffix</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix&#39; ++ i :: suffix)
â†’ <span class="kr">âˆ€</span> (<span class="nv">i0</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound (prefix&#39; ++ i :: suffix) =
    Some (i0, n)
    â†” i0 âˆˆ prefix&#39; ++ i :: suffix
      âˆ§ find_largest_nat_with_property_bounded
          (P i0) (bound i0) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix0</span> : list index,
             prefix&#39; ++ i :: suffix =
             prefix ++ [i0] ++ suffix0
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix&#39; ++ i :: suffix)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ prefix&#39; ++ i :: suffix</span></span></span><br><span><var>n, _n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some _n</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix0</span> : list index,
  a :: prefix&#39; ++ i :: suffix =
  prefix ++ i :: suffix0
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (a, _n) = Some (i, n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">erewrite</span> Hfirst <span class="kr">in</span> Hpos; [| <span class="nb">rewrite</span> app_comm_cons | <span class="nb">left</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk4a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i âˆˆ a :: indices
âˆ§ find_largest_nat_with_property_bounded (P i)
    (bound i) = Some n
  âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
       a :: indices = prefix ++ i :: suffix
       â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
           j âˆˆ prefix
           â†’ find_largest_nat_with_property_bounded
               (P j) (bound j) = None)
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = Some (i, n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk4b"><span class="nb">intros</span> (Hi &amp; Hposi &amp; Hfirst).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ a :: indices</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  a :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = Some (i, n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk4c"><span class="nb">apply</span> elem_of_cons <span class="kr">in</span> Hi <span class="kr">as</span> [&lt;- | Hi]; [<span class="bp">by</span> <span class="bp">congruence</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ indices</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  a :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = Some (i, n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk4d"><span class="nb">apply</span> IHindices; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ indices</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  a :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i âˆˆ indices
âˆ§ find_largest_nat_with_property_bounded (P i)
    (bound i) = Some n
  âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
       indices = prefix ++ [i] ++ suffix
       â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
           j âˆˆ prefix
           â†’ find_largest_nat_with_property_bounded
               (P j) (bound j) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk4e">split_and!; [<span class="bp">done</span>.. |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ <span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound indices = 
    Some (i, n)
    â†” i âˆˆ indices
      âˆ§ find_largest_nat_with_property_bounded
          (P i) (bound i) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
             indices =
             prefix ++ [i] ++ suffix
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ indices</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  a :: indices = prefix ++ i :: suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">prefix</span> <span class="nv">suffix</span> : list index,
  indices = prefix ++ [i] ++ suffix
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix
      â†’ find_largest_nat_with_property_bounded (P j)
          (bound j) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk4f"><span class="nb">intros</span> prefix suffix -&gt; j Hj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a, i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ [i] ++ suffix)
â†’ <span class="kr">âˆ€</span> (<span class="nv">i0</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound (prefix ++ [i] ++ suffix) =
    Some (i0, n)
    â†” i0 âˆˆ prefix ++ [i] ++ suffix
      âˆ§ find_largest_nat_with_property_bounded
          (P i0) (bound i0) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix0</span> <span class="nv">suffix0</span> : list index,
             prefix ++ [i] ++ suffix =
             prefix0 ++ [i0] ++ suffix0
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix0
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ [i] ++ suffix)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ prefix ++ [i] ++ suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ prefix ++ [i] ++ suffix</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix0</span> <span class="nv">suffix0</span> : list index,
  a :: prefix ++ [i] ++ suffix =
  prefix0 ++ i :: suffix0
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix0
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hj</var><span class="hyp-type"><b>: </b><span>j âˆˆ prefix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_largest_nat_with_property_bounded (P j) (bound j) =
None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk50"><span class="nb">eapply</span> Hfirst; [| <span class="bp">by</span> <span class="nb">right</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a, i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ [i] ++ suffix)
â†’ <span class="kr">âˆ€</span> (<span class="nv">i0</span> : index) (<span class="nv">n</span> : nat),
    find_first_indexed_largest_nat_with_propery_bounded
      P bound (prefix ++ [i] ++ suffix) =
    Some (i0, n)
    â†” i0 âˆˆ prefix ++ [i] ++ suffix
      âˆ§ find_largest_nat_with_property_bounded
          (P i0) (bound i0) = 
        Some n
        âˆ§ (<span class="kr">âˆ€</span> <span class="nv">prefix0</span> <span class="nv">suffix0</span> : list index,
             prefix ++ [i] ++ suffix =
             prefix0 ++ [i0] ++ suffix0
             â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
                 j âˆˆ prefix0
                 â†’ find_largest_nat_with_property_bounded
                     (P j) 
                     (bound j) = None)</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (prefix ++ [i] ++ suffix)</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ prefix ++ [i] ++ suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hpos</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ prefix ++ [i] ++ suffix</span></span></span><br><span><var>Hposi</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P i) (bound i) = Some n</span></span></span><br><span><var>Hfirst</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">prefix0</span> <span class="nv">suffix0</span> : list index,
  a :: prefix ++ [i] ++ suffix =
  prefix0 ++ i :: suffix0
  â†’ <span class="kr">âˆ€</span> <span class="nv">j</span> : index,
      j âˆˆ prefix0
      â†’ find_largest_nat_with_property_bounded
          (P j) (bound j) = None</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hj</var><span class="hyp-type"><b>: </b><span>j âˆˆ prefix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: prefix ++ [i] ++ suffix =
(<span class="nl">?y</span> :: prefix) ++ i :: <span class="nl">?suffix</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> app_comm_cons.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk51"><span class="kn">Lemma</span> <span class="nf">find_first_indexed_largest_nat_with_propery_bounded_None</span> {<span class="nv">index</span>}
  (<span class="nv">P</span> : index -&gt; nat -&gt; <span class="kt">Prop</span>) `{!RelDecision P}
  (bound : index -&gt; nat)
  (indices : list index) (Hindices : NoDup indices)
  : find_first_indexed_largest_nat_with_propery_bounded P bound indices = None
      &lt;-&gt;
    <span class="kr">forall</span> (<span class="nv">i</span> : index), i âˆˆ indices -&gt;
      find_largest_nat_with_property_bounded (P i) (bound i) = None.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = None
â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
     i âˆˆ indices
     â†’ find_largest_nat_with_property_bounded (P i)
         (bound i) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk52"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = None
â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
     i âˆˆ indices
     â†’ find_largest_nat_with_property_bounded (P i)
         (bound i) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk53"><span class="nb">induction</span> indices; simp find_first_indexed_largest_nat_with_propery_bounded;
    [<span class="bp">by</span> <span class="nb">split</span>; [<span class="nb">inversion</span> <span class="mi">2</span> |] |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup (a :: indices)</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded_clause_2
  (@find_first_indexed_largest_nat_with_propery_bounded)
  index P RelDecision0 bound a
  (inspect
     (find_largest_nat_with_property_bounded (P a)
        (bound a))) indices = None
â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
     i âˆˆ a :: indices
     â†’ find_largest_nat_with_property_bounded (P i)
         (bound i) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk54"><span class="nb">apply</span> NoDup_cons <span class="kr">in</span> Hindices <span class="kr">as</span> [Ha Hindices].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded_clause_2
  (@find_first_indexed_largest_nat_with_propery_bounded)
  index P RelDecision0 bound a
  (inspect
     (find_largest_nat_with_property_bounded (P a)
        (bound a))) indices = None
â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
     i âˆˆ a :: indices
     â†’ find_largest_nat_with_property_bounded (P i)
         (bound i) = None)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk55"><span class="nb">cbn</span>; <span class="nb">split</span>; <span class="nb">destruct</span> find_largest_nat_with_property_bounded <span class="nb">eqn</span>: Hp; [<span class="bp">done</span> | | |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = None
â†’ <span class="kr">âˆ€</span> <span class="nv">i</span> : index,
    i âˆˆ a :: indices
    â†’ find_largest_nat_with_property_bounded (P i)
        (bound i) = None</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some n</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk56"><hr></label><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
   i âˆˆ a :: indices
   â†’ find_largest_nat_with_property_bounded 
       (P i) (bound i) = None) â†’ 
Some (a, n) = None</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk57"><hr></label><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
   i âˆˆ a :: indices
   â†’ find_largest_nat_with_property_bounded 
       (P i) (bound i) = None)
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk58">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = None
â†’ <span class="kr">âˆ€</span> <span class="nv">i</span> : index,
    i âˆˆ a :: indices
    â†’ find_largest_nat_with_property_bounded (P i)
        (bound i) = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> Hnone i Hi; <span class="nb">apply</span> elem_of_cons <span class="kr">in</span> Hi <span class="kr">as</span>  [-&gt; | Hi]; [| <span class="nb">eapply</span> IHindices].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk59">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
   i âˆˆ a :: indices
   â†’ find_largest_nat_with_property_bounded (P i)
       (bound i) = None) â†’ Some (a, n) = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk5a"><span class="nb">intro</span> Hmin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some n</span></span></span><br><span><var>Hmin</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ a :: indices
  â†’ find_largest_nat_with_property_bounded
      (P i) (bound i) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (a, n) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk5b"><span class="nb">replace</span> (find_largest_nat_with_property_bounded (P a) (bound a))
      <span class="kr">with</span> (@None nat) <span class="kr">in</span> Hp; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = Some n</span></span></span><br><span><var>Hmin</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ a :: indices
  â†’ find_largest_nat_with_property_bounded
      (P i) (bound i) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">None =
find_largest_nat_with_property_bounded (P a) (bound a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">symmetry</span>; <span class="nb">apply</span> Hmin; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk5c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
   i âˆˆ a :: indices
   â†’ find_largest_nat_with_property_bounded (P i)
       (bound i) = None)
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk5d"><span class="nb">intros</span> Hmin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hmin</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ a :: indices
  â†’ find_largest_nat_with_property_bounded
      (P i) (bound i) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">find_first_indexed_largest_nat_with_propery_bounded P
  bound indices = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk5e"><span class="nb">apply</span> IHindices; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>index â†’ nat â†’ <span class="kt">Prop</span></span></span></span><br><span><var>RelDecision0</var><span class="hyp-type"><b>: </b><span>RelDecision P</span></span></span><br><span><var>bound</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>indices</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ indices</span></span></span><br><span><var>Hindices</var><span class="hyp-type"><b>: </b><span>NoDup indices</span></span></span><br><span><var>IHindices</var><span class="hyp-type"><b>: </b><span>NoDup indices
â†’ find_first_indexed_largest_nat_with_propery_bounded
    P bound indices = None
  â†” (<span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ indices
       â†’ find_largest_nat_with_property_bounded
           (P i) (bound i) = None)</span></span></span><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>find_largest_nat_with_property_bounded 
  (P a) (bound a) = None</span></span></span><br><span><var>Hmin</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ a :: indices
  â†’ find_largest_nat_with_property_bounded
      (P i) (bound i) = None</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ indices
  â†’ find_largest_nat_with_property_bounded (P i)
      (bound i) = None</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">apply</span> Hmin; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><div class="doc">
<a id="lab2"></a><h2 class="section">Products of (natural) powers of integers</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">sec_prod_powers</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span>
  `{EqDecision index}
  `(multipliers : index -&gt; Z)
  .</span></span></pre><div class="doc">
  Despite being functions, <code>multipliers</code> are supposed to represent a list
  <code>[m_1, ..., m_n]</code> and <code>powers</code> are supposed to represent a list
  <code>[p_1, ..., p_n]</code>. The function computes <code>m_1^p_1 * ... * m_n^p_n</code>.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prod_powers_aux</span> (<span class="nv">powers</span> : index -&gt; nat) (<span class="nv">l</span> : list index) : Z :=
  foldr Z.mul <span class="mi">1</span>%Z (zip_with Z.pow (map multipliers l) (map (Z.of_nat âˆ˜ powers) l)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk5f">#[export] <span class="kn">Instance</span> <span class="nf">prod_powers_aux_proper</span> :
  Proper ((=) ==&gt; (â‰¡â‚š) ==&gt; (=)) prod_powers_aux.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (eq ==&gt; Permutation ==&gt; eq) prod_powers_aux</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk60"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (eq ==&gt; Permutation ==&gt; eq) prod_powers_aux</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk61"><span class="nb">intros</span> _f f -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Permutation ==&gt; eq)%signature (prod_powers_aux f)
  (prod_powers_aux f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk62"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">cbn</span>; [<span class="bp">done</span> | ..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l â‰¡â‚š l&#39;</span></span></span><br><span><var>IHPermutation</var><span class="hyp-type"><b>: </b><span>prod_powers_aux f l =
prod_powers_aux f l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers x ^ Z.of_nat (f x) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ f) l)))%Z =
(multipliers x ^ Z.of_nat (f x) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l&#39;)
      (map (Z.of_nat âˆ˜ f) l&#39;)))%Z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk63" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk63"><hr></label><div class="goal-conclusion">(multipliers y ^ Z.of_nat (f y) *
 (multipliers x ^ Z.of_nat (f x) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z =
(multipliers x ^ Z.of_nat (f x) *
 (multipliers y ^ Z.of_nat (f y) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l, l', l''</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l â‰¡â‚š l&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l&#39; â‰¡â‚š l&#39;&#39;</span></span></span><br><span><var>IHPermutation1</var><span class="hyp-type"><b>: </b><span>prod_powers_aux f l =
prod_powers_aux f l&#39;</span></span></span><br><span><var>IHPermutation2</var><span class="hyp-type"><b>: </b><span>prod_powers_aux f l&#39; =
prod_powers_aux f l&#39;&#39;</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk64"><hr></label><div class="goal-conclusion">prod_powers_aux f l = prod_powers_aux f l&#39;&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk65">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l â‰¡â‚š l&#39;</span></span></span><br><span><var>IHPermutation</var><span class="hyp-type"><b>: </b><span>prod_powers_aux f l =
prod_powers_aux f l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers x ^ Z.of_nat (f x) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ f) l)))%Z =
(multipliers x ^ Z.of_nat (f x) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l&#39;)
      (map (Z.of_nat âˆ˜ f) l&#39;)))%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">setoid_rewrite</span> IHPermutation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers y ^ Z.of_nat (f y) *
 (multipliers x ^ Z.of_nat (f x) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z =
(multipliers x ^ Z.of_nat (f x) *
 (multipliers y ^ Z.of_nat (f y) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk67">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l, l', l''</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>l â‰¡â‚š l&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>l&#39; â‰¡â‚š l&#39;&#39;</span></span></span><br><span><var>IHPermutation1</var><span class="hyp-type"><b>: </b><span>prod_powers_aux f l =
prod_powers_aux f l&#39;</span></span></span><br><span><var>IHPermutation2</var><span class="hyp-type"><b>: </b><span>prod_powers_aux f l&#39; =
prod_powers_aux f l&#39;&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_powers_aux f l = prod_powers_aux f l&#39;&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk68"><span class="kn">Lemma</span> <span class="nf">prod_powers_aux_ext_forall</span> (<span class="nv">powers1</span> <span class="nv">powers2</span> : index -&gt; nat) (<span class="nv">l</span> : list index) :
  (<span class="kr">forall</span> <span class="nv">i</span>, i âˆˆ l -&gt; powers1 i = powers2 i) -&gt;
  prod_powers_aux powers1 l = prod_powers_aux powers2 l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers1, powers2</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">i</span> : index, i âˆˆ l â†’ powers1 i = powers2 i)
â†’ prod_powers_aux powers1 l =
  prod_powers_aux powers2 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers1, powers2</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">i</span> : index, i âˆˆ l â†’ powers1 i = powers2 i)
â†’ prod_powers_aux powers1 l =
  prod_powers_aux powers2 l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk6a"><span class="nb">intros</span> Hall; <span class="nb">unfold</span> prod_powers_aux.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers1, powers2</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, i âˆˆ l â†’ powers1 i = powers2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr Z.mul <span class="mi">1</span>%Z
  (zip_with Z.pow (map multipliers l)
     (map (Z.of_nat âˆ˜ powers1) l)) =
foldr Z.mul <span class="mi">1</span>%Z
  (zip_with Z.pow (map multipliers l)
     (map (Z.of_nat âˆ˜ powers2) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk6b"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers1, powers2</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, i âˆˆ l â†’ powers1 i = powers2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map (Z.of_nat âˆ˜ powers1) l =
map (Z.of_nat âˆ˜ powers2) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk6c"><span class="nb">apply</span> map_ext_Forall, Forall_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers1, powers2</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, i âˆˆ l â†’ powers1 i = powers2 i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">x</span> : index,
  x âˆˆ l
  â†’ (Z.of_nat âˆ˜ powers1) x = (Z.of_nat âˆ˜ powers2) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="nb">apply</span> Hall.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk6d"><span class="kn">Lemma</span> <span class="nf">prod_powers_aux_ge_1</span> (<span class="nv">powers</span> : index -&gt; nat) (<span class="nv">l</span> : list index)
  (<span class="nv">Hmpos</span> : Forall (<span class="kr">fun</span> <span class="nv">i</span> =&gt; (multipliers i &gt; <span class="mi">0</span>)%Z) l) :
  (prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk6f"><span class="nb">revert</span> Hmpos; <span class="nb">induction</span> l; [<span class="bp">by</span> <span class="nb">cbn</span>; <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l
â†’ (prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) (a :: l)
â†’ (prod_powers_aux powers (a :: l) &gt;= <span class="mi">1</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk70"><span class="nb">rewrite</span> Forall_cons; <span class="nb">intros</span> [Hma Hmpos].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l
â†’ (prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(prod_powers_aux powers (a :: l) &gt;= <span class="mi">1</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk71"><span class="nb">change</span> (prod_powers_aux powers (a :: l))
    <span class="kr">with</span> (multipliers a ^ Z.of_nat (powers a) * prod_powers_aux powers l)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l
â†’ (prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (powers a) *
 prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">specialize</span> (IHl Hmpos); <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk72"><span class="kn">Lemma</span> <span class="nf">prod_powers_aux_gt</span> (<span class="nv">powers</span> : index -&gt; nat) (<span class="nv">l</span> : list index)
  (<span class="nv">n</span> : Z) (<span class="nv">Hn</span> : (n &gt;= <span class="mi">0</span>)%Z)
  (<span class="nv">Hmpos</span> : Forall (<span class="kr">fun</span> <span class="nv">i</span> =&gt; (multipliers i &gt; n)%Z) l) :
  Exists (<span class="kr">fun</span> <span class="nv">i</span> =&gt; powers i &lt;&gt; <span class="mi">0</span>) l -&gt; (prod_powers_aux powers l &gt; n)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
â†’ (prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk73"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
â†’ (prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk74"><span class="nb">revert</span> Hmpos; <span class="nb">induction</span> l; [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">2</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) (a :: l)
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) (a :: l)
  â†’ (prod_powers_aux powers (a :: l) &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk75"><span class="nb">change</span> (prod_powers_aux powers (a :: l))
    <span class="kr">with</span> (multipliers a ^ Z.of_nat (powers a) * prod_powers_aux powers l)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) (a :: l)
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) (a :: l)
  â†’ (multipliers a ^ Z.of_nat (powers a) *
     prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk76"><span class="nb">rewrite</span> Forall_cons, Exists_cons; <span class="nb">intros</span> [Hma Hmpos] Hppos.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (powers a) *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk77"><span class="nb">destruct</span> (decide (powers a = <span class="mi">0</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>powers a = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (powers a) *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk78" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk78"><hr></label><div class="goal-conclusion">(multipliers a ^ Z.of_nat (powers a) *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk79">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>powers a = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (powers a) *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk7a"><span class="nb">cut</span> (prod_powers_aux powers l &gt; n)%Z; [<span class="bp">by</span> <span class="bp">nia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>powers a = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk7b"><span class="nb">apply</span> IHl; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>powers a = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">destruct</span> Hppos.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk7c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>powers a â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (powers a) *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk7d"><span class="nb">destruct</span> (powers a) <span class="kr">as</span> [| pa]; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>pa</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (S pa) *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk7e"><span class="nb">replace</span> (Z.of_nat (S pa)) <span class="kr">with</span> (Z.succ (Z.of_nat pa)) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>pa</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.succ (Z.of_nat pa) *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk7f"><span class="nb">rewrite</span> Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>pa</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a * multipliers a ^ Z.of_nat pa *
 prod_powers_aux powers l &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk80"><span class="nb">cut</span> (multipliers a ^ Z.of_nat pa * prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z; [<span class="bp">by</span> <span class="bp">nia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>pa</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat pa *
 prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk81"><span class="nb">cut</span> (prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z; [<span class="bp">by</span> <span class="bp">nia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>pa</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(prod_powers_aux powers l &gt;= <span class="mi">1</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk82"><span class="nb">apply</span> prod_powers_aux_ge_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l</span></span></span><br><span><var>pa</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; <span class="mi">0</span>)%Z) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk83"><span class="nb">rewrite</span> Forall_forall <span class="kr">in</span> Hmpos |- *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>powers</var><span class="hyp-type"><b>: </b><span>index â†’ nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z) l
â†’ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l
  â†’ (prod_powers_aux powers l &gt; n)%Z</span></span></span><br><span><var>Hma</var><span class="hyp-type"><b>: </b><span>(multipliers a &gt; n)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">x</span> : index, x âˆˆ l â†’ (multipliers x &gt; n)%Z</span></span></span><br><span><var>pa</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hppos</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span>
âˆ¨ Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, powers i â‰  <span class="mi">0</span>) l</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>S pa â‰  <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">x</span> : index, x âˆˆ l â†’ (multipliers x &gt; <span class="mi">0</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> x Hx; <span class="nb">specialize</span> (Hmpos x Hx); <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fsfun_prod</span> (<span class="nv">f</span> : fsfun index <span class="mi">0</span>) : Z :=
  prod_powers_aux f (fin_supp f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk84">#[export] <span class="kn">Instance</span> <span class="nf">fsfun_prod_proper</span> : Proper ((â‰¡) ==&gt; (=)) fsfun_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (equiv ==&gt; eq) fsfun_prod</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk85"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (equiv ==&gt; eq) fsfun_prod</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> f g Heq; <span class="nb">apply</span> prod_powers_aux_proper, fin_supp_proper.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk86"><span class="kn">Lemma</span> <span class="nf">fsfun_prod_zero</span> : fsfun_prod zero_fsfun = <span class="mi">1</span>%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod zero_fsfun = <span class="mi">1</span>%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod zero_fsfun = <span class="mi">1</span>%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk88"><span class="kn">Lemma</span> <span class="nf">fsfun_prod_succ</span> (<span class="nv">f</span> : fsfun index <span class="mi">0</span>) (<span class="nv">n</span> : index) :
  fsfun_prod (succ_fsfun f n) = (multipliers n * fsfun_prod f)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (succ_fsfun f n) =
(multipliers n * fsfun_prod f)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk89"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (succ_fsfun f n) =
(multipliers n * fsfun_prod f)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk8a"><span class="nb">unfold</span> fsfun_prod.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_powers_aux (succ_fsfun f n)
  (fin_supp (succ_fsfun f n)) =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk8b"><span class="nb">destruct</span> (decide (n âˆˆ fin_supp f)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n âˆˆ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_powers_aux (succ_fsfun f n)
  (fin_supp (succ_fsfun f n)) =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n âˆ‰ fin_supp f</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk8c"><hr></label><div class="goal-conclusion">prod_powers_aux (succ_fsfun f n)
  (fin_supp (succ_fsfun f n)) =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk8d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n âˆˆ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_powers_aux (succ_fsfun f n)
  (fin_supp (succ_fsfun f n)) =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk8e"><span class="nb">rewrite</span> succ_fsfun_supp_in <span class="bp">by</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>n âˆˆ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_powers_aux (succ_fsfun f n) (fin_supp f) =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk8f"><span class="nb">revert</span> e; <span class="nb">specialize</span> (fin_supp_NoDup f).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (fin_supp f)
â†’ n âˆˆ fin_supp f
  â†’ prod_powers_aux (succ_fsfun f n) (fin_supp f) =
    (multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk90"><span class="nb">generalize</span> (fin_supp f) <span class="kr">as</span> l; <span class="nb">clear</span>; <span class="nb">induction</span> l; [<span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">2</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n, a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (a :: l)
â†’ n âˆˆ a :: l
  â†’ prod_powers_aux (succ_fsfun f n) (a :: l) =
    (multipliers n * prod_powers_aux f (a :: l))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk91"><span class="nb">rewrite</span> list.NoDup_cons, elem_of_cons; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n, a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a âˆ‰ l) âˆ§ NoDup l
â†’ n = a âˆ¨ n âˆˆ l
  â†’ (multipliers a ^ Z.of_nat (succ_fsfun f n a) *
     foldr Z.mul <span class="mi">1</span>
       (zip_with Z.pow (map multipliers l)
          (map (Z.of_nat âˆ˜ succ_fsfun f n) l)))%Z =
    (multipliers n *
     (multipliers a ^ Z.of_nat (f a) *
      foldr Z.mul <span class="mi">1</span>
        (zip_with Z.pow (map multipliers l)
           (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk92"><span class="nb">intros</span> [Ha Hnodup] [&lt;- | Hn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>n âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers n ^ Z.of_nat (succ_fsfun f n n) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ succ_fsfun f n) l)))%Z =
(multipliers n *
 (multipliers n ^ Z.of_nat (f n) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n, a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n âˆˆ l</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chk93"><hr></label><div class="goal-conclusion">(multipliers a ^ Z.of_nat (succ_fsfun f n a) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ succ_fsfun f n) l)))%Z =
(multipliers n *
 (multipliers a ^ Z.of_nat (f a) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk94">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>n âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers n ^ Z.of_nat (succ_fsfun f n n) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ succ_fsfun f n) l)))%Z =
(multipliers n *
 (multipliers n ^ Z.of_nat (f n) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk95"><span class="nb">rewrite</span> succ_fsfun_eq, assoc <span class="bp">by</span> <span class="nb">typeclasses eauto</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>n âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers n ^ Z.of_nat (S (f n)) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ succ_fsfun f n) l)))%Z =
(multipliers n * multipliers n ^ Z.of_nat (f n) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ f) l)))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk96"><span class="nb">f_equal</span>; [<span class="bp">by</span> <span class="nb">rewrite</span> &lt;- Z.pow_succ_r; <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>n âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr Z.mul <span class="mi">1</span>%Z
  (zip_with Z.pow (map multipliers l)
     (map (Z.of_nat âˆ˜ succ_fsfun f n) l)) =
foldr Z.mul <span class="mi">1</span>%Z
  (zip_with Z.pow (map multipliers l)
     (map (Z.of_nat âˆ˜ f) l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk97"><span class="nb">apply</span> prod_powers_aux_ext_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>n âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">i</span> : index, i âˆˆ l â†’ succ_fsfun f n i = f i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">rewrite</span> succ_fsfun_neq; [ |set_solver].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk98">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n, a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n âˆˆ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (succ_fsfun f n a) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ succ_fsfun f n) l)))%Z =
(multipliers n *
 (multipliers a ^ Z.of_nat (f a) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk99"><span class="nb">rewrite</span> succ_fsfun_neq <span class="bp">by</span> set_solver.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n, a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n âˆˆ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (f a) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers l)
      (map (Z.of_nat âˆ˜ succ_fsfun f n) l)))%Z =
(multipliers n *
 (multipliers a ^ Z.of_nat (f a) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk9a"><span class="nb">setoid_rewrite</span> IHl; [| <span class="bp">done</span>..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n, a</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>NoDup l
â†’ n âˆˆ l
  â†’ prod_powers_aux (succ_fsfun f n) l =
    (multipliers n * prod_powers_aux f l)%Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a âˆ‰ l</span></span></span><br><span><var>Hnodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>n âˆˆ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers a ^ Z.of_nat (f a) *
 (multipliers n * prod_powers_aux f l))%Z =
(multipliers n *
 (multipliers a ^ Z.of_nat (f a) *
  foldr Z.mul <span class="mi">1</span>
    (zip_with Z.pow (map multipliers l)
       (map (Z.of_nat âˆ˜ f) l))))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">unfold</span> prod_powers_aux; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk9b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n âˆ‰ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_powers_aux (succ_fsfun f n)
  (fin_supp (succ_fsfun f n)) =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk9c"><span class="nb">rewrite</span> succ_fsfun_supp_not_in <span class="bp">by</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n âˆ‰ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod_powers_aux (succ_fsfun f n) (n :: fin_supp f) =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk9d"><span class="nb">cbn</span>; <span class="nb">rewrite</span> succ_fsfun_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n âˆ‰ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers n ^ Z.of_nat (S (f n)) *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers (fin_supp f))
      (map (Z.of_nat âˆ˜ succ_fsfun f n) (fin_supp f))))%Z =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk9e"><span class="nb">assert</span> (f n = <span class="mi">0</span>) <span class="kr">as</span> -&gt; <span class="bp">by</span> (<span class="nb">rewrite</span> elem_of_fin_supp <span class="kr">in</span> n0; <span class="nb">cbn</span> <span class="kr">in</span> n0; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n âˆ‰ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers n ^ Z.of_nat <span class="mi">1</span> *
 foldr Z.mul <span class="mi">1</span>
   (zip_with Z.pow (map multipliers (fin_supp f))
      (map (Z.of_nat âˆ˜ succ_fsfun f n) (fin_supp f))))%Z =
(multipliers n * prod_powers_aux f (fin_supp f))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chk9f"><span class="nb">cbn</span>; <span class="nb">f_equal</span>; [<span class="bp">by</span> <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n âˆ‰ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">foldr Z.mul <span class="mi">1</span>%Z
  (zip_with Z.pow (map multipliers (fin_supp f))
     (map (Z.of_nat âˆ˜ succ_fsfun f n) (fin_supp f))) =
prod_powers_aux f (fin_supp f)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka0"><span class="nb">apply</span> prod_powers_aux_ext_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>n âˆ‰ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">i</span> : index, i âˆˆ fin_supp f â†’ succ_fsfun f n i = f i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">rewrite</span> succ_fsfun_neq; [| set_solver].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka1"><span class="kn">Lemma</span> <span class="nf">prod_powers_delta</span> (<span class="nv">n</span> : index) :
  fsfun_prod (delta_nat_fsfun n) = multipliers n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (delta_nat_fsfun n) = multipliers n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (delta_nat_fsfun n) = multipliers n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka3"><span class="nb">intros</span>; <span class="nb">unfold</span> delta_nat_fsfun.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (succ_fsfun zero_fsfun n) = multipliers n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka4"><span class="nb">rewrite</span> fsfun_prod_succ, fsfun_prod_zero <span class="bp">by</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers n * <span class="mi">1</span>)%Z = multipliers n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka5"><span class="kn">Lemma</span> <span class="nf">prod_powers_gt</span> (<span class="nv">n</span> : Z) (<span class="nv">Hn</span> : (n &gt;= <span class="mi">0</span>)%Z)
  (<span class="nv">Hmpos</span> : <span class="kr">forall</span> (<span class="nv">i</span> : index), (multipliers i &gt; n)%Z) :
  <span class="kr">forall</span> (<span class="nv">f</span> : fsfun index <span class="mi">0</span>), fin_supp f &lt;&gt; [] -&gt;
  (fsfun_prod f &gt; n)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">f</span> : fsfun index <span class="mi">0</span>,
  fin_supp f â‰  [] â†’ (fsfun_prod f &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">f</span> : fsfun index <span class="mi">0</span>,
  fin_supp f â‰  [] â†’ (fsfun_prod f &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fin_supp f â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fsfun_prod f &gt; n)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chka8"><span class="nb">apply</span> prod_powers_aux_gt; [<span class="bp">done</span> | ..].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fin_supp f â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z)
  (fin_supp f)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fin_supp f â‰  []</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chka9"><hr></label><div class="goal-conclusion">Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, f i â‰  <span class="mi">0</span>) (fin_supp f)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkaa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fin_supp f â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">Î»</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z)
  (fin_supp f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> Forall_forall; <span class="nb">intros</span>; <span class="nb">apply</span> Hmpos.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkab">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fin_supp f â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">Î»</span> <span class="nv">i</span> : index, f i â‰  <span class="mi">0</span>) (fin_supp f)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkac"><span class="nb">apply</span> Exists_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fin_supp f â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">x</span> : index, x âˆˆ fin_supp f âˆ§ f x â‰  <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkad"><span class="nb">unfold</span> fin_supp; <span class="nb">setoid_rewrite</span> elem_of_list_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>fin_supp f â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">x</span> : index,
  (<span class="kr">âˆƒ</span> <span class="nv">y</span> : {x0 : index | bool_decide (f x0 â‰  <span class="mi">0</span>)},
     x = `y âˆ§ y âˆˆ enum (support <span class="mi">0</span> f)) âˆ§ f x â‰  <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkae"><span class="nb">destruct</span> (fin_supp f) <span class="nb">eqn</span>: Heq; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>fin_supp f = i :: l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i :: l â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">x</span> : index,
  (<span class="kr">âˆƒ</span> <span class="nv">y</span> : {x0 : index | bool_decide (f x0 â‰  <span class="mi">0</span>)},
     x = `y âˆ§ y âˆˆ enum (support <span class="mi">0</span> f)) âˆ§ f x â‰  <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkaf"><span class="nb">assert</span> (Hi : i âˆˆ fin_supp f) <span class="bp">by</span> (<span class="nb">rewrite</span> Heq; <span class="nb">left</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>fin_supp f = i :: l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i :: l â‰  []</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">x</span> : index,
  (<span class="kr">âˆƒ</span> <span class="nv">y</span> : {x0 : index | bool_decide (f x0 â‰  <span class="mi">0</span>)},
     x = `y âˆ§ y âˆˆ enum (support <span class="mi">0</span> f)) âˆ§ f x â‰  <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb0"><span class="nb">apply</span> elem_of_list_fmap <span class="kr">in</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>fin_supp f = i :: l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i :: l â‰  []</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">y</span> : {x : index | bool_decide (f x â‰  <span class="mi">0</span>)},
  i = `y âˆ§ y âˆˆ enum (support <span class="mi">0</span> f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">x</span> : index,
  (<span class="kr">âˆƒ</span> <span class="nv">y</span> : {x0 : index | bool_decide (f x0 â‰  <span class="mi">0</span>)},
     x = `y âˆ§ y âˆˆ enum (support <span class="mi">0</span> f)) âˆ§ f x â‰  <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb1"><span class="nb">eexists</span>; <span class="nb">split</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>fin_supp f = i :: l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>i :: l â‰  []</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆƒ</span> <span class="nv">y</span> : {x : index | bool_decide (f x â‰  <span class="mi">0</span>)},
  i = `y âˆ§ y âˆˆ enum (support <span class="mi">0</span> f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f i â‰  <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb2"><span class="nb">destruct</span> Hi <span class="kr">as</span> ([j Hj] &amp; [= -&gt;] &amp; b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n &gt;= <span class="mi">0</span>)%Z</span></span></span><br><span><var>Hmpos</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index, (multipliers i &gt; n)%Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list index</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>j :: l â‰  []</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>fin_supp f = j :: l</span></span></span><br><span><var>Hj</var><span class="hyp-type"><b>: </b><span>bool_decide (f j â‰  <span class="mi">0</span>)</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>j â†¾ Hj âˆˆ enum (support <span class="mi">0</span> f)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f j â‰  <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> bool_decide_unpack.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb3"><span class="kn">Lemma</span> <span class="nf">prod_powers_elem_of_dom</span> :
  <span class="kr">forall</span> (<span class="nv">f</span> : fsfun index <span class="mi">0</span>) (<span class="nv">i</span> : index),
    i âˆˆ fin_supp f -&gt; (multipliers i | fsfun_prod f)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">f</span> : fsfun index <span class="mi">0</span>) (<span class="nv">i</span> : index),
  i âˆˆ fin_supp f â†’ (multipliers i | fsfun_prod f)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">f</span> : fsfun index <span class="mi">0</span>) (<span class="nv">i</span> : index),
  i âˆˆ fin_supp f â†’ (multipliers i | fsfun_prod f)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb5"><span class="nb">apply</span> (nat_fsfun_ind (<span class="kr">fun</span> <span class="nv">f</span> =&gt; <span class="kr">forall</span> <span class="nv">i</span>, i âˆˆ fin_supp f -&gt; (multipliers i | fsfun_prod f)%Z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (equiv ==&gt; impl)
  (<span class="kr">Î»</span> <span class="nv">f</span> : fsfun index <span class="mi">0</span>,
     <span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ fin_supp f
       â†’ (multipliers i | fsfun_prod f)%Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkb6"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp zero_fsfun
  â†’ (multipliers i | fsfun_prod zero_fsfun)%Z</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkb7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkb7"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">f</span> : fsfun index <span class="mi">0</span>),
  (<span class="kr">âˆ€</span> <span class="nv">i0</span> : index,
     i0 âˆˆ fin_supp f
     â†’ (multipliers i0 | fsfun_prod f)%Z)
  â†’ <span class="kr">âˆ€</span> <span class="nv">i0</span> : index,
      i0 âˆˆ fin_supp (succ_fsfun f i)
      â†’ (multipliers i0 | fsfun_prod (succ_fsfun f i))%Z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (equiv ==&gt; impl)
  (<span class="kr">Î»</span> <span class="nv">f</span> : fsfun index <span class="mi">0</span>,
     <span class="kr">âˆ€</span> <span class="nv">i</span> : index,
       i âˆˆ fin_supp f
       â†’ (multipliers i | fsfun_prod f)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkb9"><span class="nb">intros</span> f g Heq Hall i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f â‰¡ g</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp f
  â†’ (multipliers i | fsfun_prod f)%Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp g</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i | fsfun_prod g)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkba"><span class="nb">rewrite</span> &lt;- Heq <span class="kr">in</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f â‰¡ g</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp f
  â†’ (multipliers i | fsfun_prod f)%Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i | fsfun_prod g)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkbb"><span class="nb">apply</span> Hall <span class="kr">in</span> Hi <span class="kr">as</span> [x Hx].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f â‰¡ g</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp f
  â†’ (multipliers i | fsfun_prod f)%Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span>fsfun_prod f = (x * multipliers i)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i | fsfun_prod g)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">x</span>; <span class="nb">rewrite</span> &lt;- Heq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkbc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp zero_fsfun
  â†’ (multipliers i | fsfun_prod zero_fsfun)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkbd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">f</span> : fsfun index <span class="mi">0</span>),
  (<span class="kr">âˆ€</span> <span class="nv">i0</span> : index,
     i0 âˆˆ fin_supp f
     â†’ (multipliers i0 | fsfun_prod f)%Z)
  â†’ <span class="kr">âˆ€</span> <span class="nv">i0</span> : index,
      i0 âˆˆ fin_supp (succ_fsfun f i)
      â†’ (multipliers i0 | fsfun_prod (succ_fsfun f i))%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkbe"><span class="nb">intros</span> j f IHf i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp f
  â†’ (multipliers i | fsfun_prod f)%Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp (succ_fsfun f j)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i | fsfun_prod (succ_fsfun f j))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkbf"><span class="nb">rewrite</span> fsfun_prod_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp f
  â†’ (multipliers i | fsfun_prod f)%Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp (succ_fsfun f j)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i | multipliers j * fsfun_prod f)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc0"><span class="nb">apply</span> elem_of_succ_fsfun <span class="kr">in</span> Hi <span class="kr">as</span> [&lt;- | Hi]; [<span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">fsfun_prod</span> <span class="nv">f</span>); <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp f
  â†’ (multipliers i | fsfun_prod f)%Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp f</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i | multipliers j * fsfun_prod f)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc1"><span class="nb">destruct</span> (IHf _ Hi) <span class="kr">as</span> [x -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">i</span> : index,
  i âˆˆ fin_supp f
  â†’ (multipliers i | fsfun_prod f)%Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp f</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i | multipliers j * (x * multipliers i))%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">multipliers</span> <span class="nv">j</span> * x)%Z; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc2"><span class="kn">Lemma</span> <span class="nf">prod_powers_add</span> :
  <span class="kr">forall</span> (<span class="nv">f1</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>),
    fsfun_prod (add_fsfun f1 f2) = (fsfun_prod f1 * fsfun_prod f2)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">f1</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun f1 f2) =
  (fsfun_prod f1 * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">f1</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun f1 f2) =
  (fsfun_prod f1 * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc4"><span class="nb">apply</span> (nat_fsfun_ind (<span class="kr">fun</span> <span class="nv">f1</span> =&gt; <span class="kr">forall</span> <span class="nv">f2</span>,
    fsfun_prod (add_fsfun f1 f2) = (fsfun_prod f1 * fsfun_prod f2)%Z)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (equiv ==&gt; impl)
  (<span class="kr">Î»</span> <span class="nv">f1</span> : fsfun index <span class="mi">0</span>,
     <span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
       fsfun_prod (add_fsfun f1 f2) =
       (fsfun_prod f1 * fsfun_prod f2)%Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkc5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkc5"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun zero_fsfun f2) =
  (fsfun_prod zero_fsfun * fsfun_prod f2)%Z</div></blockquote><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkc6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkc6"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">f</span> : fsfun index <span class="mi">0</span>),
  (<span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
     fsfun_prod (add_fsfun f f2) =
     (fsfun_prod f * fsfun_prod f2)%Z)
  â†’ <span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
      fsfun_prod (add_fsfun (succ_fsfun f i) f2) =
      (fsfun_prod (succ_fsfun f i) * fsfun_prod f2)%Z</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Proper (equiv ==&gt; impl)
  (<span class="kr">Î»</span> <span class="nv">f1</span> : fsfun index <span class="mi">0</span>,
     <span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
       fsfun_prod (add_fsfun f1 f2) =
       (fsfun_prod f1 * fsfun_prod f2)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc8"><span class="nb">intros</span> f f1 Heq Hall f2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f, f1</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f â‰¡ f1</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun f f2) =
  (fsfun_prod f * fsfun_prod f2)%Z</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (add_fsfun f1 f2) =
(fsfun_prod f1 * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkc9"><span class="nb">rewrite</span> &lt;- Heq, Hall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f, f1</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>f â‰¡ f1</span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun f f2) =
  (fsfun_prod f * fsfun_prod f2)%Z</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(fsfun_prod f * fsfun_prod f2)%Z =
(fsfun_prod f * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkca">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun zero_fsfun f2) =
  (fsfun_prod zero_fsfun * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkcb"><span class="nb">intros</span> f2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (add_fsfun zero_fsfun f2) =
(fsfun_prod zero_fsfun * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkcc"><span class="nb">rewrite</span> fsfun_prod_zero, left_id <span class="bp">by</span> <span class="nb">typeclasses eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod f2 = (<span class="mi">1</span> * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkcd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> (<span class="nv">i</span> : index) (<span class="nv">f</span> : fsfun index <span class="mi">0</span>),
  (<span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
     fsfun_prod (add_fsfun f f2) =
     (fsfun_prod f * fsfun_prod f2)%Z)
  â†’ <span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
      fsfun_prod (add_fsfun (succ_fsfun f i) f2) =
      (fsfun_prod (succ_fsfun f i) * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkce"><span class="nb">intros</span> i f1 Hall f2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun f1 f2) =
  (fsfun_prod f1 * fsfun_prod f2)%Z</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fsfun_prod (add_fsfun (succ_fsfun f1 i) f2) =
(fsfun_prod (succ_fsfun f1 i) * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkcf"><span class="nb">rewrite</span> add_fsfun_succ_l, !fsfun_prod_succ, Hall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>index</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>EqDecision0</var><span class="hyp-type"><b>: </b><span>EqDecision index</span></span></span><br><span><var>multipliers</var><span class="hyp-type"><b>: </b><span>index â†’ Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>index</span></span></span><br><span><var>f1</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br><span><var>Hall</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">f2</span> : fsfun index <span class="mi">0</span>,
  fsfun_prod (add_fsfun f1 f2) =
  (fsfun_prod f1 * fsfun_prod f2)%Z</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>fsfun index <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(multipliers i * (fsfun_prod f1 * fsfun_prod f2))%Z =
(multipliers i * fsfun_prod f1 * fsfun_prod f2)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">sec_prod_powers</span>.</span></span></pre><div class="doc">
<a id="lab3"></a><h2 class="section">A Prime Factorization Result</h2>
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Instance</span> <span class="nf">prime_decision</span> : <span class="kr">forall</span> <span class="nv">n</span>, Decision (prime n) := prime_dec.</span></span></pre><div class="doc">
The type of prime numbers. 
</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">primes</span> : <span class="kt">Type</span> := dsig prime.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input">#[export] <span class="kn">Program Instance</span> <span class="nf">primes_inhabited</span> : Inhabited primes :=
  populate (dexist <span class="mi">2</span>%Z prime_2).</span></span></pre><div class="doc">
  Compute the product of powers of primes represented by <code>powers</code>.
  Since there are only finitely many of them, the result is well-defined.

</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prod_primes_powers</span> (<span class="nv">powers</span> : fsfun primes <span class="mi">0</span>) : Z :=
  fsfun_prod (<span class="kr">fun</span> <span class="nv">p</span> : primes =&gt; ` p) powers.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd0"><span class="kn">Lemma</span> <span class="nf">not_prime_divide_prime</span> :
  <span class="kr">forall</span> (<span class="nv">n</span> : Z),
    (n &gt; <span class="mi">1</span>)%Z -&gt; ~ prime n -&gt;
      <span class="kr">exists</span> (<span class="nv">m</span> : Z), prime m /\ <span class="kr">exists</span> (<span class="nv">q</span> : Z), (<span class="mi">2</span> &lt;= q &lt; n)%Z /\ n = (q * m)%Z.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : Z,
  (n &gt; <span class="mi">1</span>)%Z
  â†’ Â¬ prime n
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : Z,
  (n &gt; <span class="mi">1</span>)%Z
  â†’ Â¬ prime n
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd2"><span class="nb">pose</span> (P := <span class="kr">fun</span> <span class="nv">n</span> =&gt;  ~ prime n -&gt;
    <span class="kr">exists</span> (<span class="nv">m</span> : Z), prime m /\ <span class="kr">exists</span> (<span class="nv">q</span> : Z), (<span class="mi">2</span> &lt;= q &lt; n)%Z /\ n = (q * m)%Z).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Î»</span> <span class="nv">n</span> : Z,
  Â¬ prime n
  â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
      prime m
      âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</span></span><span class="hyp-type"><b>: </b><span>Z â†’ <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : Z,
  (n &gt; <span class="mi">1</span>)%Z
  â†’ Â¬ prime n
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd3"><span class="nb">cut</span> (<span class="kr">forall</span> <span class="nv">n</span> : Z, (<span class="mi">2</span> &lt;= n)%Z -&gt; P n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Î»</span> <span class="nv">n</span> : Z,
  Â¬ prime n
  â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
      prime m
      âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</span></span><span class="hyp-type"><b>: </b><span>Z â†’ <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">n</span> : Z, (<span class="mi">2</span> â‰¤ n)%Z â†’ P n)
â†’ <span class="kr">âˆ€</span> <span class="nv">n</span> : Z,
    (n &gt; <span class="mi">1</span>)%Z
    â†’ Â¬ prime n
      â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
          prime m
          âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Î»</span> <span class="nv">n</span> : Z,
  Â¬ prime n
  â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
      prime m
      âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</span></span><span class="hyp-type"><b>: </b><span>Z â†’ <span class="kt">Prop</span></span></span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkd4"><hr></label><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : Z, (<span class="mi">2</span> â‰¤ n)%Z â†’ P n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Î»</span> <span class="nv">n</span> : Z,
  Â¬ prime n
  â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
      prime m
      âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</span></span><span class="hyp-type"><b>: </b><span>Z â†’ <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">âˆ€</span> <span class="nv">n</span> : Z, (<span class="mi">2</span> â‰¤ n)%Z â†’ P n)
â†’ <span class="kr">âˆ€</span> <span class="nv">n</span> : Z,
    (n &gt; <span class="mi">1</span>)%Z
    â†’ Â¬ prime n
      â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
          prime m
          âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span> HP n Hn1 Hnp; <span class="nb">apply</span> HP; [<span class="bp">lia</span> |].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Î»</span> <span class="nv">n</span> : Z,
  Â¬ prime n
  â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
      prime m
      âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</span></span><span class="hyp-type"><b>: </b><span>Z â†’ <span class="kt">Prop</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : Z, (<span class="mi">2</span> â‰¤ n)%Z â†’ P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd7"><span class="nb">apply</span> Zlt_lower_bound_ind; <span class="nb">subst</span> P; <span class="nb">cbn</span>; <span class="nb">intros</span> n Hind Hn2 Hnp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br><span><var>Hnp</var><span class="hyp-type"><b>: </b><span>Â¬ prime n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
  prime m âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z, (<span class="mi">2</span> â‰¤ q &lt; n)%Z âˆ§ n = (q * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd8"><span class="nb">apply</span> not_prime_divide <span class="kr">in</span> Hnp <span class="kr">as</span> (p &amp; [Hp1 Hpn] &amp; q &amp; -&gt;); [| <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
  prime m
  âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z,
       (<span class="mi">2</span> â‰¤ q0 &lt; q * p)%Z âˆ§ (q * p)%Z = (q0 * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkd9"><span class="nb">destruct</span> (decide (prime p)) <span class="kr">as</span> [| Hnp].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>prime p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
  prime m
  âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z,
       (<span class="mi">2</span> â‰¤ q0 &lt; q * p)%Z âˆ§ (q * p)%Z = (q0 * m)%Z)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkda" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>Hnp</var><span class="hyp-type"><b>: </b><span>Â¬ prime p</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkda"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
  prime m
  âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z,
       (<span class="mi">2</span> â‰¤ q0 &lt; q * p)%Z âˆ§ (q * p)%Z = (q0 * m)%Z)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkdb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>prime p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
  prime m
  âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z,
       (<span class="mi">2</span> â‰¤ q0 &lt; q * p)%Z âˆ§ (q * p)%Z = (q0 * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkdc"><span class="kr">exists</span> <span class="nv">p</span>; <span class="nb">split</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>prime p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z, (<span class="mi">2</span> â‰¤ q0 &lt; q * p)%Z âˆ§ (q * p)%Z = (q0 * p)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkdd"><span class="nb">eexists</span>; <span class="nb">split</span>; [| <span class="bp">done</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>p0</var><span class="hyp-type"><b>: </b><span>prime p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> â‰¤ q &lt; q * p)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="bp">nia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkde">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>Hnp</var><span class="hyp-type"><b>: </b><span>Â¬ prime p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
  prime m
  âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z,
       (<span class="mi">2</span> â‰¤ q0 &lt; q * p)%Z âˆ§ (q * p)%Z = (q0 * m)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkdf"><span class="nb">apply</span> Hind <span class="kr">in</span> Hnp <span class="kr">as</span> (m &amp; Hmprime &amp; q&#39; &amp; Hq&#39; &amp; -&gt;); [| <span class="bp">by</span> <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>q, m, q'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q&#39; &lt; q&#39; * m)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(q&#39; * m &lt; q * (q&#39; * m))%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; q&#39; * m)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * (q&#39; * m))%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * (q&#39; * m))%Z</span></span></span><br><span><var>Hmprime</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">m0</span> : Z,
  prime m0
  âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z,
       (<span class="mi">2</span> â‰¤ q0 &lt; q * (q&#39; * m))%Z
       âˆ§ (q * (q&#39; * m))%Z = (q0 * m0)%Z)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke0"><span class="kr">exists</span> <span class="nv">m</span>; <span class="nb">split</span>; [<span class="bp">done</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>q, m, q'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q&#39; &lt; q&#39; * m)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(q&#39; * m &lt; q * (q&#39; * m))%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; q&#39; * m)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * (q&#39; * m))%Z
  â†’ Â¬ prime y
    â†’ <span class="kr">âˆƒ</span> <span class="nv">m</span> : Z,
        prime m
        âˆ§ (<span class="kr">âˆƒ</span> <span class="nv">q</span> : Z,
             (<span class="mi">2</span> â‰¤ q &lt; y)%Z âˆ§ y = (q * m)%Z)</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * (q&#39; * m))%Z</span></span></span><br><span><var>Hmprime</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">q0</span> : Z,
  (<span class="mi">2</span> â‰¤ q0 &lt; q * (q&#39; * m))%Z
  âˆ§ (q * (q&#39; * m))%Z = (q0 * m)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">q</span> * q&#39;)%Z; <span class="nb">split</span>; <span class="bp">nia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke1"><span class="kn">Lemma</span> <span class="nf">primes_factorization</span> :
  <span class="kr">forall</span> (<span class="nv">n</span> : Z),
    (n &gt; <span class="mi">1</span>)%Z -&gt;
    <span class="kr">exists</span> (<span class="nv">ps</span> : fsfun primes <span class="mi">0</span>),
      fin_supp ps &lt;&gt; [] /\ n = prod_primes_powers ps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : Z,
  (n &gt; <span class="mi">1</span>)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆ€</span> <span class="nv">n</span> : Z,
  (n &gt; <span class="mi">1</span>)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke3"><span class="nb">intros</span> n H_n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H_n</var><span class="hyp-type"><b>: </b><span>(n &gt; <span class="mi">1</span>)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke4"><span class="nb">assert</span> (Hn : (<span class="mi">2</span> &lt;= n)%Z) <span class="bp">by</span> <span class="bp">lia</span>; <span class="nb">clear</span> H_n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke5"><span class="nb">revert</span> n Hn; <span class="nb">apply</span> Zlt_lower_bound_ind; <span class="nb">intros</span> n Hind Hn2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke6"><span class="nb">destruct</span> (decide (prime n)) <span class="kr">as</span> [| Hnp].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prime n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chke7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br><span><var>Hnp</var><span class="hyp-type"><b>: </b><span>Â¬ prime n</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chke7"><hr></label><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prime n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chke9"><span class="kr">exists</span> (<span class="nv">delta_nat_fsfun</span> (dexist n p)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prime n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_supp (delta_nat_fsfun (dexist n p)) â‰  []
âˆ§ n =
  prod_primes_powers (delta_nat_fsfun (dexist n p))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkea"><span class="nb">split</span>; [| <span class="bp">by</span> <span class="nb">unfold</span> prod_primes_powers; <span class="nb">rewrite</span> prod_powers_delta].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>prime n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_supp (delta_nat_fsfun (dexist n p)) â‰  []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> elem_of_not_nil, elem_of_delta_nat_fsfun.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkeb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; n)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ n)%Z</span></span></span><br><span><var>Hnp</var><span class="hyp-type"><b>: </b><span>Â¬ prime n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ n = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkec"><span class="nb">apply</span> not_prime_divide <span class="kr">in</span> Hnp <span class="kr">as</span> (p &amp; [Hp1 Hpn] &amp; q &amp; -&gt;); [| <span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ (q * p)%Z = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chked"><span class="nb">assert</span> (Hq1 : (<span class="mi">1</span> &lt; q)%Z) <span class="bp">by</span> <span class="bp">nia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; q)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ (q * p)%Z = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkee"><span class="nb">assert</span> (Hqn : (q &lt; q * p)%Z) <span class="bp">by</span> <span class="bp">nia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * p)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * p)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; p)%Z</span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(p &lt; q * p)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; q)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(q &lt; q * p)%Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps â‰  [] âˆ§ (q * p)%Z = prod_primes_powers ps</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkef"><span class="nb">destruct</span> (Hind p) <span class="kr">as</span> (ps &amp; Hdomps &amp; -&gt;); [<span class="bp">by</span> <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>q</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 q * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt; q * prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> â‰¤ q * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; q)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(q &lt; q * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>fin_supp ps â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps0</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps0 â‰  []
  âˆ§ (q * prod_primes_powers ps)%Z =
    prod_primes_powers ps0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkf0"><span class="nb">destruct</span> (Hind q) <span class="kr">as</span> (qs &amp; Hdomqs &amp; -&gt;); [<span class="bp">by</span> <span class="bp">lia</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>fin_supp ps â‰  []</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">âˆƒ</span> <span class="nv">ps0</span> : fsfun primes <span class="mi">0</span>,
  fin_supp ps0 â‰  []
  âˆ§ (prod_primes_powers qs * prod_primes_powers ps)%Z =
    prod_primes_powers ps0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkf1"><span class="kr">exists</span> (<span class="nv">add_fsfun</span> <span class="nv">qs</span> <span class="nv">ps</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>fin_supp ps â‰  []</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_supp (add_fsfun qs ps) â‰  []
âˆ§ (prod_primes_powers qs * prod_primes_powers ps)%Z =
  prod_primes_powers (add_fsfun qs ps)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkf2"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>fin_supp ps â‰  []</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_supp (add_fsfun qs ps) â‰  []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="NatExtras-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>fin_supp ps â‰  []</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br></div><label class="goal-separator" for="NatExtras-v-chkf3"><hr></label><div class="goal-conclusion">(prod_primes_powers qs * prod_primes_powers ps)%Z =
prod_primes_powers (add_fsfun qs ps)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkf4">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>fin_supp ps â‰  []</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_supp (add_fsfun qs ps) â‰  []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkf5"><span class="nb">apply</span> not_null_element <span class="kr">in</span> Hdomps.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>dsig (<span class="kr">Î»</span> <span class="nv">i</span> : primes, i âˆˆ fin_supp ps)</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_supp (add_fsfun qs ps) â‰  []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkf6">destruct_dec_sig Hdomps i Hi Heq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>dsig (<span class="kr">Î»</span> <span class="nv">i</span> : primes, i âˆˆ fin_supp ps)</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>primes</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>i âˆˆ fin_supp ps</span></span></span><br><span><var>Heq</var><span class="hyp-type"><b>: </b><span>Hdomps = dexist i Hi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fin_supp (add_fsfun qs ps) â‰  []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eapply</span> elem_of_not_nil, elem_of_add_fsfun; <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="NatExtras-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="NatExtras-v-chkf7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ps, qs</var><span class="hyp-type"><b>: </b><span>fsfun primes <span class="mi">0</span></span></span></span><br><span><var>Hpn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers ps &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hp1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers ps)%Z</span></span></span><br><span><var>Hqn</var><span class="hyp-type"><b>: </b><span>(prod_primes_powers qs &lt;
 prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hq1</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt; prod_primes_powers qs)%Z</span></span></span><br><span><var>Hn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span>
 â‰¤ prod_primes_powers qs * prod_primes_powers ps)%Z</span></span></span><br><span><var>Hind</var><span class="hyp-type"><b>: </b><span><span class="kr">âˆ€</span> <span class="nv">y</span> : Z,
  (<span class="mi">2</span> â‰¤ y &lt;
   prod_primes_powers qs *
   prod_primes_powers ps)%Z
  â†’ <span class="kr">âˆƒ</span> <span class="nv">ps</span> : fsfun primes <span class="mi">0</span>,
      fin_supp ps â‰  []
      âˆ§ y = prod_primes_powers ps</span></span></span><br><span><var>Hdomps</var><span class="hyp-type"><b>: </b><span>fin_supp ps â‰  []</span></span></span><br><span><var>Hdomqs</var><span class="hyp-type"><b>: </b><span>fin_supp qs â‰  []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(prod_primes_powers qs * prod_primes_powers ps)%Z =
prod_primes_powers (add_fsfun qs ps)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">symmetry</span>; <span class="nb">apply</span> prod_powers_add.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>