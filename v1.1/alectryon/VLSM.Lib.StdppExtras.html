<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>StdppExtras.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> prelude.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> VLSM.Lib <span class="kn">Require Import</span> ListExtras.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk0"><span class="kn">Lemma</span> <span class="nf">elem_of_take</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) (<span class="nv">x</span> : A) :
  elem_of x (take n l) -&gt; elem_of x l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ take n l → x ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ take n l → x ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2"><span class="nb">generalize dependent</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3"><span class="nb">induction</span> l; <span class="nb">intros</span> n H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n (a :: l)</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk4"><hr></label><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> n; <span class="nb">simpl</span> <span class="kr">in</span> H; <span class="nb">inversion</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take <span class="mi">0</span> (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take (S n) (a :: l)</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chka"><hr></label><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take <span class="mi">0</span> (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take (S n) (a :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke"><span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ a :: take n l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf"><span class="nb">apply</span> elem_of_cons <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x = a ∨ x ∈ take n l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk10"><span class="nb">destruct</span> H <span class="kr">as</span> [H|H].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n l</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk11"><hr></label><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk12">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk13"><span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, a ∈ take n l → a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk14"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, a ∈ take n l → a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk15">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk16"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk17"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, x ∈ take n l → x ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x ∈ take n l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk18"><span class="kn">Lemma</span> <span class="nf">map_skipn</span> [A B : <span class="kt">Type</span>] (f : A -&gt; B) (l : list A) (n : nat) :
  map f (skipn n l) = skipn n (map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n l) = drop n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk19"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n l) = drop n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1a"><span class="nb">generalize dependent</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1b"><span class="nb">induction</span> l; <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n []) = drop n (map f [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk1c"><hr></label><div class="goal-conclusion">map f (drop n (a :: l)) = drop n (map f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n []) = drop n (map f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n []) = drop n []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk1f"><span class="kp">repeat</span> <span class="nb">rewrite</span> skipn_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f [] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk20">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n (a :: l)) = drop n (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk21"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n (a :: l)) = drop n (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk22"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop <span class="mi">0</span> (a :: l)) = drop <span class="mi">0</span> (f a :: map f l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk23"><hr></label><div class="goal-conclusion">map f (drop (S n) (a :: l)) =
drop (S n) (f a :: map f l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk24">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop <span class="mi">0</span> (a :: l)) = drop <span class="mi">0</span> (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk25">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop (S n) (a :: l)) =
drop (S n) (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk26"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (drop n l) = drop n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (drop n l) = drop n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IHl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk27"><span class="kn">Lemma</span> <span class="nf">map_firstn</span> [A B : <span class="kt">Type</span>] (f : A -&gt; B) (l : list A) (n : nat) :
  map f (firstn n l) = firstn n (map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take n l) = take n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk28"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take n l) = take n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk29"><span class="nb">generalize dependent</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2a"><span class="nb">induction</span> l; <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take n []) = take n (map f [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk2b"><hr></label><div class="goal-conclusion">map f (take n (a :: l)) = take n (map f (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take n []) = take n (map f [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2d"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take n []) = take n []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2e"><span class="kp">repeat</span> <span class="nb">rewrite</span> firstn_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f [] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk2f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take n (a :: l)) = take n (map f (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk30"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take n (a :: l)) = take n (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk31"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take <span class="mi">0</span> (a :: l)) = take <span class="mi">0</span> (f a :: map f l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk32"><hr></label><div class="goal-conclusion">map f (take (S n) (a :: l)) =
take (S n) (f a :: map f l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk33">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take <span class="mi">0</span> (a :: l)) = take <span class="mi">0</span> (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk34">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (take (S n) (a :: l)) =
take (S n) (f a :: map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk35"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a :: map f (take n l) = f a :: take n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk36"><span class="nb">rewrite</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">n</span> : nat, map f (take n l) = take n (map f l)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a :: take n (map f l) = f a :: take n (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk37"><span class="kn">Lemma</span> <span class="nf">skipn_S_tail</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) :
  skipn (S n) l = (skipn n (tail l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) l = drop n (tail l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) l = drop n (tail l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk39"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) [] = drop n (tail [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk3a"><hr></label><div class="goal-conclusion">drop (S n) (a :: l) = drop n (tail (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) [] = drop n (tail [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = drop n []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3d"><span class="nb">rewrite</span> drop_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) (a :: l) = drop n (tail (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk3f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n l = drop n l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk40"><span class="kn">Lemma</span> <span class="nf">skipn_tail_comm</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) (<span class="nv">n</span> : nat) :
  skipn n (tail l) = tail (skipn n l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n (tail l) = tail (drop n l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk41"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop n (tail l) = tail (drop n l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk42"><span class="nb">generalize dependent</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk43"><span class="nb">induction</span> n; <span class="nb">intros</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop <span class="mi">0</span> (tail l) = tail (drop <span class="mi">0</span> l)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk44"><hr></label><div class="goal-conclusion">drop (S n) (tail l) = tail (drop (S n) l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk45">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop <span class="mi">0</span> (tail l) = tail (drop <span class="mi">0</span> l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk46"><span class="kp">repeat</span> <span class="nb">rewrite</span> drop_0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tail l = tail l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) (tail l) = tail (drop (S n) l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk48"><span class="nb">destruct</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) (tail []) = tail (drop (S n) [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk49"><hr></label><div class="goal-conclusion">drop (S n) (tail (a :: l)) =
tail (drop (S n) (a :: l))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) (tail []) = tail (drop (S n) [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4b">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) (tail (a :: l)) =
tail (drop (S n) (a :: l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4c"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) l = tail (drop n l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4d"><span class="nb">rewrite</span> &lt;- IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">l</span> : list A, drop n (tail l) = tail (drop n l)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">drop (S n) l = drop n (tail l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> skipn_S_tail.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4e"><span class="kn">Lemma</span> <span class="nf">map_tail</span> [A B : <span class="kt">Type</span>] (f : A -&gt; B) (l : list A) :
  map f (tail l) = tail (map f l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (tail l) = tail (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk4f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A, B</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → B</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map f (tail l) = tail (map f l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> l; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk50"><span class="kn">Lemma</span> <span class="nf">nth_error_stdpp_last</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) :
  nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk51"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk52"><span class="nb">induction</span> l; [<span class="bp">reflexivity</span>|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth_error l (length l - <span class="mi">1</span>) = <span class="nb">last</span> l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (a :: l) (length l - <span class="mi">0</span>) = <span class="nb">last</span> (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk53"><span class="nb">destruct</span> l; [<span class="bp">reflexivity</span>|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth_error (a0 :: l) (length (a0 :: l) - <span class="mi">1</span>) = <span class="nb">last</span> (a0 :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (a0 :: l) (length l) = <span class="nb">last</span> (a0 :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk54"><span class="nb">simpl</span> <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth_error (a0 :: l) (length l - <span class="mi">0</span>) = <span class="nb">last</span> (a0 :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (a0 :: l) (length l) = <span class="nb">last</span> (a0 :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk55"><span class="nb">rewrite</span> Nat.sub_0_r <span class="kr">in</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>nth_error (a0 :: l) (length l) = <span class="nb">last</span> (a0 :: l)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth_error (a0 :: l) (length l) = <span class="nb">last</span> (a0 :: l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHl; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk56"><span class="kn">Lemma</span> <span class="nf">last_last_error</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">l</span> : list A) :
 last_error l = <span class="nb">last</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error l = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error l = <span class="nb">last</span> l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk58"><span class="nb">induction</span> l; [<span class="bp">reflexivity</span>|]; <span class="nb">rewrite</span> last_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>last_error l = <span class="nb">last</span> l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error (a :: l) =
<span class="kr">match</span> <span class="nb">last</span> l <span class="kr">with</span>
| Some y =&gt; Some y
| None =&gt; Some a
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk59"><span class="nb">rewrite</span> &lt;- IHl; <span class="nb">clear</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">last_error (a :: l) =
<span class="kr">match</span> last_error l <span class="kr">with</span>
| Some y =&gt; Some y
| None =&gt; Some a
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5a"><span class="nb">destruct</span> l; [<span class="bp">reflexivity</span>|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; a0
  | _ :: _ =&gt; List.<span class="nb">last</span> l a
  <span class="kr">end</span> = Some (List.<span class="nb">last</span> l a0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5b"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a0
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> = List.<span class="nb">last</span> l a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5c"><span class="nb">induction</span> l; [<span class="bp">reflexivity</span>|]; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0, a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a0
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> = List.<span class="nb">last</span> l a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> =
<span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt; List.<span class="nb">last</span> l a0
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5d"><span class="nb">rewrite</span> &lt;- IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>a, a0, a1</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a0
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> = List.<span class="nb">last</span> l a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt; List.<span class="nb">last</span> l a
<span class="kr">end</span> =
<span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; a1
| _ :: _ =&gt;
    <span class="kr">match</span> l <span class="kr">with</span>
    | [] =&gt; a0
    | _ :: _ =&gt; List.<span class="nb">last</span> l a
    <span class="kr">end</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> l; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5e"><span class="kn">Lemma</span> <span class="nf">existsb_Exists</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; bool):
  <span class="kr">forall</span> <span class="nv">l</span>, existsb f l = true &lt;-&gt; Exists (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x = true) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = true ↔ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk5f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = true ↔ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk60"><span class="nb">intro</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb f l = true ↔ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk61"><span class="nb">rewrite</span> Exists_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb f l = true ↔ (<span class="kr">∃</span> <span class="nv">x</span> : A, x ∈ l ∧ f x = true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk62"><span class="nb">rewrite</span> existsb_exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∃</span> <span class="nv">x</span> : A, In x l ∧ f x = true)
↔ (<span class="kr">∃</span> <span class="nv">x</span> : A, x ∈ l ∧ f x = true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk63"><span class="nb">setoid_rewrite</span> elem_of_list_In.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∃</span> <span class="nv">x</span> : A, In x l ∧ f x = true)
↔ (<span class="kr">∃</span> <span class="nv">x</span> : A, In x l ∧ f x = true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk64"><span class="kn">Lemma</span> <span class="nf">Exists_last</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">l</span> : list A)
  (<span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>)
  (<span class="nv">Pdec</span> : <span class="kr">forall</span> <span class="nv">a</span>, Decision (P a))
  (<span class="nv">Hsomething</span> : Exists P l)
  : <span class="kr">exists</span> (<span class="nv">prefix</span> : list A)
         (<span class="nv">suffix</span> : list A)
         (<span class="nv">last</span> : A),
         P <span class="nb">last</span> /\
         l = prefix ++ [<span class="nb">last</span>] ++ suffix /\
         ~Exists P suffix.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk65"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk66"><span class="nb">induction</span> l <span class="nb">using</span> rev_ind;[<span class="kp">solve</span>[<span class="nb">inversion</span> Hsomething]|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk67"><span class="nb">destruct</span> (decide (P x)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk68"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk69">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6a"><span class="kr">exists</span> <span class="nv">l</span>, nil, x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x ∧ l ++ [x] = l ++ [x] ++ [] ∧ ¬ Exists P []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6b"><span class="nb">rewrite</span> Exists_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x ∧ l ++ [x] = l ++ [x] ++ [] ∧ ¬ <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P (l ++ [x])</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6d"><span class="nb">apply</span> Exists_app <span class="kr">in</span> Hsomething.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>Exists P l ∨ Exists P [x]</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk6e"><span class="nb">destruct</span> Hsomething.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P l</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk6f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P [x]</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk6f"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk70"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P [x]</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk71"><span class="nb">inversion</span> H; <span class="nb">subst</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P [x]</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk72" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P [x]</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Exists P []</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk72"><hr></label><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk73"><span class="bp">contradiction</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P [x]</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Exists P []</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion</span> H1.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk74">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>Exists P l</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>Exists P l
→ <span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
    P <span class="nb">last</span>
    ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
      ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk75"><span class="nb">specialize</span> (IHl H);<span class="nb">clear</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  P <span class="nb">last</span>
  ∧ l ++ [x] = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists P suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk76"><span class="nb">destruct</span> IHl <span class="kr">as</span> [prefix [suffix [<span class="nb">last</span> [Hf [-&gt; Hnone_after]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix0</span> <span class="nv">suffix0</span> : list A) (<span class="nv">last0</span> : A),
  P last0
  ∧ (prefix ++ [<span class="nb">last</span>] ++ suffix) ++ [x] =
    prefix0 ++ [last0] ++ suffix0 ∧ ¬ 
    Exists P suffix0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk77"><span class="kr">exists</span> <span class="nv">prefix</span>, (suffix ++ [x]), <span class="nb">last</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ (prefix ++ [<span class="nb">last</span>] ++ suffix) ++ [x] =
  prefix ++ [<span class="nb">last</span>] ++ suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk78"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ (prefix ++ <span class="nb">last</span> :: suffix) ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk79"><span class="nb">rewrite</span> app_assoc_reverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ (<span class="nb">last</span> :: suffix) ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7a"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ Exists P (suffix ++ [x])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7b"><span class="nb">rewrite</span> Exists_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ (Exists P suffix ∨ Exists P [x])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7c"><span class="nb">rewrite</span> Exists_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ (Exists P suffix ∨ P x ∨ Exists P [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7d"><span class="nb">rewrite</span> Exists_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>Pdec</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (P a)</span></span></span><br><span><var>prefix, suffix</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>last</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>P <span class="nb">last</span></span></span></span><br><span><var>Hnone_after</var><span class="hyp-type"><b>: </b><span>¬ Exists P suffix</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P <span class="nb">last</span>
∧ prefix ++ <span class="nb">last</span> :: suffix ++ [x] =
  prefix ++ <span class="nb">last</span> :: suffix ++ [x]
  ∧ ¬ (Exists P suffix ∨ P x ∨ <span class="kt">False</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7e"><span class="kn">Lemma</span> <span class="nf">existsb_last</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">l</span> : list A)
  (<span class="nv">f</span> : A -&gt; bool)
  (<span class="nv">Hsomething</span> : existsb f l = true) :
  <span class="kr">exists</span> (<span class="nv">prefix</span> : list A)
         (<span class="nv">suffix</span> : list A)
         (<span class="nv">last</span> : A),
         (f <span class="nb">last</span> = true) /\
         l = prefix ++ [<span class="nb">last</span>] ++ suffix /\
         (existsb f suffix = false).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ existsb f suffix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ existsb f suffix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk80"><span class="nb">setoid_rewrite</span> &lt;-not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ existsb f suffix ≠ true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk81"><span class="nb">setoid_rewrite</span> existsb_Exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">last</span> : A),
  f <span class="nb">last</span> = true
  ∧ l = prefix ++ [<span class="nb">last</span>] ++ suffix
    ∧ ¬ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) suffix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk82"><span class="nb">apply</span> Exists_last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk83"><hr></label><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk84">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> a; solve_decision.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk85">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> existsb_Exists;<span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk86"><span class="kn">Lemma</span> <span class="nf">existsb_forall</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; bool):
  <span class="kr">forall</span> <span class="nv">l</span>, existsb f l = false &lt;-&gt; <span class="kr">forall</span> <span class="nv">x</span>, In x l -&gt; f x = false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = false
  ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x = false)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk87"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">l</span> : list A,
  existsb f l = false
  ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x = false)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk88"><span class="nb">intro</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb f l = false ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x = false)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk89"><span class="nb">setoid_rewrite</span> &lt;- not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">existsb f l ≠ true ↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x ≠ true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8a"><span class="nb">rewrite</span> existsb_Exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l
↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x ≠ true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8b"><span class="nb">rewrite</span> &lt;- Forall_Exists_neg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (<span class="kr">λ</span> <span class="nv">x</span> : A, f x ≠ true) l
↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x ≠ true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8c"><span class="nb">rewrite</span> Forall_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → f x ≠ true)
↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x ≠ true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8d"><span class="nb">setoid_rewrite</span> -&gt; elem_of_list_In.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x ≠ true)
↔ (<span class="kr">∀</span> <span class="nv">x</span> : A, In x l → f x ≠ true)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8e"><span class="kn">Lemma</span> <span class="nf">existsb_first</span>
  {<span class="nv">A</span> : <span class="kt">Type</span>}
  (<span class="nv">l</span> : list A)
  (<span class="nv">f</span> : A -&gt; bool)
  (<span class="nv">Hsomething</span> : existsb f l = true) :
  <span class="kr">exists</span> (<span class="nv">prefix</span> : list A)
         (<span class="nv">suffix</span> : list A)
         (<span class="nv">first</span> : A),
         (f <span class="kp">first</span> = true) /\
         l = prefix ++ [<span class="kp">first</span>] ++ suffix /\
         (existsb f prefix = false).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ existsb f prefix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk8f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ existsb f prefix = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk90"><span class="nb">setoid_rewrite</span> &lt;-not_true_iff_false.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ existsb f prefix ≠ true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk91"><span class="nb">setoid_rewrite</span> existsb_Exists.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∃</span> (<span class="nv">prefix</span> <span class="nv">suffix</span> : list A) (<span class="nv">first</span> : A),
  f <span class="kp">first</span> = true
  ∧ l = prefix ++ [<span class="kp">first</span>] ++ suffix
    ∧ ¬ Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) prefix</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk92"><span class="nb">apply</span> Exists_first.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk93"><hr></label><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk94">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, Decision (f a = true)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk95"><span class="nb">intro</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (f a = true)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">solve_decision.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk96">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A → bool</span></span></span><br><span><var>Hsomething</var><span class="hyp-type"><b>: </b><span>existsb f l = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Exists (<span class="kr">λ</span> <span class="nv">x</span> : A, f x = true) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> existsb_Exists;<span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Returns all elements X of l such that X does not compare less</span>
<span class="c">   than any other element w.r.t to the preceeds relation *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">get_maximal_elements</span>
  {<span class="nv">A</span>} (<span class="nv">preceeds</span>: relation A) `{!RelDecision preceeds} (l : list A)
  : list A :=
  filter (<span class="kr">fun</span> <span class="nv">a</span> =&gt; Forall (<span class="kr">fun</span> <span class="nv">b</span> =&gt; (~ preceeds a b)) l) l.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk97"><span class="kn">Example</span> <span class="nf">get_maximal_elements1</span>: get_maximal_elements Nat.lt [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [<span class="mi">4</span>;<span class="mi">4</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">get_maximal_elements Nat.lt [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [<span class="mi">4</span>; <span class="mi">4</span>]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk98"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">get_maximal_elements Nat.lt [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [<span class="mi">4</span>; <span class="mi">4</span>]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk99"><span class="kn">Example</span> <span class="nf">get_maximal_elements2</span> : get_maximal_elements Nat.le [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">get_maximal_elements Nat.le [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">get_maximal_elements Nat.le [<span class="mi">1</span>; <span class="mi">4</span>; <span class="mi">2</span>; <span class="mi">4</span>] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9b"><span class="kn">Lemma</span> <span class="nf">filter_ext_elem_of</span> {<span class="nv">A</span>} <span class="nv">P</span> <span class="nv">Q</span>
 `{<span class="kr">∀</span> (<span class="nv">x</span>:A), Decision (P x)} `{<span class="kr">∀</span> (<span class="nv">x</span>:A), Decision (Q x)} (l:list A) :
 (<span class="kr">forall</span> <span class="nv">a</span>, a ∈ l -&gt; (P a &lt;-&gt; Q a)) -&gt;
 filter P l = filter Q l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9d"><span class="nb">induction</span> l; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ [] → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P [] = filter Q []</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chk9e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chk9e"><hr></label><div class="goal-conclusion">filter P (a :: l) = filter Q (a :: l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chk9f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ [] → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P [] = filter Q []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka0"><span class="nb">rewrite</span> <span class="mi">2</span> filter_nil.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ [] → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P (a :: l) = filter Q (a :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka2"><span class="nb">rewrite</span> <span class="mi">2</span> filter_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> decide (P a) <span class="kr">then</span> a :: filter P l <span class="kr">else</span> filter P l) =
(<span class="kr">if</span> decide (Q a) <span class="kr">then</span> a :: filter Q l <span class="kr">else</span> filter Q l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka3"><span class="nb">destruct</span> (decide (P a)); <span class="nb">destruct</span> (decide (Q a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: filter P l = a :: filter Q l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chka4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chka4"><hr></label><div class="goal-conclusion">a :: filter P l = filter Q l</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chka5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chka5"><hr></label><div class="goal-conclusion">filter P l = a :: filter Q l</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chka6"><hr></label><div class="goal-conclusion">filter P l = filter Q l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka7">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: filter P l = a :: filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka8"><span class="nb">rewrite</span> IHl; [<span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chka9"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a0 ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a0 ↔ Q a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkaa"><span class="nb">apply</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a0 ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0 ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkab">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a :: filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkac"><span class="bp">contradict</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkad"><span class="nb">apply</span> H1; [|<span class="bp">assumption</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkae">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = a :: filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkaf"><span class="bp">contradict</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb0"><span class="nb">apply</span> H1; [|<span class="bp">assumption</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">left</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb2"><span class="nb">apply</span> IHl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb3"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a0 ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a0 ↔ Q a0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb4"><span class="nb">apply</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>IHl</var><span class="hyp-type"><b>: </b><span>(<span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a) → filter P l = filter Q l</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a0</span> : A, a0 ∈ a :: l → P a0 ↔ Q a0</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br><span><var>a0</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a0 ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a0 ∈ a :: l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb5"><span class="kn">Lemma</span> <span class="nf">ext_elem_of_filter</span> {<span class="nv">A</span>} <span class="nv">P</span> <span class="nv">Q</span>
 `{<span class="kr">∀</span> (<span class="nv">x</span>:A), Decision (P x)} `{<span class="kr">∀</span> (<span class="nv">x</span>:A), Decision (Q x)}
 (l : list A) :
 filter P l = filter Q l -&gt; <span class="kr">forall</span> <span class="nv">a</span>, a ∈ l -&gt; (P a &lt;-&gt; Q a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l → <span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l → <span class="kr">∀</span> <span class="nv">a</span> : A, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkb8"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkb9"><hr></label><div class="goal-conclusion">P a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbb"><span class="nb">assert</span> (a ∈ filter P l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ filter P l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkbc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>a ∈ filter P l</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkbc"><hr></label><div class="goal-conclusion">Q a</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbd">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ filter P l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbe"><span class="nb">apply</span> elem_of_list_filter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ∧ a ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkbf">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>a ∈ filter P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc0"><span class="nb">rewrite</span> H1 <span class="kr">in</span> H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>a ∈ filter Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc1"><span class="nb">apply</span> elem_of_list_filter <span class="kr">in</span> H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>Q a ∧ a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H4; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc3"><span class="nb">assert</span> (a ∈ filter Q l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ filter Q l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>a ∈ filter Q l</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkc4"><hr></label><div class="goal-conclusion">P a</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∈ filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc6"><span class="nb">apply</span> elem_of_list_filter.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Q a ∧ a ∈ l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">split</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>a ∈ filter Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc8"><span class="nb">rewrite</span> &lt;- H1 <span class="kr">in</span> H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>a ∈ filter P l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkc9"><span class="nb">apply</span> elem_of_list_filter <span class="kr">in</span> H4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>A → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>P a ∧ a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H4; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkca"><span class="kn">Lemma</span> <span class="nf">filter_complement</span> {<span class="nv">X</span>} <span class="nv">P</span> <span class="nv">Q</span>
 `{<span class="kr">∀</span> (<span class="nv">x</span>:X), Decision (P x)} `{<span class="kr">∀</span> (<span class="nv">x</span>:X), Decision (Q x)}
 (l : list X) :
 filter P l = filter Q l &lt;-&gt;
 filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ~ P x) l = filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ~ Q x) l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l
↔ filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
  filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkcb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l
↔ filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
  filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkcc"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l = filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkcd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkcd"><hr></label><div class="goal-conclusion">filter P l = filter Q l</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l = filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkcf"><span class="nb">specialize</span> (ext_elem_of_filter P Q l H1) <span class="kr">as</span> Hext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l = filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd0"><span class="nb">apply</span> filter_ext_elem_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → ¬ P a ↔ ¬ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd1"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ P a ↔ ¬ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd2"><span class="nb">specialize</span> (Hext a H2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>P a ↔ Q a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ P a ↔ ¬ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd3"><span class="nb">rewrite</span> Hext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter P l = filter Q l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>P a ↔ Q a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ Q a ↔ ¬ Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intuition</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd5"><span class="nb">specialize</span> (ext_elem_of_filter _ _ l H1) <span class="kr">as</span> Hext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X,
  a ∈ l
  → (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">filter P l = filter Q l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd6"><span class="nb">apply</span> filter_ext_elem_of.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X,
  a ∈ l
  → (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">a</span> : X, a ∈ l → P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd7"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">a</span> : X,
  a ∈ l
  → (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd8"><span class="nb">specialize</span> (Hext a H2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkd9"><span class="nb">destruct</span> (decide (P a)); <span class="nb">destruct</span> (decide (Q a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkda" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkda"><hr></label><div class="goal-conclusion">P a ↔ Q a</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkdb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkdb"><hr></label><div class="goal-conclusion">P a ↔ Q a</div></blockquote><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkdc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkdc"><hr></label><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkdd">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkde">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkdf"><span class="nb">apply</span> Hext <span class="kr">in</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>P a</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradict</span> n; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke0">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke1"><span class="nb">apply</span> Hext <span class="kr">in</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradict</span> n; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke2">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>P, Q</var><span class="hyp-type"><b>: </b><span>X → <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (P x)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : X, Decision (Q x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) l =
filter (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) l</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>Hext</var><span class="hyp-type"><b>: </b><span>(<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ P x) a ↔ (<span class="kr">λ</span> <span class="nv">x</span> : X, ¬ Q x) a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>¬ P a</span></span></span><br><span><var>n0</var><span class="hyp-type"><b>: </b><span>¬ Q a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a ↔ Q a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke3"><span class="kn">Lemma</span> <span class="nf">NoDup_elem_of_remove</span> <span class="nv">A</span> (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A) <span class="nv">a</span> :
  NoDup (l ++ a :: l&#39;) -&gt; NoDup (l ++ l&#39;) /\ a ∉ (l ++ l&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ a :: l&#39;) → NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ a :: l&#39;) → NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke5"><span class="nb">intros</span> Hnda.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>NoDup (l ++ a :: l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke6"><span class="nb">apply</span> NoDup_app <span class="kr">in</span> Hnda.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>NoDup l
∧ (<span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;)
  ∧ NoDup (a :: l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke7"><span class="nb">destruct</span> Hnda <span class="kr">as</span> [Hnd [Ha Hnda]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>NoDup (a :: l&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke8"><span class="nb">apply</span> NoDup_cons <span class="kr">in</span> Hnda.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Hnda</var><span class="hyp-type"><b>: </b><span>(a ∉ l&#39;) ∧ NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;) ∧ a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chke9"><span class="nb">destruct</span> Hnda <span class="kr">as</span> [Ha&#39; Hnd&#39;]; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="StdppExtras-v-chkea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><label class="goal-separator" for="StdppExtras-v-chkea"><hr></label><div class="goal-conclusion">a ∉ l ++ l&#39;</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkeb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (l ++ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkec"><span class="nb">apply</span> NoDup_app; <span class="nb">split</span>; [<span class="bp">assumption</span>|<span class="nb">split</span>;[|<span class="bp">assumption</span>]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chked"><span class="nb">intros</span> x Hxl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hxl</var><span class="hyp-type"><b>: </b><span>x ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkee"><span class="nb">specialize</span> (Ha x Hxl).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br><span><var>Hxl</var><span class="hyp-type"><b>: </b><span>x ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x ∉ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> Hxl&#39;; <span class="bp">contradict</span> Ha; <span class="nb">right</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a ∉ l ++ l&#39;</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf0"><span class="nb">rewrite</span> elem_of_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">¬ (a ∈ l ∨ a ∈ l&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf1"><span class="nb">intro</span> Hal.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br><span><var>Hal</var><span class="hyp-type"><b>: </b><span>a ∈ l ∨ a ∈ l&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf2"><span class="nb">destruct</span> Hal <span class="kr">as</span> [Hal|Hal]; [|<span class="bp">contradiction</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span><span class="kr">∀</span> <span class="nv">x</span> : A, x ∈ l → x ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br><span><var>Hal</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="StdppExtras-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="StdppExtras-v-chkf3"><span class="nb">specialize</span> (Ha a Hal).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>l, l'</var><span class="hyp-type"><b>: </b><span>list A</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>Hnd</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>a ∉ a :: l&#39;</span></span></span><br><span><var>Ha'</var><span class="hyp-type"><b>: </b><span>a ∉ l&#39;</span></span></span><br><span><var>Hnd'</var><span class="hyp-type"><b>: </b><span>NoDup l&#39;</span></span></span><br><span><var>Hal</var><span class="hyp-type"><b>: </b><span>a ∈ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">contradict</span> Ha; <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>